{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Welcome to the Django Starter Template! <p> A comprehensive starting point for your new API with Django and DRF. </p>"},{"location":"#overview","title":"Overview","text":"<p>This documentation provides a comprehensive guide to the Django Starter Template, a robust foundation for building modern APIs with Django and Django REST Framework. It covers everything from initial setup and development workflows to advanced features like authentication, background tasks, and automated documentation.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>The recommended way to get started is by using the Dev Container feature in VS Code.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>To get started with the Dev Container, ensure you have the following installed:</p> <ul> <li>Visual Studio Code</li> <li>Docker Desktop</li> <li>Dev Containers extension for VS Code</li> </ul>"},{"location":"#setup-steps","title":"Setup Steps","text":"<p>Follow these steps to set up your development environment using the Dev Container:</p> <ol> <li> <p>Use the GitHub Template: Begin by creating your own repository from the Django Starter Template GitHub page by clicking the green <code>Use this template</code> button.</p> </li> <li> <p>Open in VS Code: Clone your newly created repository to your local machine and open the project folder in Visual Studio Code.</p> </li> <li> <p>Check the Setup Guide: Before proceeding, consult the <code>Todo Tree</code> view in the VS Code sidebar. This provides a guided checklist of initial setup tasks to ensure a smooth start.</p> </li> <li> <p>Reopen in Container: Upon opening the project, VS Code will prompt you to \"Reopen in Container.\" Click this option to build and launch the development environment. This process automatically configures essential services like Redis, Celery, and PostgreSQL, installs all project dependencies, and applies database migrations.</p> </li> <li> <p>Create a Superuser: Once the container is ready, create an administrative user for accessing the Django admin interface by running: <code>python manage.py createsuperuser</code>.</p> </li> <li> <p>Start the Server: Launch the Django development server with: <code>python manage.py runserver</code>.</p> </li> </ol> <p>Your API should now be running and accessible at <code>http://127.0.0.1:8000</code>.</p>"},{"location":"#key-features","title":"Key Features","text":"<p>This template comes equipped with a rich set of features designed to accelerate your API development:</p> <ul> <li>User Authentication: Implements secure, token-based authentication using <code>django-rest-knox</code>, providing a robust system for user management and access control.</li> <li>Background Tasks: Leverages <code>Celery</code> and <code>Redis</code> for efficient asynchronous task processing, enabling your application to handle long-running operations without blocking the main thread.</li> <li>API Documentation: Features automatic OpenAPI 3 schema generation with <code>drf-spectacular</code>, ensuring your API documentation is always up-to-date and easily explorable via Swagger UI.</li> <li>Centralized Logging: Provides a structured JSON logging system for comprehensive and easily parsable application logs, facilitating monitoring and debugging.</li> <li>Custom User Model: Utilizes a custom user model with email-based authentication, offering flexibility and a modern approach to user identity.</li> <li>GitHub Copilot Prompts: Includes a collection of useful prompts tailored to enhance your development experience with GitHub Copilot, boosting productivity.</li> <li>Comprehensive Documentation: This documentation serves as a detailed guide to all features and functionalities, helping you maximize the template's potential.</li> </ul>"},{"location":"#explore-the-documentation","title":"Explore the Documentation","text":"<p>This documentation is your comprehensive guide to building robust applications with the Django Starter Template. Use the navigation on the left to explore various aspects of the project:</p> <ul> <li>Development: Learn about the development workflow, including how to run tests, and utilize provided scripts.</li> <li>Project Structure: Gain an overview of the project's directory structure and organization.</li> <li>Project Settings: Understand the available settings and how to configure your project for different environments.</li> <li>Dependencies: Review a detailed list of all the project's dependencies and their purposes.</li> <li>Authentication: Dive into the authentication system, covering user management and API endpoints.</li> <li>Core Application: Discover the core functionalities and essential API endpoints provided by the <code>apps/core</code> application.</li> <li>Logging: Understand the structured logging system and how to effectively use it for monitoring and debugging.</li> <li>Celery Tasks: Learn how to create, manage, and monitor background tasks using Celery.</li> <li>Rate Limiting: Configure and understand rate limiting to protect your API from abuse and ensure fair usage.</li> <li>Database Seeding: Learn how to populate your database with initial data for development and testing.</li> <li>Testing: Understand how to write and run tests for your project to ensure code quality and reliability.</li> <li>Environment Setup: Get detailed instructions on setting up your development environment.</li> <li>AI Tools: Explore useful prompts to enhance your development experience with GitHub Copilot, Gemini CLI agent, and Roo Code.</li> </ul>"},{"location":"authentication/","title":"Authentication System","text":""},{"location":"authentication/#overview","title":"Overview","text":"<p>This section provides a comprehensive guide to the authentication system implemented in the Django Starter Template. It covers the core authentication endpoints, security settings, and how token-based authentication is managed.</p>"},{"location":"authentication/#authentication-settings","title":"Authentication Settings","text":"<p>The following settings in <code>conf/settings.py</code> are relevant to authentication and user management:</p> <ul> <li> <p><code>AUTH_USER_MODEL</code>: Specifies the custom user model to use. Default: <code>users.CustomUser</code>. This allows you to extend Django's default user model with custom fields and behaviors.</p> </li> <li> <p><code>MIN_PASSWORD_LENGTH</code>: Minimum length for user passwords. Default: <code>8</code> (loaded from <code>env.int(\"MIN_PASSWORD_LENGTH\", default=8)</code>). This is used by the password validation system.</p> </li> <li> <p><code>PASSWORD_HASHERS</code>: A list of password hashing algorithms used for storing user passwords. Default: A list including <code>ScryptPasswordHasher</code>, <code>PBKDF2PasswordHasher</code>, <code>PBKDF2SHA1PasswordHasher</code>, <code>Argon2PasswordHasher</code>, and <code>BCryptSHA256PasswordHasher</code>. This provides strong password security.</p> </li> <li> <p><code>AUTH_PASSWORD_VALIDATORS</code>: Configures password validation rules. Default: Includes validators for user attribute similarity, minimum length, common passwords, and numeric passwords. You can customize these to enforce stronger password policies.</p> </li> </ul>"},{"location":"authentication/#token-based-authentication","title":"Token-Based Authentication","text":"<p>The template uses <code>django-rest-knox</code> for secure, token-based authentication. This system provides a robust way to manage authentication tokens for users. The following settings, configured under <code>REST_KNOX</code> in <code>conf/settings.py</code>, control its behavior:</p> <ul> <li><code>SECURE_HASH_ALGORITHM</code>: Specifies the hashing algorithm for tokens. Default: <code>hashlib.sha512</code>.</li> <li><code>AUTH_TOKEN_CHARACTER_LENGTH</code>: Defines the length of the authentication token. Default: <code>64</code>.</li> <li><code>TOKEN_TTL</code>: Sets the time-to-live for tokens, determining how long they remain valid. Default: <code>timedelta(hours=10)</code>.</li> <li><code>USER_SERIALIZER</code>: Indicates the serializer used for user profiles. Default: <code>apps.users.serializers.UserProfileSerializer</code>.</li> <li><code>TOKEN_LIMIT_PER_USER</code>: Allows limiting the number of active tokens a single user can have. Default: <code>None</code> (no limit).</li> <li><code>AUTO_REFRESH</code>: Controls whether tokens are automatically refreshed upon use. Default: <code>False</code>.</li> <li><code>AUTO_REFRESH_MAX_TTL</code>: Sets the maximum time-to-live for auto-refreshed tokens. Default: <code>None</code>.</li> <li><code>MIN_REFRESH_INTERVAL</code>: Defines the minimum interval between token refreshes in seconds. Default: <code>60</code> seconds.</li> <li><code>AUTH_HEADER_PREFIX</code>: Specifies the prefix for the Authorization header (e.g., <code>Bearer</code>). Default: <code>Bearer</code>.</li> <li><code>TOKEN_MODEL</code>: Refers to the token model used by Knox. Default: <code>knox.AuthToken</code>.</li> </ul>"},{"location":"authentication/#rest-framework-settings","title":"REST Framework Settings","text":"<p>Django REST Framework (DRF) settings, particularly authentication classes and throttle rates, are configured to manage API access and prevent abuse:</p> <ul> <li> <p><code>DEFAULT_AUTHENTICATION_CLASSES</code>: Defines the authentication methods available for API endpoints. Default: <code>knox.auth.TokenAuthentication</code>. In <code>DEBUG</code> mode, <code>SessionAuthentication</code> and <code>BasicAuthentication</code> are also enabled for convenience.</p> </li> <li> <p><code>DEFAULT_THROTTLE_RATES</code>: Configures rate limiting to control the number of requests users can make within a given timeframe. Default:</p> <ul> <li><code>user: \"1000/day\"</code> (authenticated users)</li> <li><code>anon: \"100/day\"</code> (unauthenticated users)</li> <li><code>user_login: \"5/minute\"</code> (specific throttle for login attempts)</li> </ul> </li> </ul> <p>These rates can be adjusted in <code>conf/settings.py</code> to suit your application's specific needs and security requirements.</p>"},{"location":"authentication/#authentication-endpoints","title":"Authentication Endpoints","text":""},{"location":"authentication/#create-user","title":"Create User","text":"<p>This endpoint allows for the registration of a new user account.</p> <p>Request:</p> <ul> <li>Method: <code>POST</code></li> <li>URL: <code>/auth/create/</code></li> <li>Body: <pre><code>{\n    \"email\": \"user@example.com\",\n    \"password\": \"complexpassword123\",\n    \"password2\": \"complexpassword123\"\n}\n</code></pre><ul> <li><code>email</code>: The user's unique email address.</li> <li><code>password</code>: The user's chosen password.</li> <li><code>password2</code>: Confirmation of the user's chosen password (must match <code>password</code>).</li> </ul> </li> </ul> <p>Responses:</p> <ul> <li> <p>Success (201 Created): <pre><code>{\n    \"email\": \"user@example.com\"\n}\n</code></pre></p> <ul> <li>Returns the email of the newly created user.</li> </ul> </li> <li> <p>Error (400 Bad Request):</p> <ul> <li>Passwords do not match: <pre><code>{\n    \"password\": [\n        \"Passwords do not match.\"\n    ]\n}\n</code></pre></li> <li>Email already registered: <pre><code>{\n    \"email\": [\n        \"This email is already registered.\"\n    ]\n}\n</code></pre></li> <li>Invalid password (e.g., too short, common password): <pre><code>{\n    \"password\": [\n        \"This password is too short. It must contain at least 8 characters.\"\n    ]\n}\n</code></pre></li> </ul> </li> <li>Error (401 Unauthorized):<ul> <li>This error typically occurs if authentication credentials are required for this endpoint (though usually not for user creation). <pre><code>{\n    \"detail\": \"Authentication credentials were not provided.\"\n}\n</code></pre></li> </ul> </li> </ul>"},{"location":"authentication/#login","title":"Login","text":"<p>This endpoint authenticates a user and issues an authentication token.</p> <p>Request:</p> <ul> <li>Method: <code>POST</code></li> <li>URL: <code>/auth/login/</code></li> <li>Body: <pre><code>{\n    \"email\": \"user@example.com\",\n    \"password\": \"complexpassword123\"\n}\n</code></pre><ul> <li><code>email</code>: The user's registered email address.</li> <li><code>password</code>: The user's password.</li> </ul> </li> </ul> <p>Responses:</p> <ul> <li> <p>Success (200 OK): <pre><code>{\n    \"expiry\": \"2025-07-09T12:00:00Z\",\n    \"token\": \"your-auth-token\",\n    \"user\": {\n        \"email\": \"user@example.com\",\n        \"first_name\": \"\",\n        \"last_name\": \"\"\n    }\n}\n</code></pre></p> <ul> <li><code>expiry</code>: The expiration timestamp of the token.</li> <li><code>token</code>: The authentication token to be used in subsequent requests.</li> <li><code>user</code>: A dictionary containing basic user profile information.</li> </ul> </li> <li> <p>Error (400 Bad Request):</p> <ul> <li>Invalid credentials: <pre><code>{\n    \"detail\": \"Unable to log in with provided credentials.\"\n}\n</code></pre></li> <li>Missing fields: <pre><code>{\n    \"email\": [\n        \"This field is required.\"\n    ],\n    \"password\": [\n        \"This field is required.\"\n    ]\n}\n</code></pre></li> </ul> </li> </ul>"},{"location":"authentication/#logout","title":"Logout","text":"<p>This endpoint logs out the currently authenticated user by invalidating their current authentication token.</p> <p>Request:</p> <ul> <li>Method: <code>POST</code></li> <li>URL: <code>/auth/logout/</code></li> <li>Authentication: Token required.</li> </ul> <p>Responses:</p> <ul> <li> <p>Success (204 No Content):</p> <ul> <li>The response will have an empty body, indicating successful token invalidation.</li> </ul> </li> <li> <p>Error (401 Unauthorized):</p> <ul> <li>Occurs if no authentication credentials are provided or if the token is invalid. <pre><code>{\n    \"detail\": \"Authentication credentials were not provided.\"\n}\n</code></pre></li> </ul> </li> </ul>"},{"location":"authentication/#logout-all","title":"Logout All","text":"<p>This endpoint invalidates all authentication tokens for the currently authenticated user, effectively logging them out from all devices.</p> <p>Request:</p> <ul> <li>Method: <code>POST</code></li> <li>URL: <code>/auth/logoutall/</code></li> <li>Authentication: Token required.</li> </ul> <p>Responses:</p> <ul> <li> <p>Success (204 No Content):</p> <ul> <li>The response will have an empty body, indicating that all tokens for the user have been invalidated.</li> </ul> </li> <li> <p>Error (401 Unauthorized):</p> <ul> <li>Occurs if no authentication credentials are provided or if the token is invalid. <pre><code>{\n    \"detail\": \"Authentication credentials were not provided.\"\n}\n</code></pre></li> </ul> </li> </ul>"},{"location":"authentication/#user-profile","title":"User Profile","text":"<p>This endpoint allows authenticated users to retrieve and update their profile information.</p>"},{"location":"authentication/#retrieve-user-profile","title":"Retrieve User Profile","text":"<p>Retrieves the profile of the currently authenticated user.</p> <p>Request:</p> <ul> <li>Method: <code>GET</code></li> <li>URL: <code>/auth/profile/</code></li> <li>Authentication: Token required.</li> </ul> <p>Responses:</p> <ul> <li> <p>Success (200 OK): <pre><code>{\n    \"email\": \"user@example.com\",\n    \"first_name\": \"John\",\n    \"last_name\": \"Doe\"\n}\n</code></pre></p> <ul> <li>Returns the user's email, first name, and last name.</li> </ul> </li> <li> <p>Error (401 Unauthorized):</p> <ul> <li>Occurs if no authentication credentials are provided or if the token is invalid. <code>json { \"detail\": \"Authentication credentials were not provided.\" }</code></li> </ul> </li> </ul>"},{"location":"authentication/#update-user-profile","title":"Update User Profile","text":"<p>Updates the entire profile of the currently authenticated user. All fields must be provided.</p> <p>Request:</p> <ul> <li>Method: <code>PUT</code></li> <li>URL: <code>/auth/profile/</code></li> <li>Authentication: Token required.</li> <li>Body: <pre><code>{\n    \"first_name\": \"Jane\",\n    \"last_name\": \"Doe\"\n}\n</code></pre><ul> <li><code>first_name</code>: The user's first name.</li> <li><code>last_name</code>: The user's last name.</li> </ul> </li> </ul> <p>Responses:</p> <ul> <li> <p>Success (200 OK): <pre><code>{\n    \"email\": \"user@example.com\",\n    \"first_name\": \"Jane\",\n    \"last_name\": \"Doe\"\n}\n</code></pre></p> <ul> <li>Returns the updated user profile.</li> </ul> </li> <li> <p>Error (400 Bad Request):</p> <ul> <li>Occurs if the provided data is invalid (e.g., password validation errors if password fields were included). <pre><code>{\n    \"password\": [\n        \"Password must be at least 8 characters long.\"\n    ]\n}\n</code></pre></li> </ul> </li> <li> <p>Error (401 Unauthorized):</p> <ul> <li>Occurs if no authentication credentials are provided or if the token is invalid. <code>json { \"detail\": \"Authentication credentials were not provided.\" }</code></li> </ul> </li> </ul>"},{"location":"authentication/#partially-update-user-profile","title":"Partially Update User Profile","text":"<p>Partially updates the profile of the currently authenticated user. Only the fields to be updated need to be provided.</p> <p>Request:</p> <ul> <li>Method: <code>PATCH</code></li> <li>URL: <code>/auth/profile/</code></li> <li>Authentication: Token required.</li> <li>Body: <pre><code>{\n    \"first_name\": \"Jane\"\n}\n</code></pre><ul> <li><code>first_name</code>: The user's first name (optional).</li> <li><code>last_name</code>: The user's last name (optional).</li> </ul> </li> </ul> <p>Responses:</p> <ul> <li> <p>Success (200 OK): <pre><code>{\n    \"email\": \"user@example.com\",\n    \"first_name\": \"Jane\",\n    \"last_name\": \"Doe\"\n}\n</code></pre></p> <ul> <li>Returns the partially updated user profile.</li> </ul> </li> <li> <p>Error (401 Unauthorized):</p> <ul> <li>Occurs if no authentication credentials are provided or if the token is invalid. <code>json { \"detail\": \"Authentication credentials were not provided.\" }</code></li> </ul> </li> </ul>"},{"location":"auto_documentation/","title":"API Auto-Documentation","text":""},{"location":"auto_documentation/#overview","title":"Overview","text":"<p>This section details the automatic API documentation system implemented in the Django Starter Template, which leverages <code>drf-spectacular</code> to generate OpenAPI 3 (Swagger) documentation. This ensures that your API documentation remains synchronized with your codebase, minimizing manual effort and potential inconsistencies.</p>"},{"location":"auto_documentation/#what-is-drf-spectacular","title":"What is <code>drf-spectacular</code>?","text":"<p><code>drf-spectacular</code> is a powerful library that integrates seamlessly with Django REST Framework to generate a comprehensive OpenAPI schema from your DRF views, serializers, and other components. This schema can then be used to render interactive API documentation (like Swagger UI) or generate client SDKs.</p>"},{"location":"auto_documentation/#how-its-used-in-this-project-best-practices","title":"How it's Used in This Project (Best Practices)","text":"<p>This template follows best practices for <code>drf-spectacular</code> integration to provide rich and accurate API documentation.</p>"},{"location":"auto_documentation/#1-centralized-schema-definitions","title":"1. Centralized Schema Definitions","text":"<p>Instead of defining all schema details directly within views, this project centralizes reusable schema components (like error responses and common examples) in dedicated <code>schema.py</code> files within each app (e.g., <code>apps/users/schema.py</code>, <code>apps/core/schema.py</code>).</p> <p>This promotes reusability and keeps your view logic clean. For example, common error responses are defined once and reused across multiple endpoints.</p> <pre><code># Example from apps/core/schema.py\nfrom drf_spectacular.utils import OpenApiExample, inline_serializer\nfrom rest_framework import serializers\n\nErrorResponseSerializer = inline_serializer(\n    name=\"ErrorResponse\",\n    fields={\n        \"detail\": serializers.CharField(read_only=True),\n        \"code\": serializers.CharField(read_only=True, required=False),\n    },\n)\n\nUNAUTHORIZED_EXAMPLES = [\n    OpenApiExample(\n        \"Unauthorized\",\n        value={\"detail\": \"Authentication credentials were not provided.\"},\n        status_codes=[\"401\"],\n    ),\n    # ... other examples\n]\n</code></pre>"},{"location":"auto_documentation/#2-extend_schema-decorator-for-views","title":"2. <code>extend_schema</code> Decorator for Views","text":"<p>The <code>extend_schema</code> decorator is used on API views to provide additional metadata that <code>drf-spectacular</code> cannot infer automatically. This includes:</p> <ul> <li>Responses: Defining expected success and error responses, often referencing the centralized schema definitions.</li> <li>Request Bodies: Specifying the structure of request payloads.</li> <li>Parameters: Documenting query parameters, path parameters, and headers.</li> <li>Description: Adding human-readable descriptions for endpoints.</li> </ul> <p>Example (from <code>apps/users/views.py</code> for LoginView):</p> <pre><code>from drf_spectacular.utils import extend_schema\n# ... other imports\n\n@extend_schema(responses=LOGIN_RESPONSE_SCHEMA)\nclass LoginView(KnoxLoginView):\n    # ... view implementation\n</code></pre> <p>Here, <code>LOGIN_RESPONSE_SCHEMA</code> is imported from <code>apps/users/schema.py</code>, ensuring consistency and reusability.</p>"},{"location":"auto_documentation/#3-spectacular_settings-in-confsettingspy","title":"3. <code>SPECTACULAR_SETTINGS</code> in <code>conf/settings.py</code>","text":"<p>Global settings for <code>drf-spectacular</code> are configured in <code>conf/settings.py</code> under the <code>SPECTACULAR_SETTINGS</code> dictionary. This includes basic API metadata like title, description, and version.</p> <pre><code># Example from conf/settings.py\nSPECTACULAR_SETTINGS = {\n    \"TITLE\": \"Django Starter Template\",\n    \"DESCRIPTION\": \"A comprehensive starting point for your new API with Django and DRF\",\n    \"VERSION\": \"0.1.0\",\n    \"SERVE_INCLUDE_SCHEMA\": False,\n}\n</code></pre>"},{"location":"auto_documentation/#4-interactive-swagger-ui","title":"4. Interactive Swagger UI","text":"<p>The generated OpenAPI schema is served via Swagger UI, providing an interactive and user-friendly interface to explore and test the API. You can access it at:</p> <p><code>/api/schema/swagger-ui/</code></p> <p>This endpoint is configured in <code>conf/urls.py</code>:</p> <pre><code># Example from conf/urls.py\nfrom drf_spectacular.views import SpectacularAPIView, SpectacularSwaggerView\n\nurlpatterns = [\n    # ... other urls\n]\n\nif settings.DEBUG:\n    urlpatterns += [\n        path(\"api/schema/\", SpectacularAPIView.as_view(), name=\"schema\"),\n        path(\n            \"api/schema/swagger-ui/\",\n            SpectacularSwaggerView.as_view(url_name=\"schema\"),\n            name=\"swagger-ui\",\n        ),\n    ]\n</code></pre> <p>By following these practices, the project ensures that its API documentation is robust, maintainable, and automatically generated, reflecting the true state of the API.</p>"},{"location":"core_endpoints/","title":"Core Application","text":""},{"location":"core_endpoints/#overview","title":"Overview","text":"<p>This section provides an overview of the Core application (<code>apps/core/</code>), which serves as a foundational component within the Django Starter Template. It encapsulates common utilities, middleware, base tasks, and essential API endpoints.</p>"},{"location":"core_endpoints/#key-functionalities","title":"Key Functionalities","text":"<p>The <code>apps/core/</code> directory includes the following key functionalities:</p> <ul> <li>Middleware: Contains custom middleware, such as <code>RequestIDMiddleware</code>, which enriches logs and responses with request-specific details like <code>request_id</code>, client IP, and response time.</li> <li>Tasks: Provides base Celery task classes, including <code>BaseTaskWithRetry</code>, which offers common functionalities like automatic retries for background tasks, enhancing task reliability.</li> <li>Schema: Defines common OpenAPI schema components and examples, promoting reusability and consistency across API documentation.</li> <li>Management Commands: Includes custom Django management commands, such as the <code>seed</code> command, designed for populating the database with sample data for development and testing purposes.</li> </ul>"},{"location":"core_endpoints/#api-endpoints","title":"API Endpoints","text":"<p>The Core application exposes the following API endpoints, all prefixed with <code>/core/</code>:</p>"},{"location":"core_endpoints/#ping","title":"Ping","text":"<p>This is a simple endpoint designed to verify that the server is operational and responsive.</p> <p>Request:</p> <ul> <li>Method: <code>GET</code></li> <li>URL: <code>/core/ping/</code></li> </ul> <p>Responses:</p> <ul> <li>Success (200 OK): <pre><code>{\n    \"ping\": \"pong\"\n}\n</code></pre><ul> <li>Returns a JSON object with a <code>ping</code> key and <code>pong</code> value, indicating a successful response.</li> </ul> </li> </ul>"},{"location":"core_endpoints/#fire-task","title":"Fire Task","text":"<p>This endpoint triggers a sample Celery task in the background. It's useful for testing the Celery setup and task execution.</p> <p>Request:</p> <ul> <li>Method: <code>GET</code></li> <li>URL: <code>/core/fire-task/</code></li> </ul> <p>Responses:</p> <ul> <li>Success (200 OK): <pre><code>{\n    \"task\": \"Task fired\"\n}\n</code></pre><ul> <li>Returns a confirmation that the task has been successfully initiated.</li> </ul> </li> </ul>"},{"location":"database_seeding/","title":"Database Seeding","text":"<p>Database seeding is the process of populating a database with initial data. This is particularly useful during development and testing phases to ensure your application has realistic data to work with, without having to manually create it.</p>"},{"location":"database_seeding/#why-use-database-seeding","title":"Why Use Database Seeding?","text":"<ul> <li>Development: Provides a quick way to set up a development environment with sample data, allowing developers to immediately start working on features without worrying about data entry.</li> <li>Testing: Ensures that your tests run against a consistent and representative dataset, making your tests more reliable and reproducible.</li> <li>Demonstrations: Useful for populating a database for demonstrations or presentations of your application.</li> </ul>"},{"location":"database_seeding/#the-seed-management-command","title":"The <code>seed</code> Management Command","text":"<p>This project includes a powerful custom Django management command, <code>seed</code>, located at <code>apps/core/management/commands/seed.py</code>. This command allows you to easily populate your database with sample user data.</p>"},{"location":"database_seeding/#usage","title":"Usage","text":"<p>To use the <code>seed</code> command, you typically run it via <code>python manage.py seed</code> or <code>poetry run seed</code>.</p> <pre><code>python manage.py seed [options]\n</code></pre>"},{"location":"database_seeding/#available-options","title":"Available Options","text":"<p>The <code>seed</code> command supports the following arguments:</p> <ul> <li> <p><code>--users &lt;count&gt;</code>: Specifies the number of fake users to create. If not provided, it defaults to 10 users.</p> <ul> <li>Example: <code>python manage.py seed --users 50</code> (Creates 50 fake users)</li> </ul> </li> <li> <p><code>--superuser</code>: A flag that, when present, creates a superuser with predefined credentials (<code>admin@admin.com</code> / <code>admin</code>).</p> <ul> <li>Example: <code>python manage.py seed --superuser</code> (Creates an admin user)</li> </ul> </li> <li> <p><code>--clean</code>: A flag that, when present, deletes all existing non-superuser user data from the database before seeding. This is useful for starting with a fresh dataset.</p> <ul> <li>Example: <code>python manage.py seed --clean</code> (Deletes existing data before seeding)</li> </ul> </li> </ul>"},{"location":"database_seeding/#combined-examples","title":"Combined Examples","text":"<p>You can combine these options to achieve specific seeding scenarios:</p> <ul> <li> <p>Basic seeding with default options (creates 10 users):</p> <pre><code>python manage.py seed\n</code></pre> </li> <li> <p>Create specific number of users and a superuser:</p> <pre><code>python manage.py seed --users 20 --superuser\n</code></pre> </li> <li> <p>Clean existing data, create 50 users, and a superuser:</p> <pre><code>python manage.py seed --users 50 --superuser --clean\n</code></pre> </li> </ul>"},{"location":"database_seeding/#implementation-details","title":"Implementation Details","text":"<p>The <code>seed</code> command uses the <code>Faker</code> library to generate realistic-looking fake data for user profiles. It also utilizes Django's <code>transaction.atomic</code> decorator to ensure that the seeding process is atomic; if any part of the seeding fails, the entire operation is rolled back, preventing partial data corruption.</p>"},{"location":"dependencies/","title":"Project Dependencies","text":""},{"location":"dependencies/#overview","title":"Overview","text":"<p>This project utilizes Poetry as its dependency management tool. Poetry ensures consistent project environments by managing dependencies, virtual environments, and packaging. All project dependencies are defined in the <code>pyproject.toml</code> file, categorized into main dependencies and development-specific dependencies.</p>"},{"location":"dependencies/#main-dependencies","title":"Main Dependencies","text":"<p>The following are the primary dependencies required for the application to run in production:</p> <ul> <li><code>python</code>: Specifies the compatible Python version. Version: <code>^3.13</code></li> <li><code>django</code>: The web framework for perfectionists with deadlines. Version: <code>^5.1.2</code></li> <li><code>django-environ</code>: Manages environment variables for Django settings. Version: <code>^0.12.0</code></li> <li><code>django-cors-headers</code>: Handles Cross-Origin Resource Sharing (CORS) headers. Version: <code>^4.5.0</code></li> <li><code>djangorestframework</code>: A powerful and flexible toolkit for building Web APIs. Version: <code>^3.15.2</code></li> <li><code>psycopg2</code>: PostgreSQL adapter for Python. Version: <code>^2.9.10</code></li> <li><code>whitenoise</code>: Serves static files efficiently in production. Version: <code>^6.7.0</code></li> <li><code>gunicorn</code>: A Python WSGI HTTP Server for UNIX. Version: <code>^23.0.0</code></li> <li><code>django-rest-knox</code>: Token-based authentication for Django REST Framework. Version: <code>^5.0.2</code></li> <li><code>redis</code>: Python client for Redis. Version: <code>^6.0.0</code></li> <li><code>celery</code>: Distributed task queue. Version: <code>^5.4.0</code></li> <li><code>django-celery-beat</code>: A periodic task scheduler for Celery. Version: <code>^2.7.0</code></li> <li><code>django-celery-results</code>: Stores Celery task results in Django models. Version: <code>^2.5.1</code></li> <li><code>sentry-sdk</code>: Official Sentry SDK for Python, with Django integration. Version: <code>^2.17.0</code></li> <li><code>django-redis</code>: Full-featured Redis cache backend for Django. Version: <code>^6.0.0</code></li> <li><code>drf-spectacular</code>: OpenAPI 3 schema generation for Django REST Framework. Version: <code>^0.28.0</code></li> <li><code>faker</code>: Generates fake data for testing and development. Version: <code>^37.1.0</code></li> <li><code>django-seed</code>: Populates Django database with random data. Version: <code>^0.3.1</code></li> <li><code>django-extensions</code>: A collection of custom extensions for Django. Version: <code>^4.1</code></li> <li><code>django-filter</code>: Reusable Django application for filtering querysets. Version: <code>^25.1</code></li> <li><code>python-json-logger</code>: A JSON formatter for Python logging. Version: <code>^3.3.0</code></li> </ul>"},{"location":"dependencies/#development-dependencies","title":"Development Dependencies","text":"<ul> <li>django-debug-toolbar: ^5.0.0</li> <li>pytest: ^8.3.3</li> <li>pytest-django: ^4.9.0</li> <li>ipykernel: ^6.29.5</li> <li>pytest-mock: ^3.14.0</li> <li>pytest-cov: ^6.0.0</li> <li>mkdocs: ^1.6.0</li> <li>mkdocs-material: ^9.5.26</li> </ul>"},{"location":"development/","title":"Development Workflow","text":""},{"location":"development/#overview","title":"Overview","text":"<p>This guide outlines the essential commands and best practices for developing your application within the Django Starter Template. It assumes you have completed the initial environment setup, ideally using the provided Dev Container.</p>"},{"location":"development/#core-development-commands","title":"Core Development Commands","text":"<p>The project provides a set of convenient <code>poetry run</code> commands to streamline common development tasks. These commands should be executed from your terminal within the VS Code Dev Container or your activated Poetry shell.</p> <p>The project includes convenient scripts in <code>pyproject.toml</code> to simplify common development tasks. You should use these <code>poetry run</code> commands from the terminal inside your VS Code dev container.</p> Command Description <code>poetry run server</code> Starts the Django development server. <code>poetry run makemigrations</code> Creates new database migrations based on model changes. <code>poetry run migrate</code> Applies pending database migrations. <code>poetry run test</code> Runs the test suite using <code>pytest</code>. <code>poetry run test-cov</code> Runs the test suite and generates a coverage report."},{"location":"development/#testing","title":"Testing","text":"<p>The project utilizes <code>pytest</code> for its test suite. Below are common commands for running tests and generating coverage reports:</p> <ul> <li> <p>Run all tests: <pre><code>poetry run pytest\n</code></pre>     Executes the entire test suite.</p> </li> <li> <p>Run tests with coverage: <pre><code>poetry run pytest --cov\n</code></pre>     Runs all tests and collects code coverage information.</p> </li> <li> <p>Generate an HTML coverage report: <pre><code>poetry run pytest --cov --cov-report=html\n</code></pre>     Generates a detailed HTML report of code coverage, which can be found in the <code>htmlcov/</code> directory. This report helps identify untested parts of the codebase.</p> </li> </ul>"},{"location":"development/#database-seeding","title":"Database Seeding","text":"<p>The template includes a powerful management command to populate your database with sample data, which is invaluable for development and testing. This command is part of the <code>apps/core/management/commands/seed.py</code> module.</p> <p>Usage:</p> <pre><code># Basic seeding with default options (creates 10 users)\npoetry run seed\n\n# Create a specific number of users\npoetry run seed --users 20\n\n# Create a superuser (admin@admin.com:admin)\npoetry run seed --superuser\n\n# Clean existing data before seeding\npoetry run seed --clean\n\n# Combine options\npoetry run seed --users 50 --superuser --clean\n</code></pre> <p>Options:</p> <ul> <li><code>--users &lt;number&gt;</code>: Specifies the number of regular users to create. Default is 10.</li> <li><code>--superuser</code>: Creates a default superuser (<code>admin@admin.com</code> with password <code>admin</code>).</li> <li><code>--clean</code>: Cleans (deletes) existing seeded data before generating new data. Use with caution as this will remove all existing users and related data.</li> </ul>"},{"location":"development/#asynchronous-tasks-celery","title":"Asynchronous Tasks (Celery)","text":"<p>For handling background tasks and asynchronous operations, the project integrates Celery. To run Celery workers and schedulers, use the following commands:</p> <ul> <li> <p>Start the Celery worker: <pre><code>poetry run worker\n</code></pre>     This command starts a Celery worker process that executes tasks from the message queue.</p> </li> <li> <p>Start the Celery beat scheduler: <pre><code>poetry run beat\n</code></pre>     This command starts the Celery beat scheduler, which is responsible for periodically executing scheduled tasks.</p> </li> </ul>"},{"location":"development/#environment-variables","title":"Environment Variables","text":"<p>Environment variables are managed using a <code>.env</code> file, which is crucial for configuring application settings without hardcoding sensitive information. The project uses <code>django-environ</code> to load these variables.</p> <ul> <li>Development <code>.env</code> file: The <code>poetry run create_dev_env</code> command can be used to generate a new <code>.env</code> file tailored for development purposes if it's missing or needs to be reset.</li> <li>Production <code>.env</code> file: For production deployments, refer to the <code>.env.example</code> file at the project root for a comprehensive list of all required environment variables and their descriptions. This file serves as a template for setting up your production environment.</li> </ul>"},{"location":"environment_setup/","title":"Environment Setup","text":"<p>This section explains how environment variables are used in the Django Starter Template and how to configure your project for both development and production environments.</p>"},{"location":"environment_setup/#environment-variables","title":"Environment Variables","text":"<p>Environment variables are a crucial part of modern application development, allowing you to configure your application's behavior without modifying the codebase. This is especially important for sensitive information (like API keys, database credentials) and for settings that vary between development, testing, and production environments.</p> <p>This project uses the <code>django-environ</code> library to manage environment variables. It reads variables from a <code>.env</code> file located in the project's root directory.</p>"},{"location":"environment_setup/#envexample","title":"<code>.env.example</code>","text":"<p>The <code>.env.example</code> file serves as a template for your <code>.env</code> file. It lists all the environment variables that your project expects, along with example values and comments explaining their purpose. Never commit your actual <code>.env</code> file to version control.</p> <pre><code># --------------------------------------------------------------------------------\n# \u26a1 Basic Config: for development and testing.\n# --------------------------------------------------------------------------------\nDEBUG=True\nDATABASE_URL=postgres://postgres:postgres@localhost:5432/postgres\nDJANGO_SECRET_KEY=django-insecure-wlgjuo53y49%-4y5(!%ksylle_ud%b=7%__@9hh+@$d%_^y3s!\n\n\n# --------------------------------------------------------------------------------\n# \ud83d\udce7 Email Config: optional and can be copied if needed.\n# --------------------------------------------------------------------------------\nEMAIL_HOST=smtp.gmail.com\nEMAIL_USE_TLS=True\nEMAIL_PORT=587\nEMAIL_HOST_USER=user@user.com\nEMAIL_HOST_PASSWORD=myverystrongpassword\n\n\n# --------------------------------------------------------------------------------\n# \ud83d\udd10 Security Config: for production or testing the production settings locally.\n# --------------------------------------------------------------------------------\nALLOWED_HOSTS=mysite.com,mysite2.com\nCORS_ALLOWED_ORIGINS=mysite.com,mysite2.com\nSENTRY_DSN=https://examplePublicKey@o0.ingest.sentry.io/0\n</code></pre> <p>To set up your environment, copy <code>.env.example</code> to <code>.env</code> and fill in the appropriate values:</p> <pre><code>cp .env.example .env\n</code></pre>"},{"location":"environment_setup/#development-environment","title":"Development Environment","text":"<p>For local development, the following environment variables are typically set:</p> <ul> <li><code>DEBUG=True</code>: Enables Django's debug mode, providing detailed error pages and auto-reloading.</li> <li><code>DATABASE_URL</code>: Specifies the connection string for your local database (e.g., PostgreSQL running in Docker).</li> <li><code>DJANGO_SECRET_KEY</code>: A secret key for development purposes. You can use the example one provided in <code>.env.example</code>.</li> </ul> <p>When using the Dev Container setup (recommended), the <code>.env</code> file is automatically created and configured for a development environment.</p>"},{"location":"environment_setup/#production-environment","title":"Production Environment","text":"<p>For production deployments, it is critical to configure your environment variables securely and appropriately:</p> <ul> <li><code>DEBUG=False</code>: Always set to <code>False</code> in production. This disables debug mode, preventing sensitive information from being exposed in error pages.</li> <li><code>DJANGO_SECRET_KEY</code>: Generate a strong, unique secret key and store it securely. Never use the development secret key in production.</li> <li><code>ALLOWED_HOSTS</code>: A comma-separated list of domain names that your Django application will serve. Do not use <code>*</code> in production.</li> <li><code>DATABASE_URL</code>: The connection string for your production database.</li> <li><code>CORS_ALLOWED_ORIGINS</code>: A comma-separated list of origins that are allowed to make cross-origin requests to your API. Do not use <code>CORS_ALLOW_ALL_ORIGINS=True</code> in production.</li> <li><code>SENTRY_DSN</code>: Your Sentry Data Source Name (DSN) for error tracking and performance monitoring.</li> <li><code>EMAIL_HOST</code>, <code>EMAIL_USE_TLS</code>, <code>EMAIL_PORT</code>, <code>EMAIL_HOST_USER</code>, <code>EMAIL_HOST_PASSWORD</code>: Configure these for sending emails from your production environment.</li> </ul>"},{"location":"environment_setup/#example-production-env-conceptual","title":"Example Production <code>.env</code> (Conceptual)","text":"<pre><code>DEBUG=False\nDJANGO_SECRET_KEY=your_very_long_and_secure_production_secret_key\nALLOWED_HOSTS=api.yourdomain.com,www.yourdomain.com\nDATABASE_URL=postgres://user:password@db.yourdomain.com:5432/prod_db\nCORS_ALLOWED_ORIGINS=https://www.yourdomain.com,https://app.yourdomain.com\nSENTRY_DSN=https://your_sentry_public_key@o0.ingest.sentry.io/0\nEMAIL_HOST=smtp.sendgrid.net\nEMAIL_USE_TLS=True\nEMAIL_PORT=587\nEMAIL_HOST_USER=apikey\nEMAIL_HOST_PASSWORD=your_sendgrid_api_key\n</code></pre>"},{"location":"environment_setup/#managing-environment-variables","title":"Managing Environment Variables","text":"<p>It is recommended to use a tool or service provided by your deployment platform (e.g., Docker Compose, Kubernetes, Heroku, AWS Elastic Beanstalk) to manage and inject environment variables into your production environment. This ensures that sensitive information is not hardcoded or exposed in your codebase.</p>"},{"location":"logging/","title":"Logging System","text":"<p>This section details the logging system implemented in the Django Starter Template, covering its configuration, features, and how to interpret the generated logs.</p>"},{"location":"logging/#overview","title":"Overview","text":"<p>The template utilizes a centralized logging system configured within <code>conf/settings.py</code>. It's designed to provide comprehensive and structured logs, making it easier to monitor, debug, and analyze application behavior, especially in production environments.</p>"},{"location":"logging/#key-features","title":"Key Features","text":"<ul> <li>JSON Format: All logs are formatted as JSON, enabling easy parsing and integration with log management tools.</li> <li>Multiple Handlers: Different types of logs are directed to specific handlers and files:<ul> <li><code>console</code>: Outputs logs to the console, primarily used during development.</li> <li><code>app.log</code>: General application logs.</li> <li><code>security.log</code>: Specifically captures authentication events and security-related messages.</li> <li><code>error.log</code>: Records all error-level messages.</li> <li><code>info.log</code>: Records all info-level messages.</li> </ul> </li> <li>Rotating Files: To prevent log files from growing indefinitely, they are configured to rotate. Each log file has a maximum size of 10MB, and up to 5 backup files are kept.</li> <li>Request Tracing: A custom middleware (<code>apps.core.middleware.RequestIDMiddleware</code>) assigns a unique <code>request_id</code> to each incoming request. This ID, along with other request-specific details (client IP, request path, authenticated user ID, response time, and HTTP status code), is automatically injected into every log record. This allows for end-to-end tracing of requests.</li> <li>Sentry Integration: In production environments, Sentry is integrated for advanced error tracking and performance monitoring.</li> </ul>"},{"location":"logging/#log-file-locations","title":"Log File Locations","text":"<p>All log files are stored in the <code>logs/</code> directory at the root of the project:</p> <ul> <li><code>logs/app.log</code>: General application logs.</li> <li><code>logs/security.log</code>: Authentication and security events.</li> <li><code>logs/error.log</code>: Error-level logs.</li> <li><code>logs/info.log</code>: Info-level logs.</li> </ul>"},{"location":"logging/#example-log-entry","title":"Example Log Entry","text":"<p>Log entries are in JSON format, providing rich context for each event. Here's an example:</p> <pre><code>{\n    \"asctime\": \"2025-05-04 14:17:22,365\",\n    \"levelname\": \"INFO\",\n    \"module\": \"views\",\n    \"process\": 5929,\n    \"thread\": 281473186128320,\n    \"message\": \"Ping request received\",\n    \"client\": \"127.0.0.1\",\n    \"request_id\": \"0d7344bd-0e6f-426d-aeed-46b9d1ca36bc\",\n    \"path\": \"/core/ping/\",\n    \"user_id\": 1,\n    \"status_code\": 401,\n    \"response_time\": 0.0019102096557617188\n}\n</code></pre> <p>Each field in the JSON provides specific information:</p> <ul> <li><code>asctime</code>: Timestamp of the log entry.</li> <li><code>levelname</code>: The logging level (e.g., INFO, WARNING, ERROR).</li> <li><code>module</code>: The Python module where the log originated.</li> <li><code>process</code>: The process ID.</li> <li><code>thread</code>: The thread ID.</li> <li><code>message</code>: The actual log message.</li> <li><code>client</code>: The IP address of the client making the request.</li> <li><code>request_id</code>: A unique identifier for the request, useful for tracing.</li> <li><code>path</code>: The URL path of the request.</li> <li><code>user_id</code>: The ID of the authenticated user (or \"anonymous\" if not authenticated).</li> <li><code>status_code</code>: The HTTP status code of the response.</li> <li><code>response_time</code>: The time taken to process the request in seconds.</li> </ul>"},{"location":"project_structure/","title":"Project Structure","text":""},{"location":"project_structure/#overview","title":"Overview","text":"<p>Understanding the project's directory structure is fundamental for navigating, developing, and maintaining the Django Starter Template. This document provides a detailed overview of the main directories and files, explaining their purpose and contents to help you quickly grasp the project's organization.</p> <pre><code>\u251c\u2500\u2500 .clinerules/                # Gemini CLI rules\n\u251c\u2500\u2500 .coveragerc                 # Coverage.py configuration\n\u251c\u2500\u2500 .devcontainer/              # Dev container configuration\n\u251c\u2500\u2500 .env.example                # Example environment variables file\n\u251c\u2500\u2500 .flake8                     # Flake8 linter configuration\n\u251c\u2500\u2500 .github/                    # GitHub CI/CD workflows and issue templates\n\u251c\u2500\u2500 .gitignore                  # Git ignore file\n\u251c\u2500\u2500 .pytest_cache/              # Pytest cache\n\u251c\u2500\u2500 .venv/                      # Virtual environment\n\u251c\u2500\u2500 .vscode/                    # VS Code settings and recommended extensions\n\u251c\u2500\u2500 apps/                       # Django applications (core logic)\n\u2502   \u251c\u2500\u2500 core/                   # Core functionalities and shared components\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py         # Initializes the core app\n\u2502   \u2502   \u251c\u2500\u2500 admin.py            # Django admin configuration for core app\n\u2502   \u2502   \u251c\u2500\u2500 apps.py             # App configuration for core app\n\u2502   \u2502   \u251c\u2500\u2500 management/         # Custom Django management commands\n\u2502   \u2502   \u251c\u2500\u2500 middleware.py       # Custom middleware for core app\n\u2502   \u2502   \u251c\u2500\u2500 migrations/         # Database migrations for core app\n\u2502   \u2502   \u251c\u2500\u2500 schema.py           # OpenAPI schema definitions for core app\n\u2502   \u2502   \u251c\u2500\u2500 tasks.py            # Celery task definitions for core app\n\u2502   \u2502   \u251c\u2500\u2500 tests/              # Unit and integration tests for core app\n\u2502   \u2502   \u2514\u2500\u2500 urls.py             # URL routing for core app\n\u2502   \u2514\u2500\u2500 users/                  # User management and authentication app\n\u2502       \u251c\u2500\u2500 __init__.py         # Initializes the users app\n\u2502       \u251c\u2500\u2500 admin.py            # Django admin configuration for users app\n\u2502       \u251c\u2500\u2500 apps.py             # App configuration for users app\n\u2502       \u251c\u2500\u2500 forms.py            # Custom forms for users app\n\u2502       \u251c\u2500\u2500 managers.py         # Custom managers for user models\n\u2502       \u251c\u2500\u2500 migrations/         # Database migrations for users app\n\u2502       \u251c\u2500\u2500 models.py           # User model definition\n\u2502       \u251c\u2500\u2500 schema.py           # OpenAPI schema definitions for users app\n\u2502       \u251c\u2500\u2500 serializers.py      # Serializers for users app\n\u2502       \u251c\u2500\u2500 tests/              # Unit and integration tests for users app\n\u2502       \u251c\u2500\u2500 throttles.py        # Rate limiting configurations for user-related views\n\u2502       \u251c\u2500\u2500 urls.py             # URL routing for users app\n\u2502       \u251c\u2500\u2500 utils.py            # Utility functions for users app\n\u2502       \u2514\u2500\u2500 views.py            # API views for user authentication and profile management\n\u251c\u2500\u2500 conf/                       # Project-wide configuration\n\u2502   \u251c\u2500\u2500 __init__.py             # Initializes the conf module\n\u2502   \u251c\u2500\u2500 asgi.py                 # ASGI application entry point\n\u2502   \u251c\u2500\u2500 celery.py               # Celery application configuration\n\u2502   \u251c\u2500\u2500 settings.py             # Main Django settings file\n\u2502   \u251c\u2500\u2500 test_settings.py        # Settings specifically for running tests\n\u2502   \u251c\u2500\u2500 test_utils.py           # Test utilities\n\u2502   \u251c\u2500\u2500 urls.py                 # Main URL routing for the project\n\u2502   \u2514\u2500\u2500 wsgi.py                 # WSGI application entry point\n\u251c\u2500\u2500 docs/                       # Documentation files\n\u251c\u2500\u2500 logs/                       # Application log files\n\u251c\u2500\u2500 manage.py                   # Django's command-line utility\n\u251c\u2500\u2500 mkdocs.yml                  # MkDocs configuration\n\u251c\u2500\u2500 notebook.ipynb              # Jupyter Notebook for interactive development\n\u251c\u2500\u2500 poetry.lock                 # Poetry lock file\n\u251c\u2500\u2500 pyproject.toml              # Project dependencies and metadata (Poetry)\n\u251c\u2500\u2500 pytest.ini                  # Pytest configuration\n\u251c\u2500\u2500 README.md                   # Project README file\n\u251c\u2500\u2500 renovate.json               # Renovate Bot configuration for dependency updates\n\u251c\u2500\u2500 scripts/                    # Utility scripts for various development tasks\n\u251c\u2500\u2500 static/                     # Static files (CSS, JavaScript, images)\n\u2514\u2500\u2500 templates/                  # Project-wide HTML templates\n</code></pre>"},{"location":"project_structure/#key-directories","title":"Key Directories","text":"<p>This section describes the primary directories within the project and their respective purposes:</p> <ul> <li> <p><code>.devcontainer/</code>: Contains configuration files for Visual Studio Code Dev Containers. This ensures a consistent and reproducible development environment across different machines, pre-configured with all necessary tools and dependencies.</p> </li> <li> <p><code>.github/</code>: Stores GitHub-specific files, including GitHub Actions workflows for Continuous Integration (CI) and Continuous Deployment (CD), issue templates, and other repository settings. This directory automates various development processes.</p> </li> <li> <p><code>.vscode/</code>: Holds Visual Studio Code workspace settings and recommended extensions for the project. These settings enhance the development experience by providing consistent formatting, linting, and debugging configurations.</p> </li> <li> <p><code>apps/</code>: This is the core of your Django project, where individual Django applications (modules) reside. Each app is designed to be a self-contained unit responsible for a specific feature or set of features, promoting modularity and reusability.</p> <ul> <li><code>core/</code>: Houses fundamental functionalities and shared components that are used across different parts of the application. This includes custom management commands, base Celery tasks, and common API schema definitions, serving as a foundational app.</li> <li><code>users/</code>: Manages all aspects of user authentication and authorization. This includes user models, serializers, views, and related utilities for user registration, login, and profile management.</li> </ul> </li> <li> <p><code>conf/</code>: Contains project-wide configuration files that apply to the entire Django project, rather than being specific to a single app. This includes the main <code>settings.py</code>, URL routing (<code>urls.py</code>), ASGI/WSGI configurations, and Celery setup.</p> </li> <li> <p><code>logs/</code>: The designated directory for application log files. Different log levels and types (e.g., general application logs, security events, error logs) are typically written to separate files within this directory for easier monitoring and debugging.</p> </li> <li> <p><code>scripts/</code>: A collection of utility scripts that automate various development and maintenance tasks. These scripts can include commands for running the server, managing migrations, or executing custom project-specific operations.</p> </li> <li> <p><code>static/</code>: Stores static assets such as CSS stylesheets, JavaScript files, and images. These files are typically served directly by the web server and are essential for the frontend of the application.</p> </li> <li> <p><code>templates/</code>: Contains project-wide HTML templates that are not specific to any single Django application. These templates can be used for common pages like error pages or base layouts.</p> </li> </ul>"},{"location":"project_structure/#key-files","title":"Key Files","text":"<p>This section outlines the most important files at the project root and their functions:</p> <ul> <li> <p><code>.env.example</code>: A template file that outlines all the environment variables required by the project. Developers should copy this to a <code>.env</code> file and fill in their specific values for local development, ensuring sensitive information is not hardcoded.</p> </li> <li> <p><code>manage.py</code>: Django's command-line utility for administrative tasks. This script is used for running the development server, performing database migrations, creating superusers, and executing custom management commands.</p> </li> <li> <p><code>pyproject.toml</code>: Used by Poetry (the dependency management tool) to define project metadata, dependencies, and build configurations. It serves as the central point for managing the project's Python environment.</p> </li> <li> <p><code>pytest.ini</code>: The configuration file for <code>pytest</code>, the testing framework used in this project. It specifies how tests should be discovered and run, including settings for code coverage analysis.</p> </li> <li> <p><code>README.md</code>: The main project documentation file, providing a high-level overview, quick start instructions, key features, and links to more detailed documentation. It's the first file new contributors typically read.</p> </li> </ul> <p>By adhering to this structured layout, the project promotes modularity, maintainability, and scalability, making it easier for developers to understand and contribute to the codebase.</p>"},{"location":"rate_limiting/","title":"Rate Limiting","text":"<p>Rate limiting is a crucial security and performance feature that controls the number of requests a user or IP address can make to your API within a given timeframe. It helps prevent abuse, brute-force attacks, and ensures fair usage of your API resources.</p>"},{"location":"rate_limiting/#why-use-rate-limiting","title":"Why Use Rate Limiting?","text":"<ul> <li>Security: Protects against brute-force attacks on login endpoints, denial-of-service (DoS) attacks, and excessive data scraping.</li> <li>Performance: Prevents a single user or malicious actor from overwhelming your server with too many requests, ensuring the API remains responsive for all legitimate users.</li> <li>Fair Usage: Ensures that API resources are distributed fairly among all users, preventing any single user from monopolizing resources.</li> </ul>"},{"location":"rate_limiting/#how-its-implemented","title":"How it's Implemented","text":"<p>This project uses Django REST Framework's built-in throttling mechanisms, along with a custom throttle class, to implement rate limiting.</p>"},{"location":"rate_limiting/#1-default-throttle-rates","title":"1. Default Throttle Rates","text":"<p>Global throttle rates are defined in <code>conf/settings.py</code> under the <code>REST_FRAMEWORK</code> dictionary. These rates are applied based on different scopes:</p> <pre><code># Example from conf/settings.py\nREST_FRAMEWORK = {\n    # ... other settings\n    \"DEFAULT_THROTTLE_RATES\": {\n        \"user\": \"1000/day\",\n        \"anon\": \"100/day\",\n        \"user_login\": \"5/minute\",\n    },\n}\n</code></pre> <ul> <li><code>user</code>: Applies to authenticated users. Default: <code>1000 requests per day</code>.</li> <li><code>anon</code>: Applies to unauthenticated (anonymous) users. Default: <code>100 requests per day</code>.</li> <li><code>user_login</code>: A custom scope specifically for login attempts. Default: <code>5 requests per minute</code>.</li> </ul>"},{"location":"rate_limiting/#2-custom-throttle-class","title":"2. Custom Throttle Class","text":"<p>For specific scenarios, like limiting login attempts, a custom throttle class (<code>apps/users/throttles.py</code>) is used. This allows for more granular control over how requests are identified and limited.</p> <pre><code># Example from apps/users/throttles.py\nfrom rest_framework.throttling import SimpleRateThrottle\n\nclass UserLoginRateThrottle(SimpleRateThrottle):\n    scope = \"user_login\"\n\n    def get_cache_key(self, request, view):\n        if not request.user.is_authenticated:\n            ident = self.get_ident(request) # Uses IP for anonymous users\n        else:\n            ident = request.user.pk # Uses user ID for authenticated users\n\n        return self.cache_format % {\"scope\": self.scope, \"ident\": ident}\n</code></pre> <p>This custom throttle ensures that:</p> <ul> <li>For anonymous users, rate limiting is based on their IP address.</li> <li>For authenticated users, rate limiting is based on their user ID.</li> </ul>"},{"location":"rate_limiting/#3-applying-throttles-to-views","title":"3. Applying Throttles to Views","text":"<p>Throttles are applied to DRF views using the <code>throttle_classes</code> attribute. This tells DRF which throttle policies to enforce for that specific view.</p> <p>Example (from <code>apps/users/views.py</code> for <code>LoginView</code> and <code>UserProfileView</code>):</p> <pre><code># For LoginView\nfrom rest_framework.throttling import AnonRateThrottle # Or other built-in throttles\nfrom .throttles import UserLoginRateThrottle\n\nclass LoginView(KnoxLoginView):\n    # ...\n    throttle_classes = [UserLoginRateThrottle]\n\n# For UserProfileView and CreateUserView\nfrom rest_framework import throttling\n\nclass UserProfileView(generics.RetrieveUpdateAPIView):\n    # ...\n    throttle_classes = [throttling.UserRateThrottle]\n\nclass CreateUserView(generics.CreateAPIView):\n    # ...\n    throttle_classes = [throttling.UserRateThrottle]\n</code></pre> <ul> <li><code>UserLoginRateThrottle</code>: Applied to the <code>LoginView</code> to limit login attempts.</li> <li><code>throttling.UserRateThrottle</code>: A built-in DRF throttle that applies the <code>user</code> scope rate (from <code>DEFAULT_THROTTLE_RATES</code>) to authenticated users. This is used for <code>UserProfileView</code> and <code>CreateUserView</code>.</li> </ul>"},{"location":"rate_limiting/#how-to-configure","title":"How to Configure","text":"<p>To adjust the rate limits for your API, modify the <code>DEFAULT_THROTTLE_RATES</code> dictionary in <code>conf/settings.py</code>.</p> <p>For example, to change the anonymous user rate limit to 50 requests per hour:</p> <pre><code># In conf/settings.py\nREST_FRAMEWORK = {\n    # ...\n    \"DEFAULT_THROTTLE_RATES\": {\n        \"user\": \"1000/day\",\n        \"anon\": \"50/hour\", # Changed from 100/day\n        \"user_login\": \"5/minute\",\n    },\n}\n</code></pre> <p>You can also create new custom throttle classes in <code>apps/users/throttles.py</code> (or a similar location) and apply them to specific views as needed.</p>"},{"location":"settings/","title":"Project Settings","text":""},{"location":"settings/#overview","title":"Overview","text":"<p>This document provides a comprehensive guide to the <code>conf/settings.py</code> file, which centralizes the configuration for the Django Starter Template. Understanding these settings is crucial for customizing and deploying your application effectively. The settings are organized into logical sections to facilitate navigation and comprehension.</p>"},{"location":"settings/#environment-variables","title":"Environment Variables","text":"<p>The project leverages <code>django-environ</code> to manage environment variables, ensuring that sensitive information and deployment-specific configurations are kept out of version control. Variables are loaded from a <code>.env</code> file located in the project root.</p> <p>Configuration Snippet:</p> <pre><code>import environ\n\nenv = environ.Env()\nroot_path = environ.Path(__file__) - 2\nenv.read_env(str(root_path.path(\".env\")))\n</code></pre> <p>Explanation:</p> <ul> <li><code>env = environ.Env()</code>: Initializes the environment reader, which provides methods to access environment variables with type casting.</li> <li><code>root_path</code>: Defines the base directory for resolving relative paths within the project. It's calculated as two levels up from the <code>settings.py</code> file's location.</li> <li><code>env.read_env()</code>: Reads variables from the <code>.env</code> file. When called without arguments, it automatically searches for a <code>.env</code> file in the current working directory or its parent directories.</li> </ul>"},{"location":"settings/#basic-configuration","title":"Basic Configuration","text":"<p>These are fundamental Django settings that define the core behavior of the application:</p> <ul> <li><code>ROOT_URLCONF</code>: Specifies the root URL configuration module for the project. Default: <code>conf.urls</code>. This tells Django where to find the main URL patterns that route incoming requests.</li> <li><code>WSGI_APPLICATION</code>: The full Python path to the WSGI application object. Default: <code>conf.wsgi.application</code>. This is the entry point for WSGI-compatible web servers (e.g., Gunicorn) to serve the Django application.</li> <li><code>DEBUG</code>: A boolean that controls Django's debug mode. Default: <code>False</code> (loaded from <code>env.bool(\"DEBUG\", default=False)</code>). When <code>True</code>, Django provides detailed error pages, automatically reloads code on changes, and enables other development-specific features. It is critical to set this to <code>False</code> in production environments for security and performance reasons.</li> </ul>"},{"location":"settings/#time-language","title":"Time &amp; Language","text":"<p>These settings control the localization and time zone behavior of the Django application:</p> <ul> <li><code>LANGUAGE_CODE</code>: The language code for this Django installation. Default: <code>en-us</code>. This setting influences the default language for Django's built-in messages, forms, and templates.</li> <li><code>TIME_ZONE</code>: The time zone for this installation. Default: <code>UTC</code>. Django uses this time zone for all datetime objects unless a specific timezone is explicitly activated (e.g., for a user's local time).</li> <li><code>USE_I18N</code>: A boolean that determines whether Django's internationalization system should be enabled. Default: <code>True</code>. When <code>True</code>, Django will look for translation files to provide localized content.</li> <li><code>USE_TZ</code>: A boolean that specifies whether Django's timezone support should be enabled. Default: <code>True</code>. When <code>True</code>, Django stores datetimes in UTC in the database and converts them to the appropriate local time zone for display, based on <code>TIME_ZONE</code> or user-specific settings.</li> </ul>"},{"location":"settings/#security-and-users","title":"Security and Users","text":"<p>This section covers critical security configurations and user model settings, essential for protecting your application and managing user accounts:</p> <ul> <li> <p><code>SECRET_KEY</code>: A unique secret key used for cryptographic signing in Django. Default: Loaded from the <code>DJANGO_SECRET_KEY</code> environment variable. This key must be kept absolutely secret and never hardcoded in version control.</p> <pre><code>SECRET_KEY = env(\"DJANGO_SECRET_KEY\")\n</code></pre> </li> <li> <p><code>ALLOWED_HOSTS</code>: A list of strings representing the host/domain names that this Django site can serve. Default: <code>[\"*\"]</code> (loaded from <code>env.list(\"ALLOWED_HOSTS\", default=[\"*\"])</code>). This is a crucial security measure to prevent HTTP Host header attacks. In production, always specify your exact domain names (e.g., <code>[\"api.example.com\"]</code>) and never use <code>\"*\"</code> for security reasons.</p> <pre><code>ALLOWED_HOSTS = env.list(\"ALLOWED_HOSTS\", default=[\"*\"])\n</code></pre> </li> <li> <p><code>AUTH_USER_MODEL</code>: Specifies the custom user model to be used by Django's authentication system. Default: <code>users.CustomUser</code>. This allows for extending Django's default user model with custom fields and behaviors tailored to your application's needs.</p> </li> <li><code>MIN_PASSWORD_LENGTH</code>: Defines the minimum length required for user passwords. Default: <code>8</code> (loaded from <code>env.int(\"MIN_PASSWORD_LENGTH\", default=8)</code>). This setting is integrated with Django's password validation system to enforce stronger password policies.</li> <li><code>PASSWORD_HASHERS</code>: A list of password hashing algorithms used for storing user passwords. Django attempts to use them in the order specified. Default: Includes <code>ScryptPasswordHasher</code>, <code>PBKDF2PasswordHasher</code>, <code>PBKDF2SHA1PasswordHasher</code>, <code>Argon2PasswordHasher</code>, and <code>BCryptSHA256PasswordHasher</code>. This provides robust password security by using modern, secure hashing algorithms.</li> <li><code>AUTH_PASSWORD_VALIDATORS</code>: Configures the rules for password validation. Default: Includes validators for user attribute similarity, minimum length, common passwords, and numeric passwords. These can be customized to enforce more stringent password policies.</li> </ul>"},{"location":"settings/#security-headers","title":"Security Headers","text":"<p>These settings configure various HTTP security headers to protect against common web vulnerabilities:</p> <ul> <li><code>SECURE_BROWSER_XSS_FILTER</code>: Enables the <code>X-XSS-Protection</code> header. Default: <code>True</code>. This helps protect against Cross-Site Scripting (XSS) attacks by enabling the browser's built-in XSS filter.</li> <li><code>SECURE_CONTENT_TYPE_NOSNIFF</code>: Enables the <code>X-Content-Type-Options</code> header. Default: <code>True</code>. This prevents browsers from MIME-sniffing a response away from the declared <code>Content-Type</code>, mitigating certain types of attacks.</li> <li><code>X_FRAME_OPTIONS</code>: Controls the <code>X-Frame-Options</code> header to prevent clickjacking attacks. Default: <code>DENY</code>. This means the page cannot be displayed in a frame, iframe, or object tag.</li> <li><code>CSRF_COOKIE_SECURE</code>: A boolean that determines whether the CSRF cookie should only be sent over HTTPS. Default: <code>True</code> if <code>DEBUG</code> is <code>False</code>, <code>False</code> otherwise. This should always be <code>True</code> in production environments to prevent cookie interception.</li> <li><code>SESSION_COOKIE_SECURE</code>: A boolean that determines whether the session cookie should only be sent over HTTPS. Default: <code>True</code> if <code>DEBUG</code> is <code>False</code>, <code>False</code> otherwise. Similar to <code>CSRF_COOKIE_SECURE</code>, this must be <code>True</code> in production for secure session management.</li> </ul>"},{"location":"settings/#databases","title":"Databases","text":"<p>Database connection settings are managed through the <code>DATABASE_URL</code> environment variable, which <code>django-environ</code> parses to configure the database connection.</p> <p>Configuration Snippet:</p> <pre><code>DJANGO_DATABASE_URL = env.db(\"DATABASE_URL\")\nDATABASES = {\"default\": DJANGO_DATABASE_URL}\n</code></pre> <p>Explanation:</p> <ul> <li><code>DJANGO_DATABASE_URL</code>: This variable holds the database connection string, which is parsed by <code>django-environ</code> to extract database credentials and settings. Default: Loaded from the <code>DATABASE_URL</code> environment variable.</li> <li><code>DATABASES</code>: A dictionary that contains all database configurations for the project. The <code>default</code> key specifies the primary database connection used by the application.</li> <li><code>DEFAULT_AUTO_FIELD</code>: Defines the type of primary key to use for models that do not explicitly specify one. Default: <code>django.db.models.BigAutoField</code>. This uses a 64-bit integer, which is generally preferred over the default <code>AutoField</code> (32-bit) to prevent potential integer overflow issues in large-scale applications.</li> </ul>"},{"location":"settings/#applications-configuration","title":"Applications Configuration","text":"<p>This section details the configuration of installed Django applications and middleware, which are crucial for defining the project's functionalities and request-response processing flow:</p> <ul> <li> <p><code>INSTALLED_APPS</code>: A list of strings specifying all Django applications enabled in this project. Default: This includes Django's built-in applications (e.g., <code>django.contrib.admin</code>, <code>django.contrib.auth</code>), essential third-party libraries (e.g., <code>whitenoise</code>, <code>rest_framework</code>, <code>knox</code>, <code>drf_spectacular</code>), and the project's local applications (<code>apps.users</code>, <code>apps.core</code>). This setting informs Django which application modules are active and should be loaded.</p> </li> <li> <p><code>MIDDLEWARE</code>: A list of middleware classes that process requests and responses globally across your Django application. Default: This typically includes security middleware, static files handling, session management, CORS headers, common utilities, CSRF protection, authentication, and custom middleware like <code>RequestIDMiddleware</code>. The order of middleware is critically important, as they are executed sequentially for incoming requests and in reverse order for outgoing responses.</p> </li> </ul>"},{"location":"settings/#templates","title":"Templates","text":"<p>These settings configure Django's template engine, which is responsible for rendering HTML and other content:</p> <ul> <li><code>BACKEND</code>: Specifies the template engine to be used. Default: <code>django.template.backends.django.DjangoTemplates</code>.</li> <li><code>DIRS</code>: A list of absolute paths to directories where Django should search for template files. Default: <code>[root_path(\"templates\")]</code>. This allows for project-wide templates to be organized outside of individual application directories.</li> <li><code>APP_DIRS</code>: A boolean that instructs Django to look for templates within the <code>templates</code> subdirectory of installed applications. Default: <code>True</code>. This is a convenient way to organize app-specific templates alongside their respective applications.</li> <li><code>OPTIONS</code>: A dictionary of additional options for the template engine. Default: Includes <code>context_processors</code> (functions that add variables to the template context, such as <code>debug</code>, <code>request</code>, <code>auth</code>, <code>messages</code>) and <code>builtins</code> (which register built-in template tags and filters for use in templates).</li> </ul>"},{"location":"settings/#rest-framework","title":"REST Framework","text":"<p>This section details the settings for Django REST Framework (DRF) and related tools for API development, authentication, and schema generation.</p>"},{"location":"settings/#token-based-authentication","title":"Token-Based Authentication","text":"<p>Configuration for <code>django-rest-knox</code>, the token-based authentication system used for secure API access:</p> <ul> <li><code>SECURE_HASH_ALGORITHM</code>: The hashing algorithm employed for generating and verifying authentication tokens. Default: <code>hashlib.sha512</code>.</li> <li><code>AUTH_TOKEN_CHARACTER_LENGTH</code>: Defines the length of the generated authentication tokens. Default: <code>64</code>.</li> <li><code>TOKEN_TTL</code>: Sets the time-to-live (TTL) for authentication tokens, determining how long a token remains valid after issuance. Default: <code>timedelta(hours=10)</code>.</li> <li><code>USER_SERIALIZER</code>: Specifies the serializer class used for user profiles when returning user-related data with tokens. Default: <code>apps.users.serializers.UserProfileSerializer</code>.</li> <li><code>TOKEN_LIMIT_PER_USER</code>: Allows limiting the number of active tokens a single user can possess simultaneously. Default: <code>None</code> (no limit).</li> <li><code>AUTO_REFRESH</code>: A boolean indicating whether tokens should be automatically refreshed upon use, extending their validity. Default: <code>False</code>.</li> <li><code>AUTO_REFRESH_MAX_TTL</code>: The maximum time-to-live for tokens that are automatically refreshed. Default: <code>None</code>.</li> <li><code>MIN_REFRESH_INTERVAL</code>: The minimum time interval (in seconds) that must pass between token refreshes. Default: <code>60</code> seconds.</li> <li><code>AUTH_HEADER_PREFIX</code>: The prefix expected in the <code>Authorization</code> HTTP header for token authentication (e.g., <code>Bearer &lt;token&gt;</code>). Default: <code>Bearer</code>.</li> <li><code>TOKEN_MODEL</code>: Refers to the Django model used by <code>django-rest-knox</code> to store authentication tokens. Default: <code>knox.AuthToken</code>.</li> </ul>"},{"location":"settings/#general-drf-settings","title":"General DRF Settings","text":"<p>Core settings for Django REST Framework, influencing how APIs behave, including authentication, filtering, and rendering:</p> <ul> <li><code>DEFAULT_AUTHENTICATION_CLASSES</code>: Defines the authentication methods available for API endpoints. Default: <code>knox.auth.TokenAuthentication</code>. In <code>DEBUG</code> mode, <code>SessionAuthentication</code> and <code>BasicAuthentication</code> are also included for development convenience.</li> <li><code>DEFAULT_FILTER_BACKENDS</code>: Specifies the default filter backends used for enabling filtering, searching, and ordering capabilities on API list views. Default: <code>django_filters.rest_framework.DjangoFilterBackend</code>, <code>rest_framework.filters.SearchFilter</code>, <code>rest_framework.filters.OrderingFilter</code>.</li> <li><code>DEFAULT_RENDERER_CLASSES</code>: Determines how API responses are rendered. Default: <code>rest_framework.renderers.JSONRenderer</code>. In <code>DEBUG</code> mode, <code>BrowsableAPIRenderer</code> is also added, providing a user-friendly HTML interface for API interaction.</li> <li><code>DEFAULT_SCHEMA_CLASS</code>: Integrates <code>drf-spectacular</code> for automatic OpenAPI schema generation. Default: <code>drf_spectacular.openapi.AutoSchema</code>.</li> <li><code>DEFAULT_THROTTLE_RATES</code>: Configures rate limiting for different types of users or requests, helping to prevent API abuse. Default: <code>user: \"1000/day\"</code> (authenticated users), <code>anon: \"100/day\"</code> (unauthenticated users), <code>user_login: \"5/minute\"</code> (specific throttle for login attempts).</li> </ul>"},{"location":"settings/#openapi-schema-generation","title":"OpenAPI Schema Generation","text":"<p>Settings for <code>drf-spectacular</code>, which generates OpenAPI 3 documentation for your API:</p> <ul> <li><code>TITLE</code>: The title displayed in your API documentation. Default: <code>Django Starter Template</code>.</li> <li><code>DESCRIPTION</code>: A brief description of your API, providing context for users of the documentation. Default: <code>A comprehensive starting point for your new API with Django and DRF</code>.</li> <li><code>VERSION</code>: The version number of your API. Default: <code>0.1.0</code>.</li> <li><code>SERVE_INCLUDE_SCHEMA</code>: A boolean indicating whether the raw OpenAPI schema endpoint should be included in the generated documentation. Default: <code>False</code>. Set to <code>True</code> if you want the raw schema to be directly accessible.</li> </ul>"},{"location":"settings/#cors-headers","title":"CORS Headers","text":"<p>Settings related to Cross-Origin Resource Sharing (CORS), managed by <code>django-cors-headers</code>:</p> <ul> <li><code>CORS_ALLOW_ALL_ORIGINS</code>: A boolean that, when <code>True</code>, allows requests from all origins. Default: <code>True</code> if <code>DEBUG</code> is <code>True</code>, <code>False</code> otherwise. For production environments, this should always be <code>False</code> for security reasons.</li> <li><code>CORS_ALLOWED_ORIGINS</code>: A list of allowed origins for CORS requests. This setting is active when <code>CORS_ALLOW_ALL_ORIGINS</code> is <code>False</code>. Default: Loaded from the <code>CORS_ALLOWED_ORIGINS</code> environment variable, allowing you to specify trusted domains.</li> </ul>"},{"location":"settings/#cache","title":"Cache","text":"<p>These settings configure the caching mechanism, primarily utilizing Redis for efficient data storage and retrieval:</p> <ul> <li><code>CACHES</code>: A dictionary defining the cache backends available to the project. Default: Includes a <code>default</code> cache configured to use <code>django_redis.cache.RedisCache</code>.</li> <li><code>LOCATION</code>: The connection URL for the Redis server. Default: <code>redis://redis:6379</code> (loaded from <code>env(\"REDIS_URL\", default=\"redis://redis:6379\")</code>). This specifies the address and port of your Redis instance.</li> <li><code>OPTIONS</code>: Additional options passed to the Redis client. Default: <code>{\"CLIENT_CLASS\": \"django_redis.client.DefaultClient\"}</code>. This can be used to customize the Redis client's behavior.</li> <li><code>USER_AGENTS_CACHE</code>: The cache alias to be used for caching user agent information. Default: <code>default</code>. This allows for efficient storage and retrieval of user agent strings.</li> </ul>"},{"location":"settings/#celery","title":"Celery","text":"<p>These settings configure Celery, the distributed task queue used for handling asynchronous tasks and periodic jobs:</p> <ul> <li><code>CELERY_BROKER_URL</code>: The URL for the Celery message broker, which facilitates communication between the application and Celery workers. Default: <code>redis://redis:6379</code> (loaded from <code>env(\"CELERY_BROKER_URL\", default=\"redis://redis:6379\")</code>).</li> <li><code>CELERY_RESULT_BACKEND</code>: Specifies where Celery task results are stored after a task completes. Default: <code>django-db</code> (loaded from <code>env(\"CELERY_RESULT_BACKEND\", default=\"django-db\")</code>). This means results are stored in the Django database.</li> <li><code>CELERY_BEAT_SCHEDULER</code>: Defines the scheduler for periodic tasks. Default: <code>django_celery_beat.schedulers.DatabaseScheduler</code>. This allows you to manage and schedule recurring tasks directly from the Django admin interface.</li> <li><code>CELERY_ACCEPT_CONTENT</code>: A list of accepted content types for tasks, ensuring secure deserialization. Default: <code>[\"application/json\"]</code>.</li> <li><code>CELERY_TASK_SERIALIZER</code>: The default serialization method used for tasks when they are sent to the broker. Default: <code>json</code>.</li> <li><code>CELERY_RESULT_SERIALIZER</code>: The default serialization method for task results when they are stored. Default: <code>json</code>.</li> <li><code>CELERY_TIMEZONE</code>: The timezone used by Celery for scheduling and executing tasks. Default: <code>America/Santiago</code>.</li> <li><code>CELERY_RESULT_EXTENDED</code>: A boolean that, when <code>True</code>, stores extended result information for tasks, providing more details about their execution. Default: <code>True</code>.</li> </ul>"},{"location":"settings/#email","title":"Email","text":"<p>These settings configure the email backend, enabling the application to send emails for various purposes (e.g., user registration, password resets):</p> <ul> <li><code>EMAIL_HOST</code>: The hostname or IP address of the SMTP server used for sending emails. Default: <code>smtp.gmail.com</code> (loaded from <code>env(\"EMAIL_HOST\", default=\"smtp.gmail.com\")</code>).</li> <li><code>EMAIL_USE_TLS</code>: A boolean that determines whether to use TLS (Transport Layer Security) for a secure connection to the SMTP server. Default: <code>True</code> (loaded from <code>env.bool(\"EMAIL_USE_TLS\", default=True)</code>). It is highly recommended to keep this <code>True</code> for production.</li> <li><code>EMAIL_PORT</code>: The port number for the SMTP server. Default: <code>587</code> (loaded from <code>env.int(\"EMAIL_PORT\", default=587)</code>). Common ports are 587 (for TLS) or 465 (for SSL).</li> <li><code>EMAIL_HOST_USER</code>: The username for authenticating with the SMTP server. Default: <code>\"\"</code> (loaded from <code>env(\"EMAIL_HOST_USER\", default=\"\")</code>). This should be set to your email account username.</li> <li><code>EMAIL_HOST_PASSWORD</code>: The password for authenticating with the SMTP server. Default: <code>\"\"</code> (loaded from <code>env(\"EMAIL_HOST_PASSWORD\", default=\"\")</code>). This should be set to your email account password or an application-specific password.</li> </ul>"},{"location":"settings/#sentry-and-logging","title":"Sentry and Logging","text":"<p>While the logging system has its own dedicated documentation page (Logging System), this section briefly covers settings related to error tracking with Sentry and general logging configurations:</p> <ul> <li><code>IGNORABLE_404_URLS</code>: A list of regular expressions for URLs that should not trigger 404 errors in logging or error reporting systems (like Sentry). Default: Includes patterns for common favicon and Apple touch icon requests, reducing noise in logs.</li> <li><code>LOGGING</code>: This dictionary contains the detailed configuration for the project's logging system. For a comprehensive understanding of how logging is set up and used, refer to the Logging System documentation.</li> <li><code>sentry_sdk.init()</code>: This function initializes the Sentry SDK for error tracking and performance monitoring. Default: It is conditionally initialized in production environments (when <code>DEBUG</code> is <code>False</code>) with parameters such as <code>dsn</code> (your Sentry project DSN), <code>traces_sample_rate=1.0</code> (for performance monitoring), and <code>profiles_sample_rate=1.0</code> (for profiling).</li> </ul>"},{"location":"settings/#static-media-files","title":"Static &amp; Media Files","text":"<p>These settings govern how static files (CSS, JavaScript, images) and user-uploaded media files are handled and served by the Django application:</p> <ul> <li><code>STORAGES</code>: Defines the storage backends for different types of files. Default: Uses <code>FileSystemStorage</code> for default file storage and <code>whitenoise.storage.CompressedManifestStaticFilesStorage</code> for static files, which handles compression and caching for production.</li> <li><code>STATIC_URL</code>: The URL prefix to use when referring to static files. Default: <code>/static/</code>. For example, if you have a static file <code>my_app/static/css/style.css</code>, it would be accessible at <code>/static/css/style.css</code>.</li> <li><code>STATICFILES_DIRS</code>: A list of directories where Django will search for additional static files, beyond those found within individual app's <code>static/</code> directories. Default: <code>[root_path(\"static\")]</code>.</li> <li><code>STATIC_ROOT</code>: The absolute path to the directory where Django's <code>collectstatic</code> command will gather all static files for deployment. Default: A temporary directory if <code>DEBUG</code> is <code>True</code>, otherwise a <code>static_root</code> directory within the project root. This directory should be served directly by your web server in production.</li> <li><code>MEDIA_URL</code>: The URL prefix that handles media files served from <code>MEDIA_ROOT</code>. Default: <code>/media/</code>. This is used for user-uploaded content.</li> <li><code>MEDIA_ROOT</code>: The absolute path to the directory where user-uploaded media files are stored. Default: A <code>media_root</code> directory within the project root. This directory should be configured for serving by your web server.</li> <li><code>ADMIN_MEDIA_PREFIX</code>: The URL prefix for Django admin's static media files. Default: <code>/static/admin/</code>.</li> </ul>"},{"location":"settings/#django-debug-toolbar-and-django-extensions","title":"Django Debug Toolbar and Django Extensions","text":"<p>These development-centric tools are conditionally enabled only when Django's <code>DEBUG</code> mode is active, providing valuable insights and utilities during development:</p> <ul> <li><code>debug_toolbar</code>: Integrates the Django Debug Toolbar, which provides a customizable debug panel for inspecting various aspects of your Django application (e.g., SQL queries, request/response headers, templates). Default: Automatically added to <code>INSTALLED_APPS</code> and <code>MIDDLEWARE</code> if <code>DEBUG</code> is <code>True</code>.</li> <li><code>INTERNAL_IPS</code>: A list of IP addresses that are considered \"internal\" for the Django Debug Toolbar. Requests originating from these IP addresses will display the debug toolbar. Default: <code>[\"127.0.0.1\"]</code>.</li> <li><code>django_extensions</code>: Provides a collection of custom extensions for Django, including a variety of useful management commands (e.g., <code>runserver_plus</code>, <code>shell_plus</code>). Default: Automatically added to <code>INSTALLED_APPS</code> if <code>DEBUG</code> is <code>True</code>.</li> </ul> <p>These settings are dynamically included in <code>INSTALLED_APPS</code> and <code>MIDDLEWARE</code> when <code>DEBUG</code> is <code>True</code>, ensuring they are only active in development environments.</p>"},{"location":"tasks/","title":"Celery Tasks","text":"<p>This section provides a comprehensive guide to working with Celery tasks in the Django Starter Template, including how to create, configure, and manage them, with a focus on retry mechanisms and periodic tasks.</p>"},{"location":"tasks/#overview","title":"Overview","text":"<p>Celery is an asynchronous task queue/job queue based on distributed message passing. It's used in this project to offload long-running operations from the main request-response cycle, improving application responsiveness and scalability.</p>"},{"location":"tasks/#configuration","title":"Configuration","text":"<p>Celery is configured in <code>conf/celery.py</code>. It integrates with Django's settings, allowing you to manage Celery-related configurations within your Django project.</p> <p>Key settings are typically found in <code>conf/settings.py</code>:</p> <ul> <li><code>CELERY_BROKER_URL</code>: The URL for the message broker (e.g., Redis).</li> <li><code>CELERY_RESULT_BACKEND</code>: Where task results are stored (e.g., Django database).</li> <li><code>CELERY_BEAT_SCHEDULER</code>: Specifies the scheduler for periodic tasks.</li> </ul>"},{"location":"tasks/#creating-new-tasks","title":"Creating New Tasks","text":"<p>To create a new Celery task, use the <code>@shared_task</code> decorator from <code>celery</code>.</p> <pre><code>from celery import shared_task\n\n@shared_task\ndef my_new_task(arg1, arg2):\n    # Your task logic here\n    print(f\"Executing my_new_task with {arg1} and {arg2}\")\n</code></pre> <p>Place your task definitions in <code>tasks.py</code> files within your Django apps (e.g., <code>apps/core/tasks.py</code>). Celery is configured to automatically discover tasks in installed apps.</p>"},{"location":"tasks/#task-retries","title":"Task Retries","text":"<p>The template provides a custom base task class, <code>BaseTaskWithRetry</code>, located in <code>apps/core/tasks.py</code>, which simplifies implementing retry logic for your tasks.</p>"},{"location":"tasks/#basetaskwithretry-attributes","title":"<code>BaseTaskWithRetry</code> Attributes","text":"<ul> <li><code>autoretry_for</code>: A tuple of exception types that should trigger a retry. If any of these exceptions occur during task execution, Celery will automatically retry the task.</li> <li><code>retry_kwargs</code>: A dictionary of keyword arguments passed to the <code>retry()</code> method. The most common is <code>max_retries</code>, which defines the maximum number of times the task will be retried.</li> <li><code>retry_backoff</code>: The initial delay in seconds before the first retry attempt. Subsequent retries will have an exponentially increasing delay.</li> <li><code>retry_jitter</code>: A boolean that, when <code>True</code>, adds a random component to the retry delay. This helps prevent all failed tasks from retrying simultaneously, which can lead to a \"thundering herd\" problem.</li> </ul>"},{"location":"tasks/#example-usage","title":"Example Usage","text":"<p>To use <code>BaseTaskWithRetry</code> for your task, simply set its <code>base</code> argument in the <code>@shared_task</code> decorator:</p> <pre><code>from celery import shared_task\nfrom apps.core.tasks import BaseTaskWithRetry\n\n@shared_task(bind=True, base=BaseTaskWithRetry)\ndef my_retriable_task(self):\n    try:\n        # Your task logic that might fail\n        result = 1 / 0 # Example of an error\n        return result\n    except Exception as e:\n        # Log the error or perform any necessary cleanup before retrying\n        print(f\"Task failed: {e}. Retrying...\")\n        raise self.retry(exc=e)\n</code></pre>"},{"location":"tasks/#calling-tasks","title":"Calling Tasks","text":"<p>Tasks can be called in a few ways:</p> <ul> <li> <p>Asynchronously (recommended for most cases):</p> <pre><code>my_new_task.delay(arg1_value, arg2_value)\n</code></pre> </li> <li> <p>With more control (e.g., setting a countdown or ETA):</p> <pre><code>from datetime import datetime, timedelta\n\n# Execute in 10 seconds\nmy_new_task.apply_async((arg1_value, arg2_value), countdown=10)\n\n# Execute at a specific time\neta_time = datetime.now() + timedelta(minutes=5)\nmy_new_task.apply_async((arg1_value, arg2_value), eta=eta_time)\n</code></pre> </li> </ul>"},{"location":"tasks/#periodic-tasks","title":"Periodic Tasks","text":"<p>Celery Beat is a scheduler that kicks off tasks periodically. In this project, periodic tasks are managed through the Django Admin interface.</p>"},{"location":"tasks/#steps-to-configure-a-periodic-task","title":"Steps to Configure a Periodic Task","text":"<ol> <li> <p>Start Celery Worker: Ensure your Celery worker is running:</p> <pre><code>poetry run worker\n</code></pre> </li> <li> <p>Start Celery Beat: Start the Celery Beat scheduler:</p> <pre><code>poetry run beat\n</code></pre> </li> <li> <p>Configure in Django Admin: Navigate to the Django Admin interface (<code>/admin-panel/</code>). Under the <code>DJANGO CELERY BEAT</code> section, you can add and manage <code>Periodic tasks</code>. You'll need to specify:</p> <ul> <li>The task name (e.g., <code>apps.core.tasks.my_periodic_task</code>).</li> <li>The schedule (e.g., every 5 minutes, daily, etc.).</li> <li>Any arguments or keyword arguments for the task.</li> </ul> </li> </ol>"},{"location":"tasks/#example-periodic-task","title":"Example Periodic Task","text":"<pre><code>from celery import shared_task\n\n@shared_task\ndef my_periodic_task():\n    print(\"This task runs periodically!\")\n</code></pre>"},{"location":"testing/","title":"Testing","text":"<p>This project uses <code>pytest</code> as its primary testing framework, integrated with <code>pytest-django</code> for seamless Django testing and <code>pytest-cov</code> for code coverage analysis. This setup ensures a robust and efficient testing environment.</p>"},{"location":"testing/#testing-setup","title":"Testing Setup","text":""},{"location":"testing/#pytestini-configuration","title":"<code>pytest.ini</code> Configuration","text":"<p>The <code>pytest.ini</code> file in the project root configures <code>pytest</code> behavior:</p> <pre><code>[pytest]\nDJANGO_SETTINGS_MODULE = conf.test_settings\npython_files = tests.py test_*.py *_tests.py\n\naddopts = --reuse-db --nomigrations --cov=. --cov-report=html --cov-report=term-missing --no-cov-on-fail\n</code></pre> <ul> <li><code>DJANGO_SETTINGS_MODULE = conf.test_settings</code>: Specifies that <code>conf.test_settings.py</code> should be used for running tests. This file typically contains settings optimized for testing (e.g., using an in-memory database).</li> <li><code>python_files = tests.py test_*.py *_tests.py</code>: Defines the naming conventions for test files that <code>pytest</code> should discover.</li> <li><code>addopts</code>: Additional command-line options that are always passed to <code>pytest</code>:<ul> <li><code>--reuse-db</code>: Reuses the test database between test runs, significantly speeding up subsequent test executions.</li> <li><code>--nomigrations</code>: Prevents Django from running migrations during tests, assuming your test database schema is up-to-date.</li> <li><code>--cov=.</code>: Enables code coverage analysis for the entire project.</li> <li><code>--cov-report=html</code>: Generates an HTML report for code coverage, providing a visual breakdown of covered and uncovered lines.</li> <li><code>--cov-report=term-missing</code>: Displays missing coverage information directly in the terminal.</li> <li><code>--no-cov-on-fail</code>: Prevents coverage reporting if tests fail.</li> </ul> </li> </ul>"},{"location":"testing/#test-file-organization","title":"Test File Organization","text":"<p>Tests are organized by application within <code>tests/</code> directories. For example, tests for the <code>users</code> app are located in <code>apps/users/tests/</code>.</p> <ul> <li><code>apps/core/tests/</code>: Contains tests for core functionalities.</li> <li><code>apps/users/tests/</code>: Contains tests for user management and authentication.</li> </ul> <p>This structure keeps tests co-located with the code they test, making it easier to find and maintain them.</p>"},{"location":"testing/#running-tests","title":"Running Tests","text":"<p>To run tests, use the <code>poetry run pytest</code> command. The <code>pytest.ini</code> configuration will automatically apply the necessary options.</p>"},{"location":"testing/#basic-test-run","title":"Basic Test Run","text":"<p>To run all tests:</p> <pre><code>poetry run pytest\n</code></pre>"},{"location":"testing/#running-tests-with-coverage","title":"Running Tests with Coverage","text":"<p>To run tests and generate a code coverage report:</p> <pre><code>poetry run pytest --cov\n</code></pre> <p>This will output a summary of code coverage in the terminal. To generate a detailed HTML report (which you can open in your browser for a visual representation of coverage):</p> <pre><code>poetry run pytest --cov --cov-report=html\n</code></pre> <p>The HTML report will be generated in the <code>htmlcov/</code> directory in your project root.</p>"},{"location":"testing/#running-specific-tests","title":"Running Specific Tests","text":"<p>You can run specific test files or even individual test functions:</p> <ul> <li> <p>Run tests in a specific file:</p> <pre><code>poetry run pytest apps/users/tests/test_user_model.py\n</code></pre> </li> <li> <p>Run a specific test function:</p> <pre><code>poetry run pytest apps/users/tests/test_user_model.py::test_create_user\n</code></pre> </li> </ul>"},{"location":"testing/#best-practices","title":"Best Practices","text":"<ul> <li>Test Coverage: Aim for high test coverage, especially for critical business logic and API endpoints. The <code>--cov</code> option helps you track this.</li> <li>Fixtures: Utilize <code>pytest</code> fixtures to set up common test data and environments, promoting reusability and reducing boilerplate code.</li> <li>Clear Naming: Name your test files and functions clearly (e.g., <code>test_feature_name.py</code>, <code>test_function_behavior</code>) to make it easy to understand what each test covers.</li> <li>Isolation: Ensure your tests are isolated and do not depend on the state of previous tests. Use <code>pytest-django</code>'s transactional test cases or database cleanup mechanisms.</li> </ul>"},{"location":"ai_tools/","title":"AI Tools and CLI Agents","text":"<p>This section provides documentation on the various AI tools and CLI agents used in this project to enhance development, code quality, and automation.</p> <ul> <li>Gemini CLI Agent</li> <li>GitHub Copilot</li> <li>Roo Code and Cline</li> </ul>"},{"location":"ai_tools/cline_roocode/","title":"Roo Code and Cline","text":"<p>This page details the rules and best practices enforced by Cline for Django backend development within this project. For the full, up-to-date rules, please refer to the <code>.clinerules/django-backend-rules.md</code> file in the project root.</p>"},{"location":"ai_tools/cline_roocode/#brief-overview","title":"Brief overview","text":"<p>This document outlines rules and best practices for Django backend development, covering framework usage, project structure, testing, and documentation.</p>"},{"location":"ai_tools/cline_roocode/#framework-core-dependencies","title":"Framework &amp; Core Dependencies","text":"<ul> <li>Use Django 5.2+ with Django REST Framework for APIs</li> <li>Default to PostgreSQL for database operations</li> <li>Implement Redis caching for expensive operations</li> <li>Use django-rest-knox for authentication</li> <li>Document APIs using drf-spectacular</li> </ul>"},{"location":"ai_tools/cline_roocode/#project-structure","title":"Project Structure","text":"<ul> <li>Follow Django's recommended project layout strictly</li> <li>Keep apps modular with single responsibilities</li> <li>Place test files in each app's <code>tests</code> directory</li> <li>Implement RESTful API patterns consistently</li> </ul>"},{"location":"ai_tools/cline_roocode/#development-practices","title":"Development Practices","text":"<ul> <li>Strictly follow Django's security standards</li> <li>Use DRF viewsets and serializers for all endpoints</li> <li>Implement proper authentication with knox</li> <li>Cache expensive operations using Redis</li> <li>Document APIs with OpenAPI/Swagger via drf-spectacular</li> </ul>"},{"location":"ai_tools/cline_roocode/#testing-requirements","title":"Testing Requirements","text":"<ul> <li>Write comprehensive unit tests for all features</li> <li>Achieve minimum test coverage as specified</li> <li>Include positive and negative test scenarios</li> <li>Maintain test files alongside the code they test</li> </ul>"},{"location":"ai_tools/cline_roocode/#documentation-standards","title":"Documentation Standards","text":"<ul> <li>Include docstrings for all important classes/methods</li> <li>Document API endpoints thoroughly</li> <li>Keep documentation up-to-date with code changes</li> <li>Reference official Django/DRF documentation</li> </ul>"},{"location":"ai_tools/cline_roocode/#additional-guidelines","title":"Additional Guidelines","text":"<ul> <li>Prefer Django's built-in solutions over custom ones</li> <li>Maintain backward compatibility when making changes</li> <li>Validate all user input thoroughly</li> <li>Implement proper error handling and logging</li> </ul>"},{"location":"ai_tools/copilot/","title":"GitHub Copilot","text":"<p>This page provides detailed information and guidelines for using GitHub Copilot within this project.</p>"},{"location":"ai_tools/copilot/#technical-requirements-and-communication-standards","title":"Technical Requirements and Communication Standards","text":"<p>This project adheres to specific technical requirements and communication standards for Django backend development when using GitHub Copilot:</p> <p>Framework &amp; Core Dependencies: - Django 5.2+ with Django REST Framework - PostgreSQL database - Redis for caching - Authentication via django-rest-knox - API documentation using drf-spectacular - Testing framework: Pytest or Django/DRF TestCase</p> <p>Project Structure: - Test files must be placed in each app's <code>tests</code> directory - Follow Django's recommended project layout - Implement RESTful API patterns</p> <p>Development Guidelines: 1. All implementations must follow Django's best practices and security standards 2. Use Django REST Framework viewsets and serializers when building APIs 3. Implement proper authentication and permission checks using knox 4. Cache expensive operations using Redis 5. Document all APIs using OpenAPI/Swagger via drf-spectacular</p> <p>Testing Requirements: 1. Write comprehensive unit tests for all features 2. Follow Pytest conventions and patterns 3. Achieve minimum test coverage as per project standards 4. Include both positive and negative test scenarios</p> <p>Documentation: 1. Reference official Django and DRF documentation 2. Include docstrings for all classes and methods that have an important role 3. Document API endpoints using drf-spectacular decorators</p> <p>Response Format: 1. Provide direct, implementation-focused answers 2. Highlight any missing information needed for implementation 3. Include code examples only when explicitly requested 4. Format code according to PEP 8 standards</p> <ul> <li>Utilize context7 MCP for current documentation when applicable</li> </ul> <p>All responses must focus on technical implementation within these specifications and avoid theoretical discussions or alternative technology suggestions.</p>"},{"location":"ai_tools/copilot/#feature-prompt-featurepromptmd","title":"Feature Prompt (<code>feature.prompt.md</code>)","text":"<p>Purpose: Use this prompt when you need to plan and implement a new feature. It guides Copilot to think about the feature's overview, impact, implementation plan, code, and integration strategy.</p> <pre><code>As a professional developer, analyze and implement a new feature in the codebase following these guidelines:\n\n1. Feature Overview\n   - Describe the feature's core functionality and purpose\n   - List specific requirements and acceptance criteria\n   - Define expected inputs and outputs\n   - Specify performance targets and constraints\n\n2. Impact Analysis\n   - Identify affected components and dependencies\n   - Evaluate performance implications\n   - Assess security considerations\n   - Document potential risks and mitigations\n\n3. Implementation Plan\n   - Break down the feature into atomic tasks\n   - Specify interfaces and data structures\n   - Define error handling and edge cases\n   - List required test scenarios\n\n4. Code Implementation\n   - Provide code examples for each component\n   - Include inline documentation\n   - Follow project coding standards\n   - Implement necessary unit tests\n\n5. Integration Strategy\n   - Outline deployment steps\n   - Specify configuration changes\n   - Document API modifications\n   - Define rollback procedures\n\nInclude benchmark results, security review findings, and maintainability metrics for each implemented component. Prioritize clean architecture and SOLID principles.\n</code></pre>"},{"location":"ai_tools/copilot/#refactor-prompt-refactorpromptmd","title":"Refactor Prompt (<code>refactor.prompt.md</code>)","text":"<p>Purpose: Use this prompt when you want to refactor existing code. It directs Copilot to focus on performance, security, maintainability, and readability, providing a structured approach to code improvement.</p> <pre><code>As a senior software engineer, analyze the provided code and suggest specific refactoring improvements focusing on these key aspects:\n\n1. Performance:\n- Identify algorithmic inefficiencies\n- Optimize resource usage and memory management\n- Suggest caching strategies where applicable\n- Highlight potential bottlenecks\n\n2. Security:\n- Review for common vulnerabilities (OWASP Top 10)\n- Ensure proper input validation\n- Verify authentication and authorization\n- Check for secure data handling\n\n3. Maintainability:\n- Apply SOLID principles\n- Improve code organization and structure\n- Reduce technical debt\n- Enhance modularity and reusability\n\n4. Readability:\n- Follow language-specific style guides\n- Apply consistent naming conventions\n- Add meaningful comments and documentation\n- Break down complex logic into smaller functions\n\nFor each suggested improvement:\n- Explain the rationale\n- Provide a code example\n- Highlight potential trade-offs\n- Consider the impact on existing functionality\n\nPlease provide the code you want to refactor, and specify any constraints or requirements specific to your project's context.\n</code></pre>"},{"location":"ai_tools/copilot/#security-prompt-securitypromptmd","title":"Security Prompt (<code>security.prompt.md</code>)","text":"<p>Purpose: Use this prompt to conduct a security review of your API implementation. It guides Copilot to check for authentication, authorization, input validation, rate limiting, and security monitoring.</p> <pre><code>Conduct a comprehensive security review of the REST API implementation according to industry best practices. Review and implement the following security controls:\n\nAuthentication &amp; Authorization:\n- Verify JWT/OAuth2 authentication is properly implemented for all endpoints\n- Confirm role-based access control (RBAC) is enforced\n- Check token validation, expiration, and refresh mechanisms\n- Ensure sensitive endpoints require appropriate scopes/permissions\n\nInput Validation &amp; Sanitization:\n- Validate request parameters, headers, and body content\n- Implement strong input validation using a schema validator (e.g. JSON Schema)\n- Apply appropriate encoding for special characters\n- Prevent SQL injection, XSS, and CSRF attacks\n\nRate Limiting &amp; DDoS Protection:\n- Set appropriate rate limits per endpoint/user\n- Implement exponential backoff for failed attempts\n- Configure API gateway throttling rules\n- Document rate limit headers and responses\n\nSecurity Monitoring:\n- Enable detailed logging for authentication attempts\n- Track and alert on suspicious activity patterns\n- Log all administrative actions and data modifications\n- Implement audit trails for sensitive operations\n- Set up automated security scanning and penetration testing\n\nFollow OWASP API Security Top 10 guidelines and document any findings in a security assessment report.\n\nReferences:\n- OWASP API Security Top 10: https://owasp.org/www-project-api-security/\n- NIST Security Guidelines for Web Services\n</code></pre>"},{"location":"ai_tools/copilot/#test-model-prompt-test-modelpromptmd","title":"Test Model Prompt (<code>test-model.prompt.md</code>)","text":"<p>Purpose: Use this prompt when writing tests for Django models. It ensures comprehensive test coverage for field validation, relationships, data operations, edge cases, and performance.</p> <pre><code>Write comprehensive model tests for Django applications adhering to the following specifications:\n\n## Test Structure\n- Organize tests in `tests/test_&lt;model_name&gt;.py` within each Django app\n- Implement tests using pytest or Django TestCase\n- Follow PEP 8 and Django coding standards\n\n## Required Test Coverage\n\n### 1. Field Validation\n- Test all model field constraints:\n  - Required fields (null/blank)\n  - Field type validations\n  - Length/range restrictions\n  - Custom validators\n  - Unique constraints\n  - Index effectiveness\n\n### 2. Relationships\n- Validate ForeignKey constraints\n- Test ManyToMany relationship behaviors\n- Verify cascading operations\n- Check related field access patterns\n\n### 3. Data Operations\n- Test CRUD operations\n- Verify bulk operations performance\n- Validate custom manager methods\n- Test model-specific business logic\n- Check complex queries and filters\n\n### 4. Edge Cases\n- Test boundary conditions\n- Include negative test scenarios\n- Validate error handling\n- Check race conditions\n\n### 5. Performance\n- Benchmark query execution times\n- Test with representative data volumes\n- Verify index usage\n- Monitor memory consumption\n\n## Documentation\n- Add descriptive docstrings\n- Document test fixtures\n- Explain complex test scenarios\n- Reference expected behaviors\n\n## References\n- Django Testing Documentation: https://docs.djangoproject.com/en/stable/topics/testing/\n- pytest-django: https://pytest-django.readthedocs.io/\n\nUse appropriate fixtures and mocking strategies to ensure tests are isolated and repeatable.\n</code></pre>"},{"location":"ai_tools/copilot/#test-view-prompt-test-viewpromptmd","title":"Test View Prompt (<code>test-view.prompt.md</code>)","text":"<p>Purpose: Use this prompt when writing tests for Django REST framework API views. It ensures comprehensive test coverage for authentication, security, HTTP methods, response validation, and edge cases.</p> <pre><code>Generate comprehensive test suite for Django REST framework API views following these requirements:\n\n1. Test Location and Framework:\n   - Place tests in the `tests` directory within each Django app\n   - Use Pytest or Django/DRF TestCase as the testing framework\n   - Follow the `test_&lt;view_name&gt;.py` naming convention\n\n2. Authentication &amp; Security Tests:\n   - Verify authentication requirements for each endpoint\n   - Test authorization rules and permissions\n   - Validate rate limiting functionality\n   - Test request throttling behavior\n\n3. HTTP Method Coverage:\n   - Test all CRUD operations: GET, POST, PUT, PATCH, DELETE\n   - Verify correct HTTP status codes (200, 201, 204, 400, 401, 403, 404, etc.)\n   - Include both successful and error scenarios\n   - Test request payload validation\n\n4. Response Validation:\n   - Verify response structure and data types\n   - Check serializer field validation\n   - Test pagination if implemented\n   - Validate filtering and sorting functionality\n\n5. Documentation Requirements:\n   - Include docstrings describing test purpose\n   - Document test data and fixtures\n   - Add comments for complex test scenarios\n\n6. Edge Cases:\n   - Test boundary conditions\n   - Include negative testing scenarios\n   - Verify error message formats\n\nReference Django REST framework testing documentation for best practices:\nhttps://www.django-rest-framework.org/api-guide/testing/\n</code></pre>"},{"location":"ai_tools/copilot/#reusable-prompts","title":"Reusable Prompts","text":"<p>Specific reusable prompts for various tasks are located in the .github/prompts/ directory: *   <code>feature.prompt.md</code> *   <code>refactor.prompt.md</code> *   <code>security.prompt.md</code> *   <code>test-model.prompt.md</code> *   `test-view.prompt.md</p>"},{"location":"ai_tools/gemini/","title":"Gemini CLI Agent","text":"<p>This page provides specific guidelines and context for the Gemini CLI agent when interacting with the <code>django-starter-template</code> project. For the full, up-to-date guidelines, please refer to the <code>GEMINI.md</code> file in the project root.</p>"},{"location":"ai_tools/gemini/#project-overview","title":"Project Overview","text":"<p>This project is a Django REST Framework API template designed for rapid development. It includes pre-configured setups for authentication, background tasks, API documentation, and structured logging.</p>"},{"location":"ai_tools/gemini/#key-technologies-and-conventions","title":"Key Technologies and Conventions","text":"<ul> <li>Framework: Django 5.x</li> <li>API Framework: Django REST Framework (DRF)</li> <li>Dependency Management: Poetry<ul> <li>Always use <code>poetry run &lt;command&gt;</code> for executing project-specific scripts or commands (e.g., <code>poetry run server</code>, <code>poetry run pytest</code>).</li> <li>Dependencies are defined in <code>pyproject.toml</code> and managed by <code>poetry.lock</code>.</li> </ul> </li> <li>Testing: Pytest<ul> <li>Test files are typically located in <code>apps/&lt;app_name&gt;/tests/</code>.</li> <li>Run tests using <code>poetry run test</code> or <code>poetry run pytest</code>.</li> <li>Code coverage can be generated with <code>poetry run test-cov</code>.</li> </ul> </li> <li>API Documentation: drf-spectacular<ul> <li>OpenAPI 3 schema generation.</li> <li>Schema definitions are often centralized in <code>schema.py</code> files within apps (e.g., <code>apps/users/schema.py</code>).</li> <li>Use <code>@extend_schema</code> decorator for detailed API documentation.</li> </ul> </li> <li>Documentation (MkDocs): MkDocs with Material theme.<ul> <li>Documentation source files are in the <code>docs/</code> directory.</li> <li>The <code>mkdocs.yml</code> file configures the documentation site.</li> <li>When refactoring documentation, maintain the style and structure observed in <code>logging.md</code>, <code>tasks.md</code>, <code>rate_limiting.md</code>, <code>database_seeding.md</code>, <code>testing.md</code>, <code>environment_setup.md</code>, and <code>copilot_prompts.md</code>.</li> </ul> </li> <li>Environment Variables: Managed using <code>django-environ</code>.<ul> <li>Configuration is loaded from <code>.env</code> files. Refer to <code>.env.example</code> for required variables.</li> </ul> </li> <li>Asynchronous Tasks: Celery with Redis as broker and backend.<ul> <li>Celery worker: <code>poetry run worker</code></li> <li>Celery beat scheduler: <code>poetry run beat</code></li> </ul> </li> <li>Logging: Structured JSON logging.<ul> <li>Logs are typically written to the <code>logs/</code> directory.</li> <li>Request tracing is implemented via <code>RequestIDMiddleware</code>.</li> </ul> </li> <li>Code Quality: Flake8 for linting.<ul> <li>Configuration is in <code>.flake8</code>.</li> </ul> </li> <li>Development Environment: Designed for use with VS Code Dev Containers.<ul> <li>Ensures a consistent and reproducible development setup.</li> </ul> </li> </ul>"},{"location":"ai_tools/gemini/#general-instructions-for-gemini","title":"General Instructions for Gemini","text":"<ul> <li>Adhere to existing code style: When modifying or adding code, always match the surrounding code's formatting, naming conventions, and architectural patterns.</li> <li>Verify dependencies: Before suggesting or implementing new libraries, check <code>pyproject.toml</code> and <code>poetry.lock</code> to see if they are already in use. If not, propose adding them via Poetry.</li> <li>Prioritize existing solutions: Leverage existing project features (e.g., <code>drf-spectacular</code> for API docs, Celery for background tasks) before introducing new tools or patterns.</li> <li>Explain shell commands: For any <code>run_shell_command</code> that modifies the file system or project state, provide a brief explanation of its purpose and potential impact.</li> <li>Testing: If a change involves logic, consider if new or updated tests are appropriate. Use <code>poetry run test</code> to verify changes.</li> <li>Documentation: If new features or significant changes are introduced, update the relevant documentation in the <code>docs/</code> directory, following the established style.</li> </ul>"}]}