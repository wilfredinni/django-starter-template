{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Welcome to the Django Starter Template! <p> A comprehensive starting point for your new API with Django and DRF. </p>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>The recommended way to get started is by using the Dev Container feature in VS Code.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Visual Studio Code</li> <li>Docker Desktop</li> <li>Dev Containers extension for VS Code.</li> </ul>"},{"location":"#setup-steps","title":"Setup Steps","text":"<ol> <li> <p>Use the GitHub Template:</p> <p>Click the green <code>Use this template</code> button on the GitHub repository page to create your own repository.</p> </li> <li> <p>Open in VS Code:</p> <p>Clone your new repository and open its folder in Visual Studio Code.</p> </li> <li> <p>Check the Setup Guide:</p> <p>Before proceeding, check the <code>Todo Tree</code> view in the VS Code sidebar for a guided list of initial setup tasks.</p> </li> <li> <p>Reopen in Container:</p> <p>When prompted, click \"Reopen in Container\" to build and start the dev environment. This will configure Redis, Celery, PostgreSQL, install dependencies, and migrate the database.</p> </li> <li> <p>Create a Superuser:</p> <p>Run python <code>manage.py createsuperuser</code> to create an admin user for accessing the Django admin interface.</p> </li> <li> <p>Start the Server:</p> <p>Run <code>python manage.py runserver</code> to start the development server.</p> </li> </ol> <p>Your API is now running and accessible at <code>http://127.0.0.1:8000</code>.</p>"},{"location":"#key-features","title":"\u2728 Key Features","text":"<p>This template is packed with features to help you build amazing APIs:</p> <ul> <li>User Authentication: Secure token-based authentication with <code>django-rest-knox</code>.</li> <li>Background Tasks: Asynchronous task processing with <code>Celery</code> and <code>Redis</code>.</li> <li>API Documentation: Automatic OpenAPI 3 schema generation with <code>drf-spectacular</code>.</li> <li>Centralized Logging: Structured JSON logging for easy monitoring.</li> <li>Custom User Model: Email-based authentication for a modern user experience.</li> <li>Github Copilot Prompts: Useful prompts to enhance your development experience.</li> <li>And much more! Explore the documentation to discover all the features.</li> </ul>"},{"location":"#explore-the-documentation","title":"\ud83d\udcd6 Explore the Documentation","text":"<p>This documentation is your guide to building amazing applications with the Django Starter Template. Use the navigation on the left to explore the different sections.</p> <ul> <li>Development: Learn about the development workflow, including how to run tests, and use the provided scripts.</li> <li>Project Structure: Get an overview of the project's directory structure.</li> <li>Project Settings: Understand the available settings and how to configure your project.</li> <li>Dependencies: See a list of all the project's dependencies.</li> <li>Authentication: Learn how to use the authentication and user management endpoints.</li> <li>Core App: Discover the core functionalities and API endpoints.</li> <li>Logging: Understand the logging system and how to use it.</li> <li>Celery Tasks: Learn how to create and manage background tasks.</li> <li>Rate Limiting: Configure rate limiting to protect your API.</li> <li>Database Seeding: Learn how to seed your database with initial data.</li> <li>Testing: Understand how to run and write tests for your project.</li> <li>Environment Setup: Learn how to set up your development environment.</li> <li>Copilot Prompts: Explore useful prompts to enhance your development experience with GitHub Copilot.</li> </ul>"},{"location":"authentication/","title":"Authentication Endpoints","text":"<p>This section details the API endpoints related to user authentication and management, all prefixed with <code>/auth/</code>.</p>"},{"location":"authentication/#authentication-settings","title":"Authentication Settings","text":"<p>The following settings in <code>conf/settings.py</code> are relevant to authentication and user management:</p> <ul> <li> <p><code>AUTH_USER_MODEL</code>: Specifies the custom user model to use. Default: <code>users.CustomUser</code>. This allows you to extend Django's default user model with custom fields and behaviors.</p> </li> <li> <p><code>MIN_PASSWORD_LENGTH</code>: Minimum length for user passwords. Default: <code>8</code> (loaded from <code>env.int(\"MIN_PASSWORD_LENGTH\", default=8)</code>). This is used by the password validation system.</p> </li> <li> <p><code>PASSWORD_HASHERS</code>: A list of password hashing algorithms used for storing user passwords. Default: A list including <code>ScryptPasswordHasher</code>, <code>PBKDF2PasswordHasher</code>, <code>PBKDF2SHA1PasswordHasher</code>, <code>Argon2PasswordHasher</code>, and <code>BCryptSHA256PasswordHasher</code>. This provides strong password security.</p> </li> <li> <p><code>AUTH_PASSWORD_VALIDATORS</code>: Configures password validation rules. Default: Includes validators for user attribute similarity, minimum length, common passwords, and numeric passwords. You can customize these to enforce stronger password policies.</p> </li> </ul>"},{"location":"authentication/#rest_knox","title":"<code>REST_KNOX</code>","text":"<p>Configuration for <code>django-rest-knox</code>, the token-based authentication system.</p> <ul> <li><code>SECURE_HASH_ALGORITHM</code>: The hashing algorithm used for tokens. Default: <code>hashlib.sha512</code>.</li> <li><code>AUTH_TOKEN_CHARACTER_LENGTH</code>: The length of the authentication token. Default: <code>64</code>.</li> <li><code>TOKEN_TTL</code>: Token time-to-live. Default: <code>timedelta(hours=10)</code>. This defines how long a token is valid.</li> <li><code>USER_SERIALIZER</code>: The serializer used for user profiles. Default: <code>apps.users.serializers.UserProfileSerializer</code>.</li> <li><code>TOKEN_LIMIT_PER_USER</code>: Limits the number of active tokens per user. Default: <code>None</code> (no limit).</li> <li><code>AUTO_REFRESH</code>: Whether tokens should be automatically refreshed. Default: <code>False</code>.</li> <li><code>AUTO_REFRESH_MAX_TTL</code>: Maximum time-to-live for auto-refreshed tokens. Default: <code>None</code>.</li> <li><code>MIN_REFRESH_INTERVAL</code>: Minimum interval between token refreshes. Default: <code>60</code> seconds.</li> <li><code>AUTH_HEADER_PREFIX</code>: The prefix for the Authorization header. Default: <code>Bearer</code>.</li> <li><code>TOKEN_MODEL</code>: The token model used. Default: <code>knox.AuthToken</code>.</li> </ul>"},{"location":"authentication/#rest_framework-authentication-classes-and-throttle-rates","title":"<code>REST_FRAMEWORK</code> Authentication Classes and Throttle Rates","text":"<ul> <li> <p><code>DEFAULT_AUTHENTICATION_CLASSES</code>: Defines authentication methods. Default: <code>knox.auth.TokenAuthentication</code>. In <code>DEBUG</code> mode, <code>SessionAuthentication</code> and <code>BasicAuthentication</code> are also added.</p> </li> <li> <p><code>DEFAULT_THROTTLE_RATES</code>: Configures rate limiting for different user types. Default: <code>user: \"1000/day\"</code>, <code>anon: \"100/day\"</code>, <code>user_login: \"5/minute\"</code>. These can be adjusted based on your application's needs.</p> </li> </ul>"},{"location":"authentication/#endpoints","title":"Endpoints","text":""},{"location":"authentication/#create-user","title":"Create User","text":"<p>POST /auth/create/</p> <p>Creates a new user.</p> <p>Request Body:</p> <pre><code>{\n    \"email\": \"user@example.com\",\n    \"password\": \"complexpassword123\",\n    \"password2\": \"complexpassword123\"\n}\n</code></pre> <p>Success Response (201 Created):</p> <pre><code>{\n    \"email\": \"user@example.com\"\n}\n</code></pre> <p>Error Responses:</p> <p>400 Bad Request (Passwords do not match):</p> <pre><code>{\n    \"password\": [\n        \"Passwords do not match.\"\n    ]\n}\n</code></pre> <p>400 Bad Request (Email already registered):</p> <pre><code>{\n    \"email\": [\n        \"This email is already registered.\"\n    ]\n}\n</code></pre> <p>401 Unauthorized:</p> <pre><code>{\n    \"detail\": \"Authentication credentials were not provided.\"\n}\n</code></pre>"},{"location":"authentication/#login","title":"Login","text":"<p>POST /auth/login/</p> <p>Logs in a user and returns an authentication token.</p> <p>Request Body:</p> <pre><code>{\n    \"email\": \"user@example.com\",\n    \"password\": \"complexpassword123\"\n}\n</code></pre> <p>Success Response (200 OK):</p> <pre><code>{\n    \"expiry\": \"2025-07-09T12:00:00Z\",\n    \"token\": \"your-auth-token\",\n    \"user\": {\n        \"email\": \"user@example.com\",\n        \"first_name\": \"\",\n        \"last_name\": \"\"\n    }\n}\n</code></pre> <p>Error Responses:</p> <p>400 Bad Request (Invalid credentials):</p> <pre><code>{\n    \"detail\": \"Unable to log in with provided credentials.\"\n}\n</code></pre> <p>400 Bad Request (Missing fields):</p> <pre><code>{\n    \"email\": [\n        \"This field is required.\"\n    ],\n    \"password\": [\n        \"This field is required.\"\n    ]\n}\n</code></pre>"},{"location":"authentication/#logout","title":"Logout","text":"<p>POST /auth/logout/</p> <p>Logs out the currently authenticated user.</p> <p>Success Response (204 No Content):</p> <p>The response will have an empty body.</p> <p>Error Responses:</p> <p>401 Unauthorized:</p> <pre><code>{\n    \"detail\": \"Authentication credentials were not provided.\"\n}\n</code></pre>"},{"location":"authentication/#logout-all","title":"Logout All","text":"<p>POST /auth/logoutall/</p> <p>Logs out the currently authenticated user from all sessions.</p> <p>Success Response (204 No Content):</p> <p>The response will have an empty body.</p> <p>Error Responses:</p> <p>401 Unauthorized:</p> <pre><code>{\n    \"detail\": \"Authentication credentials were not provided.\"\n}\n</code></pre>"},{"location":"authentication/#user-profile","title":"User Profile","text":"<p>GET /auth/profile/</p> <p>Retrieves the profile of the currently authenticated user.</p> <p>Success Response (200 OK):</p> <pre><code>{\n    \"email\": \"user@example.com\",\n    \"first_name\": \"John\",\n    \"last_name\": \"Doe\"\n}\n</code></pre> <p>Error Responses:</p> <p>401 Unauthorized:</p> <pre><code>{\n    \"detail\": \"Authentication credentials were not provided.\"\n}\n</code></pre> <p>PUT /auth/profile/</p> <p>Updates the profile of the currently authenticated user.</p> <p>Request Body:</p> <pre><code>{\n    \"first_name\": \"Jane\",\n    \"last_name\": \"Doe\"\n}\n</code></pre> <p>Success Response (200 OK):</p> <pre><code>{\n    \"email\": \"user@example.com\",\n    \"first_name\": \"Jane\",\n    \"last_name\": \"Doe\"\n}\n</code></pre> <p>Error Responses:</p> <p>400 Bad Request (Invalid data):</p> <pre><code>{\n    \"password\": [\n        \"Password must be at least 8 characters long.\"\n    ]\n}\n</code></pre> <p>401 Unauthorized:</p> <pre><code>{\n    \"detail\": \"Authentication credentials were not provided.\"\n}\n</code></pre> <p>PATCH /auth/profile/</p> <p>Partially updates the profile of the currently authenticated user.</p> <p>Request Body:</p> <pre><code>{\n    \"first_name\": \"Jane\"\n}\n</code></pre> <p>Success Response (200 OK):</p> <pre><code>{\n    \"email\": \"user@example.com\",\n    \"first_name\": \"Jane\",\n    \"last_name\": \"Doe\"\n}\n</code></pre> <p>Error Responses:</p> <p>401 Unauthorized:</p> <pre><code>{\n    \"detail\": \"Authentication credentials were not provided.\"\n}\n</code></pre>"},{"location":"auto_documentation/","title":"Auto Documentation (drf-spectacular)","text":"<p>This project leverages <code>drf-spectacular</code> to automatically generate OpenAPI 3 (Swagger) documentation for its REST APIs. This approach ensures that your API documentation is always up-to-date with your codebase, reducing manual effort and potential discrepancies.</p>"},{"location":"auto_documentation/#what-is-drf-spectacular","title":"What is drf-spectacular?","text":"<p><code>drf-spectacular</code> is a powerful library that integrates seamlessly with Django REST Framework to generate a comprehensive OpenAPI schema from your DRF views, serializers, and other components. This schema can then be used to render interactive API documentation (like Swagger UI) or generate client SDKs.</p>"},{"location":"auto_documentation/#how-its-used-in-this-project-best-practices","title":"How it's Used in This Project (Best Practices)","text":"<p>This template follows best practices for <code>drf-spectacular</code> integration to provide rich and accurate API documentation.</p>"},{"location":"auto_documentation/#1-centralized-schema-definitions","title":"1. Centralized Schema Definitions","text":"<p>Instead of defining all schema details directly within views, this project centralizes reusable schema components (like error responses and common examples) in dedicated <code>schema.py</code> files within each app (e.g., <code>apps/users/schema.py</code>, <code>apps/core/schema.py</code>).</p> <p>This promotes reusability and keeps your view logic clean. For example, common error responses are defined once and reused across multiple endpoints.</p> <pre><code># Example from apps/core/schema.py\nfrom drf_spectacular.utils import OpenApiExample, inline_serializer\nfrom rest_framework import serializers\n\nErrorResponseSerializer = inline_serializer(\n    name=\"ErrorResponse\",\n    fields={\n        \"detail\": serializers.CharField(read_only=True),\n        \"code\": serializers.CharField(read_only=True, required=False),\n    },\n)\n\nUNAUTHORIZED_EXAMPLES = [\n    OpenApiExample(\n        \"Unauthorized\",\n        value={\"detail\": \"Authentication credentials were not provided.\"},\n        status_codes=[\"401\"],\n    ),\n    # ... other examples\n]\n</code></pre>"},{"location":"auto_documentation/#2-extend_schema-decorator-for-views","title":"2. <code>extend_schema</code> Decorator for Views","text":"<p>The <code>extend_schema</code> decorator is used on API views to provide additional metadata that <code>drf-spectacular</code> cannot infer automatically. This includes:</p> <ul> <li>Responses: Defining expected success and error responses, often referencing the centralized schema definitions.</li> <li>Request Bodies: Specifying the structure of request payloads.</li> <li>Parameters: Documenting query parameters, path parameters, and headers.</li> <li>Description: Adding human-readable descriptions for endpoints.</li> </ul> <p>Example (from <code>apps/users/views.py</code> for LoginView):</p> <pre><code>from drf_spectacular.utils import extend_schema\n# ... other imports\n\n@extend_schema(responses=LOGIN_RESPONSE_SCHEMA)\nclass LoginView(KnoxLoginView):\n    # ... view implementation\n</code></pre> <p>Here, <code>LOGIN_RESPONSE_SCHEMA</code> is imported from <code>apps/users/schema.py</code>, ensuring consistency and reusability.</p>"},{"location":"auto_documentation/#3-spectacular_settings-in-confsettingspy","title":"3. <code>SPECTACULAR_SETTINGS</code> in <code>conf/settings.py</code>","text":"<p>Global settings for <code>drf-spectacular</code> are configured in <code>conf/settings.py</code> under the <code>SPECTACULAR_SETTINGS</code> dictionary. This includes basic API metadata like title, description, and version.</p> <pre><code># Example from conf/settings.py\nSPECTACULAR_SETTINGS = {\n    \"TITLE\": \"Django Starter Template\",\n    \"DESCRIPTION\": \"A comprehensive starting point for your new API with Django and DRF\",\n    \"VERSION\": \"0.1.0\",\n    \"SERVE_INCLUDE_SCHEMA\": False,\n}\n</code></pre>"},{"location":"auto_documentation/#4-interactive-swagger-ui","title":"4. Interactive Swagger UI","text":"<p>The generated OpenAPI schema is served via Swagger UI, providing an interactive and user-friendly interface to explore and test the API. You can access it at:</p> <p><code>/api/schema/swagger-ui/</code></p> <p>This endpoint is configured in <code>conf/urls.py</code>:</p> <pre><code># Example from conf/urls.py\nfrom drf_spectacular.views import SpectacularAPIView, SpectacularSwaggerView\n\nurlpatterns = [\n    # ... other urls\n]\n\nif settings.DEBUG:\n    urlpatterns += [\n        path(\"api/schema/\", SpectacularAPIView.as_view(), name=\"schema\"),\n        path(\n            \"api/schema/swagger-ui/\",\n            SpectacularSwaggerView.as_view(url_name=\"schema\"),\n            name=\"swagger-ui\",\n        ),\n    ]\n</code></pre> <p>By following these practices, the project ensures that its API documentation is robust, maintainable, and automatically generated, reflecting the true state of the API.</p>"},{"location":"copilot_prompts/","title":"GitHub Copilot Prompts and Guidelines","text":"<p>This document outlines the technical requirements and communication standards for Django backend development within this project, and explains how to leverage specific GitHub Copilot prompts to streamline your workflow.</p>"},{"location":"copilot_prompts/#technical-requirements-and-communication-standards","title":"Technical Requirements and Communication Standards","text":"<p>These guidelines ensure consistency, quality, and adherence to best practices when working with GitHub Copilot:</p> <p>Framework &amp; Core Dependencies: - Django 5.2+ with Django REST Framework - PostgreSQL database - Redis for caching - Authentication via django-rest-knox - API documentation using drf-spectacular - Testing framework: Pytest or Django/DRF TestCase</p> <p>Project Structure: - Test files must be placed in each app's <code>tests</code> directory - Follow Django's recommended project layout - Implement RESTful API patterns</p> <p>Development Guidelines: 1. All implementations must follow Django's best practices and security standards 2. Use Django REST Framework viewsets and serializers when building APIs 3. Implement proper authentication and permission checks using knox 4. Cache expensive operations using Redis 5. Document all APIs using OpenAPI/Swagger via drf-spectacular</p> <p>Testing Requirements: 1. Write comprehensive unit tests for all features 2. Follow Pytest conventions and patterns 3. Achieve minimum test coverage as per project standards 4. Include both positive and negative test scenarios</p> <p>Documentation: 1. Reference official Django and DRF documentation 2. Include docstrings for all classes and methods that have an important role 3. Document API endpoints using drf-spectacular decorators</p> <p>Response Format: 1. Provide direct, implementation-focused answers 2. Highlight any missing information needed for implementation 3. Include code examples only when explicitly requested 4. Format code according to PEP 8 standards</p> <ul> <li>Utilize context7 MCP for current documentation when applicable</li> </ul> <p>All responses must focus on technical implementation within these specifications and avoid theoretical discussions or alternative technology suggestions.</p>"},{"location":"copilot_prompts/#using-github-copilot-prompts","title":"Using GitHub Copilot Prompts","text":"<p>These specialized prompts are designed to guide GitHub Copilot towards generating more relevant and accurate responses for specific development tasks within this project. To use them, copy the content of the desired prompt file and paste it into your GitHub Copilot chat window, followed by your specific request.</p>"},{"location":"copilot_prompts/#feature-prompt-featurepromptmd","title":"Feature Prompt (<code>feature.prompt.md</code>)","text":"<p>Purpose: Use this prompt when you need to plan and implement a new feature. It guides Copilot to think about the feature's overview, impact, implementation plan, code, and integration strategy.</p> <pre><code>As a professional developer, analyze and implement a new feature in the codebase following these guidelines:\n\n1. Feature Overview\n   - Describe the feature's core functionality and purpose\n   - List specific requirements and acceptance criteria\n   - Define expected inputs and outputs\n   - Specify performance targets and constraints\n\n2. Impact Analysis\n   - Identify affected components and dependencies\n   - Evaluate performance implications\n   - Assess security considerations\n   - Document potential risks and mitigations\n\n3. Implementation Plan\n   - Break down the feature into atomic tasks\n   - Specify interfaces and data structures\n   - Define error handling and edge cases\n   - List required test scenarios\n\n4. Code Implementation\n   - Provide code examples for each component\n   - Include inline documentation\n   - Follow project coding standards\n   - Implement necessary unit tests\n\n5. Integration Strategy\n   - Outline deployment steps\n   - Specify configuration changes\n   - Document API modifications\n   - Define rollback procedures\n\nInclude benchmark results, security review findings, and maintainability metrics for each implemented component. Prioritize clean architecture and SOLID principles.\n</code></pre>"},{"location":"copilot_prompts/#refactor-prompt-refactorpromptmd","title":"Refactor Prompt (<code>refactor.prompt.md</code>)","text":"<p>Purpose: Use this prompt when you want to refactor existing code. It directs Copilot to focus on performance, security, maintainability, and readability, providing a structured approach to code improvement.</p> <pre><code>As a senior software engineer, analyze the provided code and suggest specific refactoring improvements focusing on these key aspects:\n\n1. Performance:\n- Identify algorithmic inefficiencies\n- Optimize resource usage and memory management\n- Suggest caching strategies where applicable\n- Highlight potential bottlenecks\n\n2. Security:\n- Review for common vulnerabilities (OWASP Top 10)\n- Ensure proper input validation\n- Verify authentication and authorization\n- Check for secure data handling\n\n3. Maintainability:\n- Apply SOLID principles\n- Improve code organization and structure\n- Reduce technical debt\n- Enhance modularity and reusability\n\n4. Readability:\n- Follow language-specific style guides\n- Apply consistent naming conventions\n- Add meaningful comments and documentation\n- Break down complex logic into smaller functions\n\nFor each suggested improvement:\n- Explain the rationale\n- Provide a code example\n- Highlight potential trade-offs\n- Consider the impact on existing functionality\n\nPlease provide the code you want to refactor, and specify any constraints or requirements specific to your project's context.\n</code></pre>"},{"location":"copilot_prompts/#security-prompt-securitypromptmd","title":"Security Prompt (<code>security.prompt.md</code>)","text":"<p>Purpose: Use this prompt to conduct a security review of your API implementation. It guides Copilot to check for authentication, authorization, input validation, rate limiting, and security monitoring.</p> <pre><code>Conduct a comprehensive security review of the REST API implementation according to industry best practices. Review and implement the following security controls:\n\nAuthentication &amp; Authorization:\n- Verify JWT/OAuth2 authentication is properly implemented for all endpoints\n- Confirm role-based access control (RBAC) is enforced\n- Check token validation, expiration, and refresh mechanisms\n- Ensure sensitive endpoints require appropriate scopes/permissions\n\nInput Validation &amp; Sanitization:\n- Validate request parameters, headers, and body content\n- Implement strong input validation using a schema validator (e.g. JSON Schema)\n- Apply appropriate encoding for special characters\n- Prevent SQL injection, XSS, and CSRF attacks\n\nRate Limiting &amp; DDoS Protection:\n- Set appropriate rate limits per endpoint/user\n- Implement exponential backoff for failed attempts\n- Configure API gateway throttling rules\n- Document rate limit headers and responses\n\nSecurity Monitoring:\n- Enable detailed logging for authentication attempts\n- Track and alert on suspicious activity patterns\n- Log all administrative actions and data modifications\n- Implement audit trails for sensitive operations\n- Set up automated security scanning and penetration testing\n\nFollow OWASP API Security Top 10 guidelines and document any findings in a security assessment report.\n\nReferences:\n- OWASP API Security Top 10: https://owasp.org/www-project-api-security/\n- NIST Security Guidelines for Web Services\n</code></pre>"},{"location":"copilot_prompts/#test-model-prompt-test-modelpromptmd","title":"Test Model Prompt (<code>test-model.prompt.md</code>)","text":"<p>Purpose: Use this prompt when writing tests for Django models. It ensures comprehensive test coverage for field validation, relationships, data operations, edge cases, and performance.</p> <pre><code>Write comprehensive model tests for Django applications adhering to the following specifications:\n\n## Test Structure\n- Organize tests in `tests/test_&lt;model_name&gt;.py` within each Django app\n- Implement tests using pytest or Django TestCase\n- Follow PEP 8 and Django coding standards\n\n## Required Test Coverage\n\n### 1. Field Validation\n- Test all model field constraints:\n  - Required fields (null/blank)\n  - Field type validations\n  - Length/range restrictions\n  - Custom validators\n  - Unique constraints\n  - Index effectiveness\n\n### 2. Relationships\n- Validate ForeignKey constraints\n- Test ManyToMany relationship behaviors\n- Verify cascading operations\n- Check related field access patterns\n\n### 3. Data Operations\n- Test CRUD operations\n- Verify bulk operations performance\n- Validate custom manager methods\n- Test model-specific business logic\n- Check complex queries and filters\n\n### 4. Edge Cases\n- Test boundary conditions\n- Include negative test scenarios\n- Validate error handling\n- Check race conditions\n\n### 5. Performance\n- Benchmark query execution times\n- Test with representative data volumes\n- Verify index usage\n- Monitor memory consumption\n\n## Documentation\n- Add descriptive docstrings\n- Document test fixtures\n- Explain complex test scenarios\n- Reference expected behaviors\n\n## References\n- Django Testing Documentation: https://docs.djangoproject.com/en/stable/topics/testing/\n- pytest-django: https://pytest-django.readthedocs.io/\n\nUse appropriate fixtures and mocking strategies to ensure tests are isolated and repeatable.\n</code></pre>"},{"location":"copilot_prompts/#test-view-prompt-test-viewpromptmd","title":"Test View Prompt (<code>test-view.prompt.md</code>)","text":"<p>Purpose: Use this prompt when writing tests for Django REST framework API views. It ensures comprehensive test coverage for authentication, security, HTTP methods, response validation, and edge cases.</p> <pre><code>Generate comprehensive test suite for Django REST framework API views following these requirements:\n\n1. Test Location and Framework:\n   - Place tests in the `tests` directory within each Django app\n   - Use Pytest or Django/DRF TestCase as the testing framework\n   - Follow the `test_&lt;view_name&gt;.py` naming convention\n\n2. Authentication &amp; Security Tests:\n   - Verify authentication requirements for each endpoint\n   - Test authorization rules and permissions\n   - Validate rate limiting functionality\n   - Test request throttling behavior\n\n3. HTTP Method Coverage:\n   - Test all CRUD operations: GET, POST, PUT, PATCH, DELETE\n   - Verify correct HTTP status codes (200, 201, 204, 400, 401, 403, 404, etc.)\n   - Include both successful and error scenarios\n   - Test request payload validation\n\n4. Response Validation:\n   - Verify response structure and data types\n   - Check serializer field validation\n   - Test pagination if implemented\n   - Validate filtering and sorting functionality\n\n5. Documentation Requirements:\n   - Include docstrings describing test purpose\n   - Document test data and fixtures\n   - Add comments for complex test scenarios\n\n6. Edge Cases:\n   - Test boundary conditions\n   - Include negative testing scenarios\n   - Verify error message formats\n\nReference Django REST framework testing documentation for best practices:\nhttps://www.django-rest-framework.org/api-guide/testing/\n</code></pre>"},{"location":"core_endpoints/","title":"Core App","text":"<p>This section details the functionalities and API endpoints provided by the Core application (<code>apps/core/</code>). The Core app serves as a foundation for common utilities, middleware, and base tasks within the Django Starter Template.</p>"},{"location":"core_endpoints/#functionalities","title":"Functionalities","text":"<p>The <code>apps/core</code> directory contains:</p> <ul> <li>Middleware: Custom middleware, such as <code>RequestIDMiddleware</code>, for adding request-specific information (e.g., request ID, client IP, response time) to logs and responses.</li> <li>Tasks: Base Celery task classes, like <code>BaseTaskWithRetry</code>, which provide common functionalities such as automatic retries for background tasks.</li> <li>Schema: Common OpenAPI schema definitions and examples used across different API endpoints.</li> <li>Management Commands: Custom Django management commands (e.g., <code>seed</code> command for populating the database with sample data).</li> </ul>"},{"location":"core_endpoints/#endpoints","title":"Endpoints","text":"<p>These endpoints are prefixed with <code>/core/</code>.</p>"},{"location":"core_endpoints/#ping","title":"Ping","text":"<p>GET /core/ping/</p> <p>A simple endpoint to check if the server is running.</p> <p>Success Response (200 OK):</p> <pre><code>{\n    \"ping\": \"pong\"\n}\n</code></pre>"},{"location":"core_endpoints/#fire-task","title":"Fire Task","text":"<p>GET /core/fire-task/</p> <p>Triggers a sample Celery task.</p> <p>Success Response (200 OK):</p> <pre><code>{\n    \"task\": \"Task fired\"\n}\n</code></pre>"},{"location":"database_seeding/","title":"Database Seeding","text":"<p>Database seeding is the process of populating a database with initial data. This is particularly useful during development and testing phases to ensure your application has realistic data to work with, without having to manually create it.</p>"},{"location":"database_seeding/#why-use-database-seeding","title":"Why Use Database Seeding?","text":"<ul> <li>Development: Provides a quick way to set up a development environment with sample data, allowing developers to immediately start working on features without worrying about data entry.</li> <li>Testing: Ensures that your tests run against a consistent and representative dataset, making your tests more reliable and reproducible.</li> <li>Demonstrations: Useful for populating a database for demonstrations or presentations of your application.</li> </ul>"},{"location":"database_seeding/#the-seed-management-command","title":"The <code>seed</code> Management Command","text":"<p>This project includes a powerful custom Django management command, <code>seed</code>, located at <code>apps/core/management/commands/seed.py</code>. This command allows you to easily populate your database with sample user data.</p>"},{"location":"database_seeding/#usage","title":"Usage","text":"<p>To use the <code>seed</code> command, you typically run it via <code>python manage.py seed</code> or <code>poetry run seed</code>.</p> <pre><code>python manage.py seed [options]\n</code></pre>"},{"location":"database_seeding/#available-options","title":"Available Options","text":"<p>The <code>seed</code> command supports the following arguments:</p> <ul> <li> <p><code>--users &lt;count&gt;</code>: Specifies the number of fake users to create. If not provided, it defaults to 10 users.</p> <ul> <li>Example: <code>python manage.py seed --users 50</code> (Creates 50 fake users)</li> </ul> </li> <li> <p><code>--superuser</code>: A flag that, when present, creates a superuser with predefined credentials (<code>admin@admin.com</code> / <code>admin</code>).</p> <ul> <li>Example: <code>python manage.py seed --superuser</code> (Creates an admin user)</li> </ul> </li> <li> <p><code>--clean</code>: A flag that, when present, deletes all existing non-superuser user data from the database before seeding. This is useful for starting with a fresh dataset.</p> <ul> <li>Example: <code>python manage.py seed --clean</code> (Deletes existing data before seeding)</li> </ul> </li> </ul>"},{"location":"database_seeding/#combined-examples","title":"Combined Examples","text":"<p>You can combine these options to achieve specific seeding scenarios:</p> <ul> <li> <p>Basic seeding with default options (creates 10 users):</p> <pre><code>python manage.py seed\n</code></pre> </li> <li> <p>Create specific number of users and a superuser:</p> <pre><code>python manage.py seed --users 20 --superuser\n</code></pre> </li> <li> <p>Clean existing data, create 50 users, and a superuser:</p> <pre><code>python manage.py seed --users 50 --superuser --clean\n</code></pre> </li> </ul>"},{"location":"database_seeding/#implementation-details","title":"Implementation Details","text":"<p>The <code>seed</code> command uses the <code>Faker</code> library to generate realistic-looking fake data for user profiles. It also utilizes Django's <code>transaction.atomic</code> decorator to ensure that the seeding process is atomic; if any part of the seeding fails, the entire operation is rolled back, preventing partial data corruption.</p>"},{"location":"dependencies/","title":"Project Dependencies","text":"<p>This project uses Poetry to manage its dependencies. The main dependencies are listed in the <code>[tool.poetry.dependencies]</code> section of the <code>pyproject.toml</code> file, while development dependencies are in the <code>[tool.poetry.group.dev.dependencies]</code> section.</p>"},{"location":"dependencies/#main-dependencies","title":"Main Dependencies","text":"<ul> <li>python: ^3.13</li> <li>django: ^5.1.2</li> <li>django-environ: ^0.12.0</li> <li>django-cors-headers: ^4.5.0</li> <li>djangorestframework: ^3.15.2</li> <li>psycopg2: ^2.9.10</li> <li>whitenoise: ^6.7.0</li> <li>gunicorn: ^23.0.0</li> <li>django-rest-knox: ^5.0.2</li> <li>redis: ^6.0.0</li> <li>celery: ^5.4.0</li> <li>django-celery-beat: ^2.7.0</li> <li>django-celery-results: ^2.5.1</li> <li>sentry-sdk: ^2.17.0 (with <code>django</code> extra)</li> <li>django-redis: ^6.0.0</li> <li>drf-spectacular: ^0.28.0</li> <li>faker: ^37.1.0</li> <li>django-seed: ^0.3.1</li> <li>django-extensions: ^4.1</li> <li>django-filter: ^25.1</li> <li>python-json-logger: ^3.3.0</li> </ul>"},{"location":"dependencies/#development-dependencies","title":"Development Dependencies","text":"<ul> <li>django-debug-toolbar: ^5.0.0</li> <li>pytest: ^8.3.3</li> <li>pytest-django: ^4.9.0</li> <li>ipykernel: ^6.29.5</li> <li>pytest-mock: ^3.14.0</li> <li>pytest-cov: ^6.0.0</li> <li>mkdocs: ^1.6.0</li> <li>mkdocs-material: ^9.5.26</li> </ul>"},{"location":"development/","title":"Development Workflow","text":"<p>This guide covers the essential commands and practices for developing your application after you have completed the initial setup using the Dev Container.</p>"},{"location":"development/#core-development-commands","title":"Core Development Commands","text":"<p>The project includes convenient scripts in <code>pyproject.toml</code> to simplify common development tasks. You should use these <code>poetry run</code> commands from the terminal inside your VS Code dev container.</p> Command Description <code>poetry run server</code> Starts the Django development server. <code>poetry run makemigrations</code> Creates new database migrations based on model changes. <code>poetry run migrate</code> Applies pending database migrations. <code>poetry run test</code> Runs the test suite using <code>pytest</code>. <code>poetry run test-cov</code> Runs the test suite and generates a coverage report."},{"location":"development/#testing","title":"Testing","text":"<p>The project uses <code>pytest</code> for testing.</p> <ul> <li>Run all tests: <pre><code>poetry run pytest\n</code></pre></li> <li>Run tests with coverage: <pre><code>poetry run pytest --cov\n</code></pre></li> <li>Generate an HTML coverage report: <pre><code>poetry run pytest --cov --cov-report=html\n</code></pre>   The report will be generated in the <code>htmlcov/</code> directory.</li> </ul>"},{"location":"development/#database-seeding","title":"Database Seeding","text":"<p>The template includes a powerful seeding command to populate your database with sample data for development and testing.</p> <pre><code># Basic seeding with default options (creates 10 users)\npoetry run seed\n\n# Create a specific number of users\npoetry run seed --users 20\n\n# Create a superuser (admin@admin.com:admin)\npoetry run seed --superuser\n\n# Clean existing data before seeding\npoetry run seed --clean\n\n# Combine options\npoetry run seed --users 50 --superuser --clean\n</code></pre>"},{"location":"development/#asynchronous-tasks-celery","title":"Asynchronous Tasks (Celery)","text":"<p>For handling background tasks, the project uses Celery.</p> <ul> <li>Start the Celery worker: <pre><code>poetry run worker\n</code></pre></li> <li>Start the Celery beat scheduler (for periodic tasks): <pre><code>poetry run beat\n</code></pre></li> </ul>"},{"location":"development/#environment-variables","title":"Environment Variables","text":"<ul> <li>The project uses a <code>.env</code> file to manage environment variables.</li> <li>The <code>poetry run create_dev_env</code> command can be used to generate a new development <code>.env</code> file if needed.</li> <li>For production, refer to <code>.env.example</code> for the full list of required variables.</li> </ul>"},{"location":"environment_setup/","title":"Environment Setup","text":"<p>This section explains how environment variables are used in the Django Starter Template and how to configure your project for both development and production environments.</p>"},{"location":"environment_setup/#environment-variables","title":"Environment Variables","text":"<p>Environment variables are a crucial part of modern application development, allowing you to configure your application's behavior without modifying the codebase. This is especially important for sensitive information (like API keys, database credentials) and for settings that vary between development, testing, and production environments.</p> <p>This project uses the <code>django-environ</code> library to manage environment variables. It reads variables from a <code>.env</code> file located in the project's root directory.</p>"},{"location":"environment_setup/#envexample","title":"<code>.env.example</code>","text":"<p>The <code>.env.example</code> file serves as a template for your <code>.env</code> file. It lists all the environment variables that your project expects, along with example values and comments explaining their purpose. Never commit your actual <code>.env</code> file to version control.</p> <pre><code># --------------------------------------------------------------------------------\n# \u26a1 Basic Config: for development and testing.\n# --------------------------------------------------------------------------------\nDEBUG=True\nDATABASE_URL=postgres://postgres:postgres@localhost:5432/postgres\nDJANGO_SECRET_KEY=django-insecure-wlgjuo53y49%-4y5(!%ksylle_ud%b=7%__@9hh+@$d%_^y3s!\n\n\n# --------------------------------------------------------------------------------\n# \ud83d\udce7 Email Config: optional and can be copied if needed.\n# --------------------------------------------------------------------------------\nEMAIL_HOST=smtp.gmail.com\nEMAIL_USE_TLS=True\nEMAIL_PORT=587\nEMAIL_HOST_USER=user@user.com\nEMAIL_HOST_PASSWORD=myverystrongpassword\n\n\n# --------------------------------------------------------------------------------\n# \ud83d\udd10 Security Config: for production or testing the production settings locally.\n# --------------------------------------------------------------------------------\nALLOWED_HOSTS=mysite.com,mysite2.com\nCORS_ALLOWED_ORIGINS=mysite.com,mysite2.com\nSENTRY_DSN=https://examplePublicKey@o0.ingest.sentry.io/0\n</code></pre> <p>To set up your environment, copy <code>.env.example</code> to <code>.env</code> and fill in the appropriate values:</p> <pre><code>cp .env.example .env\n</code></pre>"},{"location":"environment_setup/#development-environment","title":"Development Environment","text":"<p>For local development, the following environment variables are typically set:</p> <ul> <li><code>DEBUG=True</code>: Enables Django's debug mode, providing detailed error pages and auto-reloading.</li> <li><code>DATABASE_URL</code>: Specifies the connection string for your local database (e.g., PostgreSQL running in Docker).</li> <li><code>DJANGO_SECRET_KEY</code>: A secret key for development purposes. You can use the example one provided in <code>.env.example</code>.</li> </ul> <p>When using the Dev Container setup (recommended), the <code>.env</code> file is automatically created and configured for a development environment.</p>"},{"location":"environment_setup/#production-environment","title":"Production Environment","text":"<p>For production deployments, it is critical to configure your environment variables securely and appropriately:</p> <ul> <li><code>DEBUG=False</code>: Always set to <code>False</code> in production. This disables debug mode, preventing sensitive information from being exposed in error pages.</li> <li><code>DJANGO_SECRET_KEY</code>: Generate a strong, unique secret key and store it securely. Never use the development secret key in production.</li> <li><code>ALLOWED_HOSTS</code>: A comma-separated list of domain names that your Django application will serve. Do not use <code>*</code> in production.</li> <li><code>DATABASE_URL</code>: The connection string for your production database.</li> <li><code>CORS_ALLOWED_ORIGINS</code>: A comma-separated list of origins that are allowed to make cross-origin requests to your API. Do not use <code>CORS_ALLOW_ALL_ORIGINS=True</code> in production.</li> <li><code>SENTRY_DSN</code>: Your Sentry Data Source Name (DSN) for error tracking and performance monitoring.</li> <li><code>EMAIL_HOST</code>, <code>EMAIL_USE_TLS</code>, <code>EMAIL_PORT</code>, <code>EMAIL_HOST_USER</code>, <code>EMAIL_HOST_PASSWORD</code>: Configure these for sending emails from your production environment.</li> </ul>"},{"location":"environment_setup/#example-production-env-conceptual","title":"Example Production <code>.env</code> (Conceptual)","text":"<pre><code>DEBUG=False\nDJANGO_SECRET_KEY=your_very_long_and_secure_production_secret_key\nALLOWED_HOSTS=api.yourdomain.com,www.yourdomain.com\nDATABASE_URL=postgres://user:password@db.yourdomain.com:5432/prod_db\nCORS_ALLOWED_ORIGINS=https://www.yourdomain.com,https://app.yourdomain.com\nSENTRY_DSN=https://your_sentry_public_key@o0.ingest.sentry.io/0\nEMAIL_HOST=smtp.sendgrid.net\nEMAIL_USE_TLS=True\nEMAIL_PORT=587\nEMAIL_HOST_USER=apikey\nEMAIL_HOST_PASSWORD=your_sendgrid_api_key\n</code></pre>"},{"location":"environment_setup/#managing-environment-variables","title":"Managing Environment Variables","text":"<p>It is recommended to use a tool or service provided by your deployment platform (e.g., Docker Compose, Kubernetes, Heroku, AWS Elastic Beanstalk) to manage and inject environment variables into your production environment. This ensures that sensitive information is not hardcoded or exposed in your codebase.</p>"},{"location":"logging/","title":"Logging System","text":"<p>This section details the logging system implemented in the Django Starter Template, covering its configuration, features, and how to interpret the generated logs.</p>"},{"location":"logging/#overview","title":"Overview","text":"<p>The template utilizes a centralized logging system configured within <code>conf/settings.py</code>. It's designed to provide comprehensive and structured logs, making it easier to monitor, debug, and analyze application behavior, especially in production environments.</p>"},{"location":"logging/#key-features","title":"Key Features","text":"<ul> <li>JSON Format: All logs are formatted as JSON, enabling easy parsing and integration with log management tools.</li> <li>Multiple Handlers: Different types of logs are directed to specific handlers and files:<ul> <li><code>console</code>: Outputs logs to the console, primarily used during development.</li> <li><code>app.log</code>: General application logs.</li> <li><code>security.log</code>: Specifically captures authentication events and security-related messages.</li> <li><code>error.log</code>: Records all error-level messages.</li> <li><code>info.log</code>: Records all info-level messages.</li> </ul> </li> <li>Rotating Files: To prevent log files from growing indefinitely, they are configured to rotate. Each log file has a maximum size of 10MB, and up to 5 backup files are kept.</li> <li>Request Tracing: A custom middleware (<code>apps.core.middleware.RequestIDMiddleware</code>) assigns a unique <code>request_id</code> to each incoming request. This ID, along with other request-specific details (client IP, request path, authenticated user ID, response time, and HTTP status code), is automatically injected into every log record. This allows for end-to-end tracing of requests.</li> <li>Sentry Integration: In production environments, Sentry is integrated for advanced error tracking and performance monitoring.</li> </ul>"},{"location":"logging/#log-file-locations","title":"Log File Locations","text":"<p>All log files are stored in the <code>logs/</code> directory at the root of the project:</p> <ul> <li><code>logs/app.log</code>: General application logs.</li> <li><code>logs/security.log</code>: Authentication and security events.</li> <li><code>logs/error.log</code>: Error-level logs.</li> <li><code>logs/info.log</code>: Info-level logs.</li> </ul>"},{"location":"logging/#example-log-entry","title":"Example Log Entry","text":"<p>Log entries are in JSON format, providing rich context for each event. Here's an example:</p> <pre><code>{\n    \"asctime\": \"2025-05-04 14:17:22,365\",\n    \"levelname\": \"INFO\",\n    \"module\": \"views\",\n    \"process\": 5929,\n    \"thread\": 281473186128320,\n    \"message\": \"Ping request received\",\n    \"client\": \"127.0.0.1\",\n    \"request_id\": \"0d7344bd-0e6f-426d-aeed-46b9d1ca36bc\",\n    \"path\": \"/core/ping/\",\n    \"user_id\": 1,\n    \"status_code\": 401,\n    \"response_time\": 0.0019102096557617188\n}\n</code></pre> <p>Each field in the JSON provides specific information:</p> <ul> <li><code>asctime</code>: Timestamp of the log entry.</li> <li><code>levelname</code>: The logging level (e.g., INFO, WARNING, ERROR).</li> <li><code>module</code>: The Python module where the log originated.</li> <li><code>process</code>: The process ID.</li> <li><code>thread</code>: The thread ID.</li> <li><code>message</code>: The actual log message.</li> <li><code>client</code>: The IP address of the client making the request.</li> <li><code>request_id</code>: A unique identifier for the request, useful for tracing.</li> <li><code>path</code>: The URL path of the request.</li> <li><code>user_id</code>: The ID of the authenticated user (or \"anonymous\" if not authenticated).</li> <li><code>status_code</code>: The HTTP status code of the response.</li> <li><code>response_time</code>: The time taken to process the request in seconds.</li> </ul>"},{"location":"project_structure/","title":"Project Structure","text":"<p>Understanding the project's directory structure is key to navigating and contributing to the Django Starter Template. This document provides a detailed overview of the main directories and files, explaining their purpose and contents.</p> <pre><code>\u251c\u2500\u2500 .clinerules/                # Gemini CLI rules\n\u251c\u2500\u2500 .coveragerc                 # Coverage.py configuration\n\u251c\u2500\u2500 .devcontainer/              # Dev container configuration\n\u251c\u2500\u2500 .env.example                # Example environment variables file\n\u251c\u2500\u2500 .flake8                     # Flake8 linter configuration\n\u251c\u2500\u2500 .github/                    # GitHub CI/CD workflows and issue templates\n\u251c\u2500\u2500 .gitignore                  # Git ignore file\n\u251c\u2500\u2500 .pytest_cache/              # Pytest cache\n\u251c\u2500\u2500 .venv/                      # Virtual environment\n\u251c\u2500\u2500 .vscode/                    # VS Code settings and recommended extensions\n\u251c\u2500\u2500 apps/                       # Django applications (core logic)\n\u2502   \u251c\u2500\u2500 core/                   # Core functionalities and shared components\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py         # Initializes the core app\n\u2502   \u2502   \u251c\u2500\u2500 admin.py            # Django admin configuration for core app\n\u2502   \u2502   \u251c\u2500\u2500 apps.py             # App configuration for core app\n\u2502   \u2502   \u251c\u2500\u2500 management/         # Custom Django management commands\n\u2502   \u2502   \u251c\u2500\u2500 middleware.py       # Custom middleware for core app\n\u2502   \u2502   \u251c\u2500\u2500 migrations/         # Database migrations for core app\n\u2502   \u2502   \u251c\u2500\u2500 schema.py           # OpenAPI schema definitions for core app\n\u2502   \u2502   \u251c\u2500\u2500 tasks.py            # Celery task definitions for core app\n\u2502   \u2502   \u251c\u2500\u2500 tests/              # Unit and integration tests for core app\n\u2502   \u2502   \u2514\u2500\u2500 urls.py             # URL routing for core app\n\u2502   \u2514\u2500\u2500 users/                  # User management and authentication app\n\u2502       \u251c\u2500\u2500 __init__.py         # Initializes the users app\n\u2502       \u251c\u2500\u2500 admin.py            # Django admin configuration for users app\n\u2502       \u251c\u2500\u2500 apps.py             # App configuration for users app\n\u2502       \u251c\u2500\u2500 forms.py            # Custom forms for users app\n\u2502       \u251c\u2500\u2500 managers.py         # Custom managers for user models\n\u2502       \u251c\u2500\u2500 migrations/         # Database migrations for users app\n\u2502       \u251c\u2500\u2500 models.py           # User model definition\n\u2502       \u251c\u2500\u2500 schema.py           # OpenAPI schema definitions for users app\n\u2502       \u251c\u2500\u2500 serializers.py      # Serializers for users app\n\u2502       \u251c\u2500\u2500 tests/              # Unit and integration tests for users app\n\u2502       \u251c\u2500\u2500 throttles.py        # Rate limiting configurations for user-related views\n\u2502       \u251c\u2500\u2500 urls.py             # URL routing for users app\n\u2502       \u251c\u2500\u2500 utils.py            # Utility functions for users app\n\u2502       \u2514\u2500\u2500 views.py            # API views for user authentication and profile management\n\u251c\u2500\u2500 conf/                       # Project-wide configuration\n\u2502   \u251c\u2500\u2500 __init__.py             # Initializes the conf module\n\u2502   \u251c\u2500\u2500 asgi.py                 # ASGI application entry point\n\u2502   \u251c\u2500\u2500 celery.py               # Celery application configuration\n\u2502   \u251c\u2500\u2500 settings.py             # Main Django settings file\n\u2502   \u251c\u2500\u2500 test_settings.py        # Settings specifically for running tests\n\u2502   \u251c\u2500\u2500 test_utils.py           # Test utilities\n\u2502   \u251c\u2500\u2500 urls.py                 # Main URL routing for the project\n\u2502   \u2514\u2500\u2500 wsgi.py                 # WSGI application entry point\n\u251c\u2500\u2500 docs/                       # Documentation files\n\u251c\u2500\u2500 logs/                       # Application log files\n\u251c\u2500\u2500 manage.py                   # Django's command-line utility\n\u251c\u2500\u2500 mkdocs.yml                  # MkDocs configuration\n\u251c\u2500\u2500 notebook.ipynb              # Jupyter Notebook for interactive development\n\u251c\u2500\u2500 poetry.lock                 # Poetry lock file\n\u251c\u2500\u2500 pyproject.toml              # Project dependencies and metadata (Poetry)\n\u251c\u2500\u2500 pytest.ini                  # Pytest configuration\n\u251c\u2500\u2500 README.md                   # Project README file\n\u251c\u2500\u2500 renovate.json               # Renovate Bot configuration for dependency updates\n\u251c\u2500\u2500 scripts/                    # Utility scripts for various development tasks\n\u251c\u2500\u2500 static/                     # Static files (CSS, JavaScript, images)\n\u2514\u2500\u2500 templates/                  # Project-wide HTML templates\n</code></pre>"},{"location":"project_structure/#key-directories-and-their-purpose","title":"Key Directories and Their Purpose","text":"<ul> <li> <p><code>.devcontainer/</code>: Contains configuration files for Visual Studio Code Dev Containers. This ensures a consistent and reproducible development environment across different machines.</p> </li> <li> <p><code>.github/</code>: Stores GitHub-specific files, including GitHub Actions workflows for Continuous Integration (CI), issue templates, and other repository settings.</p> </li> <li> <p><code>.vscode/</code>: Holds Visual Studio Code workspace settings and recommended extensions for the project, enhancing the development experience.</p> </li> <li> <p><code>apps/</code>: This is the core of your Django project, where individual Django applications reside. Each app is a self-contained module responsible for a specific feature or set of features.</p> <ul> <li><code>core/</code>: Houses fundamental functionalities and shared components that are used across different parts of the application. This includes custom management commands, base Celery tasks, and common API schema definitions.</li> <li><code>users/</code>: Manages all aspects of user authentication and authorization, including user models, serializers, views, and related utilities.</li> </ul> </li> <li> <p><code>conf/</code>: Contains project-wide configuration files that apply to the entire Django project, rather than a specific app. This includes the main <code>settings.py</code>, URL routing, WSGI configuration, and Celery setup.</p> </li> <li> <p><code>logs/</code>: The designated directory for application log files. Different log levels and types (e.g., general, security, error) are typically written to separate files within this directory.</p> </li> <li> <p><code>scripts/</code>: A collection of utility scripts that automate various development and maintenance tasks, such as running the server, migrations, or custom commands.</p> </li> <li> <p><code>static/</code>: Stores static assets like CSS, JavaScript, and images that are served directly by the web server.</p> </li> <li> <p><code>templates/</code>: Contains project-wide HTML templates that are not specific to any single Django application.</p> </li> </ul>"},{"location":"project_structure/#key-files-and-their-purpose","title":"Key Files and Their Purpose","text":"<ul> <li> <p><code>.env.example</code>: A template file that outlines all the environment variables required by the project. Developers should copy this to <code>.env</code> and fill in their specific values.</p> </li> <li> <p><code>manage.py</code>: Django's command-line utility for administrative tasks. You'll use this for running the development server, migrations, and custom management commands.</p> </li> <li> <p><code>pyproject.toml</code>: Used by Poetry (the dependency management tool) to define project metadata, dependencies, and build configurations.</p> </li> <li> <p><code>pytest.ini</code>: Configuration file for <code>pytest</code>, specifying how tests should be discovered and run, including settings for code coverage.</p> </li> <li> <p><code>README.md</code>: The main project documentation, providing a high-level overview, quick start instructions, and key features.</p> </li> </ul> <p>By adhering to this structured layout, the project promotes modularity, maintainability, and scalability, making it easier for developers to understand and contribute to the codebase.</p>"},{"location":"rate_limiting/","title":"Rate Limiting","text":"<p>Rate limiting is a crucial security and performance feature that controls the number of requests a user or IP address can make to your API within a given timeframe. It helps prevent abuse, brute-force attacks, and ensures fair usage of your API resources.</p>"},{"location":"rate_limiting/#why-use-rate-limiting","title":"Why Use Rate Limiting?","text":"<ul> <li>Security: Protects against brute-force attacks on login endpoints, denial-of-service (DoS) attacks, and excessive data scraping.</li> <li>Performance: Prevents a single user or malicious actor from overwhelming your server with too many requests, ensuring the API remains responsive for all legitimate users.</li> <li>Fair Usage: Ensures that API resources are distributed fairly among all users, preventing any single user from monopolizing resources.</li> </ul>"},{"location":"rate_limiting/#how-its-implemented","title":"How it's Implemented","text":"<p>This project uses Django REST Framework's built-in throttling mechanisms, along with a custom throttle class, to implement rate limiting.</p>"},{"location":"rate_limiting/#1-default_throttle_rates-in-confsettingspy","title":"1. <code>DEFAULT_THROTTLE_RATES</code> in <code>conf/settings.py</code>","text":"<p>Global throttle rates are defined in <code>conf/settings.py</code> under the <code>REST_FRAMEWORK</code> dictionary. These rates are applied based on different scopes:</p> <pre><code># Example from conf/settings.py\nREST_FRAMEWORK = {\n    # ... other settings\n    \"DEFAULT_THROTTLE_RATES\": {\n        \"user\": \"1000/day\",\n        \"anon\": \"100/day\",\n        \"user_login\": \"5/minute\",\n    },\n}\n</code></pre> <ul> <li><code>user</code>: Applies to authenticated users. Default: <code>1000 requests per day</code>.</li> <li><code>anon</code>: Applies to unauthenticated (anonymous) users. Default: <code>100 requests per day</code>.</li> <li><code>user_login</code>: A custom scope specifically for login attempts. Default: <code>5 requests per minute</code>.</li> </ul>"},{"location":"rate_limiting/#2-custom-throttle-class-userloginratethrottle","title":"2. Custom Throttle Class (<code>UserLoginRateThrottle</code>)","text":"<p>For specific scenarios, like limiting login attempts, a custom throttle class (<code>apps/users/throttles.py</code>) is used. This allows for more granular control over how requests are identified and limited.</p> <pre><code># Example from apps/users/throttles.py\nfrom rest_framework.throttling import SimpleRateThrottle\n\nclass UserLoginRateThrottle(SimpleRateThrottle):\n    scope = \"user_login\"\n\n    def get_cache_key(self, request, view):\n        if not request.user.is_authenticated:\n            ident = self.get_ident(request) # Uses IP for anonymous users\n        else:\n            ident = request.user.pk # Uses user ID for authenticated users\n\n        return self.cache_format % {\"scope\": self.scope, \"ident\": ident}\n</code></pre> <p>This custom throttle ensures that:</p> <ul> <li>For anonymous users, rate limiting is based on their IP address.</li> <li>For authenticated users, rate limiting is based on their user ID.</li> </ul>"},{"location":"rate_limiting/#3-applying-throttles-to-views","title":"3. Applying Throttles to Views","text":"<p>Throttles are applied to DRF views using the <code>throttle_classes</code> attribute. This tells DRF which throttle policies to enforce for that specific view.</p> <p>Example (from <code>apps/users/views.py</code> for <code>LoginView</code> and <code>UserProfileView</code>):</p> <pre><code># For LoginView\nfrom rest_framework.throttling import AnonRateThrottle # Or other built-in throttles\nfrom .throttles import UserLoginRateThrottle\n\nclass LoginView(KnoxLoginView):\n    # ...\n    throttle_classes = [UserLoginRateThrottle]\n\n# For UserProfileView and CreateUserView\nfrom rest_framework import throttling\n\nclass UserProfileView(generics.RetrieveUpdateAPIView):\n    # ...\n    throttle_classes = [throttling.UserRateThrottle]\n\nclass CreateUserView(generics.CreateAPIView):\n    # ...\n    throttle_classes = [throttling.UserRateThrottle]\n</code></pre> <ul> <li><code>UserLoginRateThrottle</code>: Applied to the <code>LoginView</code> to limit login attempts.</li> <li><code>throttling.UserRateThrottle</code>: A built-in DRF throttle that applies the <code>user</code> scope rate (from <code>DEFAULT_THROTTLE_RATES</code>) to authenticated users. This is used for <code>UserProfileView</code> and <code>CreateUserView</code>.</li> </ul>"},{"location":"rate_limiting/#how-to-configure","title":"How to Configure","text":"<p>To adjust the rate limits for your API, modify the <code>DEFAULT_THROTTLE_RATES</code> dictionary in <code>conf/settings.py</code>.</p> <p>For example, to change the anonymous user rate limit to 50 requests per hour:</p> <pre><code># In conf/settings.py\nREST_FRAMEWORK = {\n    # ...\n    \"DEFAULT_THROTTLE_RATES\": {\n        \"user\": \"1000/day\",\n        \"anon\": \"50/hour\", # Changed from 100/day\n        \"user_login\": \"5/minute\",\n    },\n}\n</code></pre> <p>You can also create new custom throttle classes in <code>apps/users/throttles.py</code> (or a similar location) and apply them to specific views as needed.</p>"},{"location":"settings/","title":"Project Settings","text":"<p>This document provides an extensive guide to the <code>conf/settings.py</code> file, which centralizes the configuration for the Django Starter Template. Understanding these settings is crucial for customizing and deploying your application.</p>"},{"location":"settings/#environment-variables-django-environ","title":"Environment Variables (<code>django-environ</code>)","text":"<p>The project uses <code>django-environ</code> to manage environment variables, allowing sensitive information and deployment-specific configurations to be kept out of version control. Variables are loaded from a <code>.env</code> file in the project root.</p> <pre><code>import environ\n\nenv = environ.Env()\nroot_path = environ.Path(__file__) - 2\nenv.read_env(str(root_path.path(\".env\")))\n</code></pre> <ul> <li><code>env = environ.Env()</code>: Initializes the environment reader.</li> <li><code>root_path</code>: Defines the base directory for relative paths, calculated as two levels up from the <code>settings.py</code> file.</li> <li><code>env.read_env()</code>: Reads variables from the <code>.env</code> file. This function is called without arguments, so it looks for <code>.env</code> in the current working directory or parent directories.</li> </ul>"},{"location":"settings/#basic-configuration","title":"Basic Configuration","text":"<p>These are fundamental Django settings.</p> <ul> <li><code>ROOT_URLCONF</code>: Specifies the root URL configuration module. Default: <code>conf.urls</code>. This tells Django where to find the main URL patterns for your project.</li> <li><code>WSGI_APPLICATION</code>: The full Python path to the WSGI application object. Default: <code>conf.wsgi.application</code>. This is the entry point for WSGI-compatible web servers.</li> <li><code>DEBUG</code>: A boolean that turns debug mode on or off. Default: <code>False</code> (loaded from <code>env.bool(\"DEBUG\", default=False)</code>). When <code>True</code>, Django provides detailed error pages, reloads code on changes, and enables other development-specific features. Must be <code>False</code> in production for security and performance reasons.</li> </ul>"},{"location":"settings/#time-language","title":"Time &amp; Language","text":"<p>Standard settings for localization and time zones.</p> <ul> <li><code>LANGUAGE_CODE</code>: The language code for this installation. Default: <code>en-us</code>. This affects the default language for Django's built-in messages and templates.</li> <li><code>TIME_ZONE</code>: The time zone for this installation. Default: <code>UTC</code>. This is the time zone that Django will use for all datetime objects unless a specific timezone is activated.</li> <li><code>USE_I18N</code>: A boolean that specifies whether Django's internationalization system should be enabled. Default: <code>True</code>. When <code>True</code>, Django will look for translation files.</li> <li><code>USE_TZ</code>: A boolean that specifies whether Django's timezone support should be enabled. Default: <code>True</code>. When <code>True</code>, Django stores datetimes in UTC in the database and converts them to the user's local time zone for display.</li> </ul>"},{"location":"settings/#security-and-users","title":"Security and Users","text":"<p>This section covers critical security configurations and user model settings.</p> <ul> <li> <p><code>SECRET_KEY</code>: A secret key for a particular Django installation. Default: Loaded from the <code>DJANGO_SECRET_KEY</code> environment variable. This is used to provide cryptographic signing and should be a unique, unpredictable value. Must be kept secret and loaded from environment variables.</p> <pre><code>SECRET_KEY = env(\"DJANGO_SECRET_KEY\")\n</code></pre> </li> <li> <p><code>ALLOWED_HOSTS</code>: A list of strings representing the host/domain names that this Django site can serve. Default: <code>[\"*\"]</code> (loaded from <code>env.list(\"ALLOWED_HOSTS\", default=[\"*\"])</code>). This is a security measure to prevent HTTP Host header attacks. In production, specify your exact domain names (e.g., <code>[\"example.com\", \"www.example.com\"]</code>) and never use <code>\"*\"</code> for security.</p> <pre><code>ALLOWED_HOSTS = env.list(\"ALLOWED_HOSTS\", default=[\"*\"])\n</code></pre> </li> <li> <p><code>AUTH_USER_MODEL</code>: Specifies the custom user model to use. Default: <code>users.CustomUser</code>. This allows you to extend Django's default user model with custom fields and behaviors.</p> </li> <li><code>MIN_PASSWORD_LENGTH</code>: Minimum length for user passwords. Default: <code>8</code> (loaded from <code>env.int(\"MIN_PASSWORD_LENGTH\", default=8)</code>). This is used by the password validation system.</li> <li><code>PASSWORD_HASHERS</code>: A list of password hashing algorithms used for storing user passwords. Django will try them in order until one works. Default: A list including <code>ScryptPasswordHasher</code>, <code>PBKDF2PasswordHasher</code>, <code>PBKDF2SHA1PasswordHasher</code>, <code>Argon2PasswordHasher</code>, and <code>BCryptSHA256PasswordHasher</code>. This provides strong password security.</li> <li><code>AUTH_PASSWORD_VALIDATORS</code>: Configures password validation rules. Default: Includes validators for user attribute similarity, minimum length, common passwords, and numeric passwords. You can customize these to enforce stronger password policies.</li> </ul>"},{"location":"settings/#security-headers","title":"Security Headers","text":"<ul> <li><code>SECURE_BROWSER_XSS_FILTER</code>: A boolean that enables the X-XSS-Protection header. Default: <code>True</code>. This helps protect against Cross-Site Scripting (XSS) attacks.</li> <li><code>SECURE_CONTENT_TYPE_NOSNIFF</code>: A boolean that enables the X-Content-Type-Options header. Default: <code>True</code>. This prevents browsers from MIME-sniffing a response away from the declared content-type.</li> <li><code>X_FRAME_OPTIONS</code>: Prevents clickjacking by setting the X-Frame-Options header. Default: <code>DENY</code>. This means the page cannot be displayed in a frame.</li> <li><code>CSRF_COOKIE_SECURE</code>: A boolean that determines whether the CSRF cookie should be sent only over HTTPS. Default: <code>True</code> if <code>DEBUG</code> is <code>False</code>, <code>False</code> otherwise. Should be <code>True</code> in production.</li> <li><code>SESSION_COOKIE_SECURE</code>: A boolean that determines whether the session cookie should be sent only over HTTPS. Default: <code>True</code> if <code>DEBUG</code> is <code>False</code>, <code>False</code> otherwise. Should be <code>True</code> in production.</li> </ul>"},{"location":"settings/#databases","title":"Databases","text":"<p>Database connection settings are configured via the <code>DATABASE_URL</code> environment variable.</p> <pre><code>DJANGO_DATABASE_URL = env.db(\"DATABASE_URL\")\nDATABASES = {\"default\": DJANGO_DATABASE_URL}\n</code></pre> <ul> <li><code>DJANGO_DATABASE_URL</code>: The database connection string, parsed by <code>django-environ</code>. Default: Loaded from the <code>DATABASE_URL</code> environment variable.</li> <li><code>DATABASES</code>: A dictionary containing the database configurations. The <code>default</code> key holds the primary database connection.</li> <li><code>DEFAULT_AUTO_FIELD</code>: The type of primary key to use for models that don't explicitly specify one. Default: <code>django.db.models.BigAutoField</code>. This uses a 64-bit integer, which is generally preferred over <code>AutoField</code> (32-bit) to avoid overflow issues in large applications.</li> </ul>"},{"location":"settings/#applications-configuration","title":"Applications Configuration","text":"<p>This section lists all installed Django applications and middleware.</p> <ul> <li> <p><code>INSTALLED_APPS</code>: A list of strings designating all applications that are enabled in this Django installation. Default: Includes Django's built-in apps (admin, auth, contenttypes, sessions, messages, staticfiles), third-party libraries (whitenoise, corsheaders, rest_framework, django_filters, knox, django_celery_beat, django_celery_results, drf_spectacular, django_extensions), and local project apps (apps.users, apps.core). This setting tells Django which applications are active in your project.</p> </li> <li> <p><code>MIDDLEWARE</code>: A list of middleware classes to use. Middleware components process requests and responses globally. Default: Includes security, static files, session, CORS, common, CSRF, authentication, custom <code>RequestIDMiddleware</code>, and messages middleware. The order of middleware is important as they are processed in the order they appear in this list.</p> </li> </ul>"},{"location":"settings/#templates","title":"Templates","text":"<p>Configuration for Django's template engine.</p> <ul> <li><code>BACKEND</code>: The template engine to use. Default: <code>django.template.backends.django.DjangoTemplates</code>.</li> <li><code>DIRS</code>: A list of directories where Django should look for template files. Default: <code>[root_path(\"templates\")]</code>. This allows you to place project-wide templates outside of specific app directories.</li> <li><code>APP_DIRS</code>: A boolean that tells Django to look for templates inside the <code>templates</code> subdirectory of installed applications. Default: <code>True</code>. This is a convenient way to organize app-specific templates.</li> <li><code>OPTIONS</code>: A dictionary of options for the template engine. Default: Includes <code>context_processors</code> (which add variables to the template context, such as <code>debug</code>, <code>request</code>, <code>auth</code>, <code>messages</code>) and <code>builtins</code> (which register built-in template tags and filters).</li> </ul>"},{"location":"settings/#rest-framework","title":"REST Framework","text":"<p>Settings for Django REST Framework (DRF) and related authentication/API schema tools.</p>"},{"location":"settings/#rest_knox","title":"<code>REST_KNOX</code>","text":"<p>Configuration for <code>django-rest-knox</code>, the token-based authentication system.</p> <ul> <li><code>SECURE_HASH_ALGORITHM</code>: The hashing algorithm used for tokens. Default: <code>hashlib.sha512</code>.</li> <li><code>AUTH_TOKEN_CHARACTER_LENGTH</code>: The length of the authentication token. Default: <code>64</code>.</li> <li><code>TOKEN_TTL</code>: Token time-to-live. Default: <code>timedelta(hours=10)</code>. This defines how long a token is valid.</li> <li><code>USER_SERIALIZER</code>: The serializer used for user profiles. Default: <code>apps.users.serializers.UserProfileSerializer</code>.</li> <li><code>TOKEN_LIMIT_PER_USER</code>: Limits the number of active tokens per user. Default: <code>None</code> (no limit).</li> <li><code>AUTO_REFRESH</code>: Whether tokens should be automatically refreshed. Default: <code>False</code>.</li> <li><code>AUTO_REFRESH_MAX_TTL</code>: Maximum time-to-live for auto-refreshed tokens. Default: <code>None</code>.</li> <li><code>MIN_REFRESH_INTERVAL</code>: Minimum interval between token refreshes. Default: <code>60</code> seconds.</li> <li><code>AUTH_HEADER_PREFIX</code>: The prefix for the Authorization header. Default: <code>Bearer</code>.</li> <li><code>TOKEN_MODEL</code>: The token model used. Default: <code>knox.AuthToken</code>.</li> </ul>"},{"location":"settings/#rest_framework","title":"<code>REST_FRAMEWORK</code>","text":"<p>General DRF settings.</p> <ul> <li><code>DEFAULT_AUTHENTICATION_CLASSES</code>: Defines authentication methods. Default: <code>knox.auth.TokenAuthentication</code>. In <code>DEBUG</code> mode, <code>SessionAuthentication</code> and <code>BasicAuthentication</code> are also added.</li> <li><code>DEFAULT_FILTER_BACKENDS</code>: Enables filtering, searching, and ordering capabilities. Default: <code>django_filters.rest_framework.DjangoFilterBackend</code>, <code>rest_framework.filters.SearchFilter</code>, <code>rest_framework.filters.OrderingFilter</code>.</li> <li><code>DEFAULT_RENDERER_CLASSES</code>: Specifies how API responses are rendered. Default: <code>rest_framework.renderers.JSONRenderer</code>. In <code>DEBUG</code> mode, <code>BrowsableAPIRenderer</code> is also added.</li> <li><code>DEFAULT_SCHEMA_CLASS</code>: Integrates <code>drf-spectacular</code> for OpenAPI schema generation. Default: <code>drf_spectacular.openapi.AutoSchema</code>.</li> <li><code>DEFAULT_THROTTLE_RATES</code>: Configures rate limiting for different user types. Default: <code>user: \"1000/day\"</code>, <code>anon: \"100/day\"</code>, <code>user_login: \"5/minute\"</code>. These can be adjusted based on your application's needs.</li> </ul>"},{"location":"settings/#spectacular_settings","title":"<code>SPECTACULAR_SETTINGS</code>","text":"<p>Settings for <code>drf-spectacular</code>, used for generating OpenAPI 3 documentation.</p> <ul> <li><code>TITLE</code>: The title of your API documentation. Default: <code>Django Starter Template</code>.</li> <li><code>DESCRIPTION</code>: A description of your API. Default: <code>A comprehensive starting point for your new API with Django and DRF</code>.</li> <li><code>VERSION</code>: The version of your API. Default: <code>0.1.0</code>.</li> <li><code>SERVE_INCLUDE_SCHEMA</code>: Whether to include the schema endpoint in the generated documentation. Default: <code>False</code>. Set to <code>True</code> if you want the raw OpenAPI schema to be accessible.</li> </ul>"},{"location":"settings/#cors-headers","title":"CORS Headers","text":"<ul> <li><code>CORS_ALLOW_ALL_ORIGINS</code>: A boolean that allows all origins for CORS requests in debug mode. Default: <code>True</code> if <code>DEBUG</code> is <code>True</code>, <code>False</code> otherwise. Should be <code>False</code> in production for security.</li> <li><code>CORS_ALLOWED_ORIGINS</code>: A list of allowed origins for CORS requests when <code>CORS_ALLOW_ALL_ORIGINS</code> is <code>False</code>. Default: Loaded from the <code>CORS_ALLOWED_ORIGINS</code> environment variable.</li> </ul>"},{"location":"settings/#cache","title":"Cache","text":"<p>Configuration for caching, using Redis.</p> <ul> <li><code>CACHES</code>: Defines cache backends. Default: A dictionary with a <code>default</code> cache using <code>django_redis.cache.RedisCache</code>.</li> <li><code>LOCATION</code>: The connection URL for the Redis server. Default: <code>redis://redis:6379</code> (loaded from <code>env(\"REDIS_URL\", default=\"redis://redis:6379\")</code>).</li> <li><code>OPTIONS</code>: Additional options for the Redis client. Default: <code>{\"CLIENT_CLASS\": \"django_redis.client.DefaultClient\"}</code>.</li> <li><code>USER_AGENTS_CACHE</code>: The cache alias to use for user agent caching. Default: <code>default</code>.</li> </ul>"},{"location":"settings/#celery","title":"Celery","text":"<p>Settings for Celery, the asynchronous task queue.</p> <ul> <li><code>CELERY_BROKER_URL</code>: The URL for the Celery message broker. Default: <code>redis://redis:6379</code> (loaded from <code>env(\"CELERY_BROKER_URL\", default=\"redis://redis:6379\")</code>).</li> <li><code>CELERY_RESULT_BACKEND</code>: Where Celery task results are stored. Default: <code>django-db</code> (loaded from <code>env(\"CELERY_RESULT_BACKEND\", default=\"django-db\")</code>).</li> <li><code>CELERY_BEAT_SCHEDULER</code>: Specifies the scheduler for periodic tasks. Default: <code>django_celery_beat.schedulers.DatabaseScheduler</code>. This enables managing periodic tasks via the Django admin.</li> <li><code>CELERY_ACCEPT_CONTENT</code>: A list of accepted content types for tasks. Default: <code>[\"application/json\"]</code>.</li> <li><code>CELERY_TASK_SERIALIZER</code>: The default serialization method for tasks. Default: <code>json</code>.</li> <li><code>CELERY_RESULT_SERIALIZER</code>: The default serialization method for task results. Default: <code>json</code>.</li> <li><code>CELERY_TIMEZONE</code>: The timezone for Celery. Default: <code>America/Santiago</code>.</li> <li><code>CELERY_RESULT_EXTENDED</code>: Whether to store extended result information. Default: <code>True</code>.</li> </ul>"},{"location":"settings/#email","title":"Email","text":"<p>Email backend settings for sending emails.</p> <ul> <li><code>EMAIL_HOST</code>: The hostname of the SMTP server. Default: <code>smtp.gmail.com</code> (loaded from <code>env(\"EMAIL_HOST\", default=\"smtp.gmail.com\")</code>).</li> <li><code>EMAIL_USE_TLS</code>: Whether to use TLS (Transport Layer Security) for the connection. Default: <code>True</code> (loaded from <code>env.bool(\"EMAIL_USE_TLS\", default=True)</code>).</li> <li><code>EMAIL_PORT</code>: The port number for the SMTP server. Default: <code>587</code> (loaded from <code>env.int(\"EMAIL_PORT\", default=587)</code>).</li> <li><code>EMAIL_HOST_USER</code>: The username for the SMTP server. Default: <code>\"\"</code> (loaded from <code>env(\"EMAIL_HOST_USER\", default=\"\")</code>).</li> <li><code>EMAIL_HOST_PASSWORD</code>: The password for the SMTP server. Default: <code>\"\"</code> (loaded from <code>env(\"EMAIL_HOST_PASSWORD\", default=\"\")</code>).</li> </ul>"},{"location":"settings/#sentry-and-logging","title":"Sentry and Logging","text":"<p>While logging has its own dedicated documentation page, this section briefly covers Sentry integration.</p> <ul> <li><code>IGNORABLE_404_URLS</code>: A list of regular expressions for URLs that should not trigger 404 errors in logging/error reporting. Default: Includes patterns for common favicon and Apple touch icon requests.</li> <li><code>LOGGING</code>: Detailed logging configuration (refer to the Logging System documentation for more).</li> <li><code>sentry_sdk.init()</code>: Initializes Sentry for error tracking and performance monitoring in production environments. Default: Initialized with <code>dsn</code>, <code>traces_sample_rate=1.0</code>, and <code>profiles_sample_rate=1.0</code> when <code>DEBUG</code> is <code>False</code>.</li> </ul>"},{"location":"settings/#static-media-files","title":"Static &amp; Media Files","text":"<p>Settings for serving static and user-uploaded media files.</p> <ul> <li><code>STORAGES</code>: Defines storage backends for default and static files. Default: <code>FileSystemStorage</code> for default and <code>whitenoise.storage.CompressedManifestStaticFilesStorage</code> for static files.</li> <li><code>STATIC_URL</code>: The URL to use when referring to static files located in <code>STATIC_ROOT</code>. Default: <code>/static/</code>.</li> <li><code>STATICFILES_DIRS</code>: A list of directories where Django will look for additional static files. Default: <code>[root_path(\"static\")]</code>.</li> <li><code>STATIC_ROOT</code>: The absolute path to the directory where <code>collectstatic</code> will gather all static files for deployment. Default: A temporary directory if <code>DEBUG</code> is <code>True</code>, otherwise <code>static_root</code> within the project root.</li> <li><code>MEDIA_URL</code>: The URL that handles the media served from <code>MEDIA_ROOT</code>. Default: <code>/media/</code>.</li> <li><code>MEDIA_ROOT</code>: The absolute path to the directory where user-uploaded media files are stored. Default: <code>media_root</code> within the project root.</li> <li><code>ADMIN_MEDIA_PREFIX</code>: The URL prefix for admin media files. Default: <code>/static/admin/</code>.</li> </ul>"},{"location":"settings/#django-debug-toolbar-and-django-extensions","title":"Django Debug Toolbar and Django Extensions","text":"<p>These tools are enabled only in <code>DEBUG</code> mode for development purposes.</p> <ul> <li><code>debug_toolbar</code>: Provides a customizable debug panel for Django projects. Default: Added to <code>INSTALLED_APPS</code> and <code>MIDDLEWARE</code> if <code>DEBUG</code> is <code>True</code>.</li> <li><code>INTERNAL_IPS</code>: A list of IP addresses that are considered \"internal\" for the Debug Toolbar. Default: <code>[\"127.0.0.1\"]</code>.</li> <li><code>django_extensions</code>: Offers a collection of custom extensions for Django, including useful management commands. Default: Added to <code>INSTALLED_APPS</code> if <code>DEBUG</code> is <code>True</code>.</li> </ul> <p>These settings are conditionally added to <code>INSTALLED_APPS</code> and <code>MIDDLEWARE</code> when <code>DEBUG</code> is <code>True</code>.</p>"},{"location":"tasks/","title":"Celery Tasks","text":"<p>This section provides a comprehensive guide to working with Celery tasks in the Django Starter Template, including how to create, configure, and manage them, with a focus on retry mechanisms and periodic tasks.</p>"},{"location":"tasks/#overview","title":"Overview","text":"<p>Celery is an asynchronous task queue/job queue based on distributed message passing. It's used in this project to offload long-running operations from the main request-response cycle, improving application responsiveness and scalability.</p>"},{"location":"tasks/#configuration","title":"Configuration","text":"<p>Celery is configured in <code>conf/celery.py</code>. It integrates with Django's settings, allowing you to manage Celery-related configurations within your Django project.</p> <p>Key settings are typically found in <code>conf/settings.py</code>:</p> <ul> <li><code>CELERY_BROKER_URL</code>: The URL for the message broker (e.g., Redis).</li> <li><code>CELERY_RESULT_BACKEND</code>: Where task results are stored (e.g., Django database).</li> <li><code>CELERY_BEAT_SCHEDULER</code>: Specifies the scheduler for periodic tasks.</li> </ul>"},{"location":"tasks/#creating-new-tasks","title":"Creating New Tasks","text":"<p>To create a new Celery task, use the <code>@shared_task</code> decorator from <code>celery</code>.</p> <pre><code>from celery import shared_task\n\n@shared_task\ndef my_new_task(arg1, arg2):\n    # Your task logic here\n    print(f\"Executing my_new_task with {arg1} and {arg2}\")\n</code></pre> <p>Place your task definitions in <code>tasks.py</code> files within your Django apps (e.g., <code>apps/core/tasks.py</code>). Celery is configured to automatically discover tasks in installed apps.</p>"},{"location":"tasks/#task-retries","title":"Task Retries","text":"<p>The template provides a custom base task class, <code>BaseTaskWithRetry</code>, located in <code>apps/core/tasks.py</code>, which simplifies implementing retry logic for your tasks.</p>"},{"location":"tasks/#basetaskwithretry-attributes","title":"<code>BaseTaskWithRetry</code> Attributes:","text":"<ul> <li><code>autoretry_for</code>: A tuple of exception types that should trigger a retry. If any of these exceptions occur during task execution, Celery will automatically retry the task.</li> <li><code>retry_kwargs</code>: A dictionary of keyword arguments passed to the <code>retry()</code> method. The most common is <code>max_retries</code>, which defines the maximum number of times the task will be retried.</li> <li><code>retry_backoff</code>: The initial delay in seconds before the first retry attempt. Subsequent retries will have an exponentially increasing delay.</li> <li><code>retry_jitter</code>: A boolean that, when <code>True</code>, adds a random component to the retry delay. This helps prevent all failed tasks from retrying simultaneously, which can lead to a \"thundering herd\" problem.</li> </ul>"},{"location":"tasks/#example-usage","title":"Example Usage:","text":"<p>To use <code>BaseTaskWithRetry</code> for your task, simply set its <code>base</code> argument in the <code>@shared_task</code> decorator:</p> <pre><code>from celery import shared_task\nfrom apps.core.tasks import BaseTaskWithRetry\n\n@shared_task(bind=True, base=BaseTaskWithRetry)\ndef my_retriable_task(self):\n    try:\n        # Your task logic that might fail\n        result = 1 / 0 # Example of an error\n        return result\n    except Exception as e:\n        # Log the error or perform any necessary cleanup before retrying\n        print(f\"Task failed: {e}. Retrying...\")\n        raise self.retry(exc=e)\n</code></pre>"},{"location":"tasks/#calling-tasks","title":"Calling Tasks","text":"<p>Tasks can be called in a few ways:</p> <ul> <li> <p>Asynchronously (recommended for most cases):</p> <pre><code>my_new_task.delay(arg1_value, arg2_value)\n</code></pre> </li> <li> <p>With more control (e.g., setting a countdown or ETA):</p> <pre><code>from datetime import datetime, timedelta\n\n# Execute in 10 seconds\nmy_new_task.apply_async((arg1_value, arg2_value), countdown=10)\n\n# Execute at a specific time\neta_time = datetime.now() + timedelta(minutes=5)\nmy_new_task.apply_async((arg1_value, arg2_value), eta=eta_time)\n</code></pre> </li> </ul>"},{"location":"tasks/#periodic-tasks-celery-beat","title":"Periodic Tasks (Celery Beat)","text":"<p>Celery Beat is a scheduler that kicks off tasks periodically. In this project, periodic tasks are managed through the Django Admin interface.</p>"},{"location":"tasks/#steps-to-configure-a-periodic-task","title":"Steps to Configure a Periodic Task:","text":"<ol> <li> <p>Start Celery Worker: Ensure your Celery worker is running:</p> <pre><code>poetry run worker\n</code></pre> </li> <li> <p>Start Celery Beat: Start the Celery Beat scheduler:</p> <pre><code>poetry run beat\n</code></pre> </li> <li> <p>Configure in Django Admin: Navigate to the Django Admin interface (<code>/admin-panel/</code>). Under the <code>DJANGO CELERY BEAT</code> section, you can add and manage <code>Periodic tasks</code>. You'll need to specify:</p> <ul> <li>The task name (e.g., <code>apps.core.tasks.my_periodic_task</code>).</li> <li>The schedule (e.g., every 5 minutes, daily, etc.).</li> <li>Any arguments or keyword arguments for the task.</li> </ul> </li> </ol>"},{"location":"tasks/#example-periodic-task","title":"Example Periodic Task:","text":"<pre><code>from celery import shared_task\n\n@shared_task\ndef my_periodic_task():\n    print(\"This task runs periodically!\")\n</code></pre>"},{"location":"testing/","title":"Testing","text":"<p>This project uses <code>pytest</code> as its primary testing framework, integrated with <code>pytest-django</code> for seamless Django testing and <code>pytest-cov</code> for code coverage analysis. This setup ensures a robust and efficient testing environment.</p>"},{"location":"testing/#testing-setup","title":"Testing Setup","text":""},{"location":"testing/#pytestini-configuration","title":"<code>pytest.ini</code> Configuration","text":"<p>The <code>pytest.ini</code> file in the project root configures <code>pytest</code> behavior:</p> <pre><code>[pytest]\nDJANGO_SETTINGS_MODULE = conf.test_settings\npython_files = tests.py test_*.py *_tests.py\n\naddopts = --reuse-db --nomigrations --cov=. --cov-report=html --cov-report=term-missing --no-cov-on-fail\n</code></pre> <ul> <li><code>DJANGO_SETTINGS_MODULE = conf.test_settings</code>: Specifies that <code>conf.test_settings.py</code> should be used for running tests. This file typically contains settings optimized for testing (e.g., using an in-memory database).</li> <li><code>python_files = tests.py test_*.py *_tests.py</code>: Defines the naming conventions for test files that <code>pytest</code> should discover.</li> <li><code>addopts</code>: Additional command-line options that are always passed to <code>pytest</code>:<ul> <li><code>--reuse-db</code>: Reuses the test database between test runs, significantly speeding up subsequent test executions.</li> <li><code>--nomigrations</code>: Prevents Django from running migrations during tests, assuming your test database schema is up-to-date.</li> <li><code>--cov=.</code>: Enables code coverage analysis for the entire project.</li> <li><code>--cov-report=html</code>: Generates an HTML report for code coverage, providing a visual breakdown of covered and uncovered lines.</li> <li><code>--cov-report=term-missing</code>: Displays missing coverage information directly in the terminal.</li> <li><code>--no-cov-on-fail</code>: Prevents coverage reporting if tests fail.</li> </ul> </li> </ul>"},{"location":"testing/#test-file-organization","title":"Test File Organization","text":"<p>Tests are organized by application within <code>tests/</code> directories. For example, tests for the <code>users</code> app are located in <code>apps/users/tests/</code>.</p> <ul> <li><code>apps/core/tests/</code>: Contains tests for core functionalities.</li> <li><code>apps/users/tests/</code>: Contains tests for user management and authentication.</li> </ul> <p>This structure keeps tests co-located with the code they test, making it easier to find and maintain them.</p>"},{"location":"testing/#running-tests","title":"Running Tests","text":"<p>To run tests, use the <code>poetry run pytest</code> command. The <code>pytest.ini</code> configuration will automatically apply the necessary options.</p>"},{"location":"testing/#basic-test-run","title":"Basic Test Run","text":"<p>To run all tests:</p> <pre><code>poetry run pytest\n</code></pre>"},{"location":"testing/#running-tests-with-coverage","title":"Running Tests with Coverage","text":"<p>To run tests and generate a code coverage report:</p> <pre><code>poetry run pytest --cov\n</code></pre> <p>This will output a summary of code coverage in the terminal. To generate a detailed HTML report (which you can open in your browser for a visual representation of coverage):</p> <pre><code>poetry run pytest --cov --cov-report=html\n</code></pre> <p>The HTML report will be generated in the <code>htmlcov/</code> directory in your project root.</p>"},{"location":"testing/#running-specific-tests","title":"Running Specific Tests","text":"<p>You can run specific test files or even individual test functions:</p> <ul> <li> <p>Run tests in a specific file:</p> <pre><code>poetry run pytest apps/users/tests/test_user_model.py\n</code></pre> </li> <li> <p>Run a specific test function:</p> <pre><code>poetry run pytest apps/users/tests/test_user_model.py::test_create_user\n</code></pre> </li> </ul>"},{"location":"testing/#best-practices","title":"Best Practices","text":"<ul> <li>Test Coverage: Aim for high test coverage, especially for critical business logic and API endpoints. The <code>--cov</code> option helps you track this.</li> <li>Fixtures: Utilize <code>pytest</code> fixtures to set up common test data and environments, promoting reusability and reducing boilerplate code.</li> <li>Clear Naming: Name your test files and functions clearly (e.g., <code>test_feature_name.py</code>, <code>test_function_behavior</code>) to make it easy to understand what each test covers.</li> <li>Isolation: Ensure your tests are isolated and do not depend on the state of previous tests. Use <code>pytest-django</code>'s transactional test cases or database cleanup mechanisms.</li> </ul>"}]}