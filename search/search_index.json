{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"Welcome to the Django Starter Template! <p> A comprehensive starting point for your new API with Django and DRF. </p>"},{"location":"#overview","title":"Overview","text":"<p>This documentation provides a comprehensive guide to the Django Starter Template, a robust foundation for building modern APIs with Django and Django REST Framework. It covers everything from initial setup and development workflows to advanced features like authentication, background tasks, and automated documentation.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>The recommended way to get started is by using Docker Compose.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>To get started, ensure you have the following installed:</p> <ul> <li>Docker Desktop</li> <li>uv (optional, for local IDE support)</li> </ul>"},{"location":"#setup-steps","title":"Setup Steps","text":"<p>Follow these steps to set up your development environment:</p> <ol> <li> <p>Use the GitHub Template: Begin by creating your own repository from the Django Starter Template GitHub page by clicking the green <code>Use this template</code> button.</p> </li> <li> <p>Clone Repository: Clone your newly created repository to your local machine.</p> </li> <li> <p>Start Services: Run <code>docker compose up</code> to start all services (PostgreSQL, Redis, Django, Celery).</p> </li> <li> <p>Run Migrations: In another terminal, run: <code>docker compose exec backend python manage.py migrate</code>.</p> </li> <li> <p>Create a Superuser: Create an administrative user for accessing the Django admin interface by running: <code>docker compose exec backend python manage.py createsuperuser</code>.</p> </li> <li> <p>Install Local Dependencies (Optional): For IDE support (IntelliSense, autocomplete), run: <code>uv sync</code>.</p> </li> </ol> <p>Your API should now be running and accessible at <code>http://127.0.0.1:8000</code>.</p>"},{"location":"#key-features","title":"Key Features","text":"<p>This template comes equipped with a rich set of features designed to accelerate your API development:</p> <ul> <li>User Authentication: Implements secure, token-based authentication using <code>django-rest-knox</code>, providing a robust system for user management and access control.</li> <li>Background Tasks: Leverages <code>Celery</code> and <code>Redis</code> for efficient asynchronous task processing, enabling your application to handle long-running operations without blocking the main thread.</li> <li>API Documentation: Features automatic OpenAPI 3 schema generation with <code>drf-spectacular</code>, ensuring your API documentation is always up-to-date and easily explorable via Swagger UI.</li> <li>Centralized Logging: Provides a structured JSON logging system for comprehensive and easily parsable application logs, facilitating monitoring and debugging.</li> <li>Custom User Model: Utilizes a custom user model with email-based authentication, offering flexibility and a modern approach to user identity.</li> <li>GitHub Copilot Prompts: Includes a collection of useful prompts tailored to enhance your development experience with GitHub Copilot, boosting productivity.</li> <li>Comprehensive Documentation: This documentation serves as a detailed guide to all features and functionalities, helping you maximize the template's potential.</li> </ul>"},{"location":"#explore-the-documentation","title":"Explore the Documentation","text":"<p>This documentation is your comprehensive guide to building robust applications with the Django Starter Template. Use the navigation on the left to explore various aspects of the project:</p> <ul> <li>Development: Learn about the development workflow, including how to run tests, and utilize provided scripts.</li> <li>Project Structure: Gain an overview of the project's directory structure and organization.</li> <li>Project Settings: Understand the available settings and how to configure your project for different environments.</li> <li>Dependencies: Review a detailed list of all the project's dependencies and their purposes.</li> <li>Authentication: Dive into the authentication system, covering user management and API endpoints.</li> <li>Core Application: Discover the core functionalities and essential API endpoints provided by the <code>apps/core</code> application.</li> <li>Logging: Understand the structured logging system and how to effectively use it for monitoring and debugging.</li> <li>Celery Tasks: Learn how to create, manage, and monitor background tasks using Celery.</li> <li>Rate Limiting: Configure and understand rate limiting to protect your API from abuse and ensure fair usage.</li> <li>Database Seeding: Learn how to populate your database with initial data for development and testing.</li> <li>Testing: Understand how to write and run tests for your project to ensure code quality and reliability.</li> <li>Environment Setup: Get detailed instructions on setting up your development environment.</li> <li>AI Tools: Explore useful prompts to enhance your development experience with GitHub Copilot, Gemini CLI agent, and Roo Code.</li> </ul>"},{"location":"authentication/","title":"Authentication System","text":""},{"location":"authentication/#overview","title":"Overview","text":"<p>This section provides a comprehensive guide to the authentication system implemented in the Django Starter Template. It covers the core authentication endpoints, security settings, and how token-based authentication is managed.</p>"},{"location":"authentication/#authentication-settings","title":"Authentication Settings","text":"<p>The following settings in <code>conf/settings.py</code> are relevant to authentication and user management:</p> <ul> <li> <p><code>AUTH_USER_MODEL</code>: Specifies the custom user model to use. Default: <code>users.CustomUser</code>. This allows you to extend Django's default user model with custom fields and behaviors.</p> </li> <li> <p><code>MIN_PASSWORD_LENGTH</code>: Minimum length for user passwords. Default: <code>8</code> (loaded from <code>env.int(\"MIN_PASSWORD_LENGTH\", default=8)</code>). This is used by the password validation system.</p> </li> <li> <p><code>PASSWORD_HASHERS</code>: A list of password hashing algorithms used for storing user passwords. Default: A list including <code>ScryptPasswordHasher</code>, <code>PBKDF2PasswordHasher</code>, <code>PBKDF2SHA1PasswordHasher</code>, <code>Argon2PasswordHasher</code>, and <code>BCryptSHA256PasswordHasher</code>. This provides strong password security.</p> </li> <li> <p><code>AUTH_PASSWORD_VALIDATORS</code>: Configures password validation rules. Default: Includes validators for user attribute similarity, minimum length, common passwords, and numeric passwords. You can customize these to enforce stronger password policies.</p> </li> </ul>"},{"location":"authentication/#token-based-authentication","title":"Token-Based Authentication","text":"<p>The template uses <code>django-rest-knox</code> for secure, token-based authentication. This system provides a robust way to manage authentication tokens for users. The following settings, configured under <code>REST_KNOX</code> in <code>conf/settings.py</code>, control its behavior:</p> <ul> <li><code>SECURE_HASH_ALGORITHM</code>: Specifies the hashing algorithm for tokens. Default: <code>hashlib.sha512</code>.</li> <li><code>AUTH_TOKEN_CHARACTER_LENGTH</code>: Defines the length of the authentication token. Default: <code>64</code>.</li> <li><code>TOKEN_TTL</code>: Sets the time-to-live for tokens, determining how long they remain valid. Default: <code>timedelta(hours=10)</code>.</li> <li><code>USER_SERIALIZER</code>: Indicates the serializer used for user profiles. Default: <code>apps.users.serializers.UserProfileSerializer</code>.</li> <li><code>TOKEN_LIMIT_PER_USER</code>: Allows limiting the number of active tokens a single user can have. Default: <code>None</code> (no limit).</li> <li><code>AUTO_REFRESH</code>: Controls whether tokens are automatically refreshed upon use. Default: <code>False</code>.</li> <li><code>AUTO_REFRESH_MAX_TTL</code>: Sets the maximum time-to-live for auto-refreshed tokens. Default: <code>None</code>.</li> <li><code>MIN_REFRESH_INTERVAL</code>: Defines the minimum interval between token refreshes in seconds. Default: <code>60</code> seconds.</li> <li><code>AUTH_HEADER_PREFIX</code>: Specifies the prefix for the Authorization header (e.g., <code>Bearer</code>). Default: <code>Bearer</code>.</li> <li><code>TOKEN_MODEL</code>: Refers to the token model used by Knox. Default: <code>knox.AuthToken</code>.</li> </ul>"},{"location":"authentication/#rest-framework-settings","title":"REST Framework Settings","text":"<p>Django REST Framework (DRF) settings, particularly authentication classes and throttle rates, are configured to manage API access and prevent abuse:</p> <ul> <li> <p><code>DEFAULT_AUTHENTICATION_CLASSES</code>: Defines the authentication methods available for API endpoints. Default: <code>knox.auth.TokenAuthentication</code>. In <code>DEBUG</code> mode, <code>SessionAuthentication</code> and <code>BasicAuthentication</code> are also enabled for convenience.</p> </li> <li> <p><code>DEFAULT_THROTTLE_RATES</code>: Configures rate limiting to control the number of requests users can make within a given timeframe. Default:</p> <ul> <li><code>user: \"1000/day\"</code> (authenticated users)</li> <li><code>anon: \"100/day\"</code> (unauthenticated users)</li> <li><code>user_login: \"5/minute\"</code> (specific throttle for login attempts)</li> </ul> </li> </ul> <p>These rates can be adjusted in <code>conf/settings.py</code> to suit your application's specific needs and security requirements.</p>"},{"location":"authentication/#authentication-endpoints","title":"Authentication Endpoints","text":""},{"location":"authentication/#create-user","title":"Create User","text":"<p>This endpoint allows for the registration of a new user account.</p> <p>Request:</p> <ul> <li>Method: <code>POST</code></li> <li>URL: <code>/auth/create/</code></li> <li>Body: <pre><code>{\n    \"email\": \"user@example.com\",\n    \"password\": \"complexpassword123\",\n    \"password2\": \"complexpassword123\"\n}\n</code></pre><ul> <li><code>email</code>: The user's unique email address.</li> <li><code>password</code>: The user's chosen password.</li> <li><code>password2</code>: Confirmation of the user's chosen password (must match <code>password</code>).</li> </ul> </li> </ul> <p>Responses:</p> <ul> <li> <p>Success (201 Created): <pre><code>{\n    \"email\": \"user@example.com\"\n}\n</code></pre></p> <ul> <li>Returns the email of the newly created user.</li> </ul> </li> <li> <p>Error (400 Bad Request):</p> <ul> <li>Passwords do not match: <pre><code>{\n    \"password\": [\n        \"Passwords do not match.\"\n    ]\n}\n</code></pre></li> <li>Email already registered: <pre><code>{\n    \"email\": [\n        \"This email is already registered.\"\n    ]\n}\n</code></pre></li> <li>Invalid password (e.g., too short, common password): <pre><code>{\n    \"password\": [\n        \"This password is too short. It must contain at least 8 characters.\"\n    ]\n}\n</code></pre></li> </ul> </li> <li>Error (401 Unauthorized):<ul> <li>This error typically occurs if authentication credentials are required for this endpoint (though usually not for user creation). <pre><code>{\n    \"detail\": \"Authentication credentials were not provided.\"\n}\n</code></pre></li> </ul> </li> </ul>"},{"location":"authentication/#login","title":"Login","text":"<p>This endpoint authenticates a user and issues an authentication token.</p> <p>Request:</p> <ul> <li>Method: <code>POST</code></li> <li>URL: <code>/auth/login/</code></li> <li>Body: <pre><code>{\n    \"email\": \"user@example.com\",\n    \"password\": \"complexpassword123\"\n}\n</code></pre><ul> <li><code>email</code>: The user's registered email address.</li> <li><code>password</code>: The user's password.</li> </ul> </li> </ul> <p>Responses:</p> <ul> <li> <p>Success (200 OK): <pre><code>{\n    \"expiry\": \"2025-07-09T12:00:00Z\",\n    \"token\": \"your-auth-token\",\n    \"user\": {\n        \"email\": \"user@example.com\",\n        \"first_name\": \"\",\n        \"last_name\": \"\"\n    }\n}\n</code></pre></p> <ul> <li><code>expiry</code>: The expiration timestamp of the token.</li> <li><code>token</code>: The authentication token to be used in subsequent requests.</li> <li><code>user</code>: A dictionary containing basic user profile information.</li> </ul> </li> <li> <p>Error (400 Bad Request):</p> <ul> <li>Invalid credentials: <pre><code>{\n    \"detail\": \"Unable to log in with provided credentials.\"\n}\n</code></pre></li> <li>Missing fields: <pre><code>{\n    \"email\": [\n        \"This field is required.\"\n    ],\n    \"password\": [\n        \"This field is required.\"\n    ]\n}\n</code></pre></li> </ul> </li> </ul>"},{"location":"authentication/#logout","title":"Logout","text":"<p>This endpoint logs out the currently authenticated user by invalidating their current authentication token.</p> <p>Request:</p> <ul> <li>Method: <code>POST</code></li> <li>URL: <code>/auth/logout/</code></li> <li>Authentication: Token required.</li> </ul> <p>Responses:</p> <ul> <li> <p>Success (204 No Content):</p> <ul> <li>The response will have an empty body, indicating successful token invalidation.</li> </ul> </li> <li> <p>Error (401 Unauthorized):</p> <ul> <li>Occurs if no authentication credentials are provided or if the token is invalid. <pre><code>{\n    \"detail\": \"Authentication credentials were not provided.\"\n}\n</code></pre></li> </ul> </li> </ul>"},{"location":"authentication/#logout-all","title":"Logout All","text":"<p>This endpoint invalidates all authentication tokens for the currently authenticated user, effectively logging them out from all devices.</p> <p>Request:</p> <ul> <li>Method: <code>POST</code></li> <li>URL: <code>/auth/logoutall/</code></li> <li>Authentication: Token required.</li> </ul> <p>Responses:</p> <ul> <li> <p>Success (204 No Content):</p> <ul> <li>The response will have an empty body, indicating that all tokens for the user have been invalidated.</li> </ul> </li> <li> <p>Error (401 Unauthorized):</p> <ul> <li>Occurs if no authentication credentials are provided or if the token is invalid. <pre><code>{\n    \"detail\": \"Authentication credentials were not provided.\"\n}\n</code></pre></li> </ul> </li> </ul>"},{"location":"authentication/#user-profile","title":"User Profile","text":"<p>This endpoint allows authenticated users to retrieve and update their profile information.</p>"},{"location":"authentication/#retrieve-user-profile","title":"Retrieve User Profile","text":"<p>Retrieves the profile of the currently authenticated user.</p> <p>Request:</p> <ul> <li>Method: <code>GET</code></li> <li>URL: <code>/auth/profile/</code></li> <li>Authentication: Token required.</li> </ul> <p>Responses:</p> <ul> <li> <p>Success (200 OK): <pre><code>{\n    \"email\": \"user@example.com\",\n    \"first_name\": \"John\",\n    \"last_name\": \"Doe\"\n}\n</code></pre></p> <ul> <li>Returns the user's email, first name, and last name.</li> </ul> </li> <li> <p>Error (401 Unauthorized):</p> <ul> <li>Occurs if no authentication credentials are provided or if the token is invalid. <code>json { \"detail\": \"Authentication credentials were not provided.\" }</code></li> </ul> </li> </ul>"},{"location":"authentication/#update-user-profile","title":"Update User Profile","text":"<p>Updates the entire profile of the currently authenticated user. All fields must be provided.</p> <p>Request:</p> <ul> <li>Method: <code>PUT</code></li> <li>URL: <code>/auth/profile/</code></li> <li>Authentication: Token required.</li> <li>Body: <pre><code>{\n    \"first_name\": \"Jane\",\n    \"last_name\": \"Doe\"\n}\n</code></pre><ul> <li><code>first_name</code>: The user's first name.</li> <li><code>last_name</code>: The user's last name.</li> </ul> </li> </ul> <p>Responses:</p> <ul> <li> <p>Success (200 OK): <pre><code>{\n    \"email\": \"user@example.com\",\n    \"first_name\": \"Jane\",\n    \"last_name\": \"Doe\"\n}\n</code></pre></p> <ul> <li>Returns the updated user profile.</li> </ul> </li> <li> <p>Error (400 Bad Request):</p> <ul> <li>Occurs if the provided data is invalid (e.g., password validation errors if password fields were included). <pre><code>{\n    \"password\": [\n        \"Password must be at least 8 characters long.\"\n    ]\n}\n</code></pre></li> </ul> </li> <li> <p>Error (401 Unauthorized):</p> <ul> <li>Occurs if no authentication credentials are provided or if the token is invalid. <code>json { \"detail\": \"Authentication credentials were not provided.\" }</code></li> </ul> </li> </ul>"},{"location":"authentication/#partially-update-user-profile","title":"Partially Update User Profile","text":"<p>Partially updates the profile of the currently authenticated user. Only the fields to be updated need to be provided.</p> <p>Request:</p> <ul> <li>Method: <code>PATCH</code></li> <li>URL: <code>/auth/profile/</code></li> <li>Authentication: Token required.</li> <li>Body: <pre><code>{\n    \"first_name\": \"Jane\"\n}\n</code></pre><ul> <li><code>first_name</code>: The user's first name (optional).</li> <li><code>last_name</code>: The user's last name (optional).</li> </ul> </li> </ul> <p>Responses:</p> <ul> <li> <p>Success (200 OK): <pre><code>{\n    \"email\": \"user@example.com\",\n    \"first_name\": \"Jane\",\n    \"last_name\": \"Doe\"\n}\n</code></pre></p> <ul> <li>Returns the partially updated user profile.</li> </ul> </li> <li> <p>Error (401 Unauthorized):</p> <ul> <li>Occurs if no authentication credentials are provided or if the token is invalid. <code>json { \"detail\": \"Authentication credentials were not provided.\" }</code></li> </ul> </li> </ul>"},{"location":"auto_documentation/","title":"API Auto-Documentation","text":""},{"location":"auto_documentation/#overview","title":"Overview","text":"<p>This section details the automatic API documentation system implemented in the Django Starter Template, which leverages <code>drf-spectacular</code> to generate OpenAPI 3 (Swagger) documentation. This ensures that your API documentation remains synchronized with your codebase, minimizing manual effort and potential inconsistencies.</p>"},{"location":"auto_documentation/#what-is-drf-spectacular","title":"What is <code>drf-spectacular</code>?","text":"<p><code>drf-spectacular</code> is a powerful library that integrates seamlessly with Django REST Framework to generate a comprehensive OpenAPI schema from your DRF views, serializers, and other components. This schema can then be used to render interactive API documentation (like Swagger UI) or generate client SDKs.</p>"},{"location":"auto_documentation/#how-its-used-in-this-project-best-practices","title":"How it's Used in This Project (Best Practices)","text":"<p>This template follows best practices for <code>drf-spectacular</code> integration to provide rich and accurate API documentation.</p>"},{"location":"auto_documentation/#1-centralized-schema-definitions","title":"1. Centralized Schema Definitions","text":"<p>Instead of defining all schema details directly within views, this project centralizes reusable schema components (like error responses and common examples) in dedicated <code>schema.py</code> files within each app (e.g., <code>apps/users/schema.py</code>, <code>apps/core/schema.py</code>).</p> <p>This promotes reusability and keeps your view logic clean. For example, common error responses are defined once and reused across multiple endpoints.</p> <pre><code># Example from apps/core/schema.py\nfrom drf_spectacular.utils import OpenApiExample, inline_serializer\nfrom rest_framework import serializers\n\nErrorResponseSerializer = inline_serializer(\n    name=\"ErrorResponse\",\n    fields={\n        \"detail\": serializers.CharField(read_only=True),\n        \"code\": serializers.CharField(read_only=True, required=False),\n    },\n)\n\nUNAUTHORIZED_EXAMPLES = [\n    OpenApiExample(\n        \"Unauthorized\",\n        value={\"detail\": \"Authentication credentials were not provided.\"},\n        status_codes=[\"401\"],\n    ),\n    # ... other examples\n]\n</code></pre>"},{"location":"auto_documentation/#2-extend_schema-decorator-for-views","title":"2. <code>extend_schema</code> Decorator for Views","text":"<p>The <code>extend_schema</code> decorator is used on API views to provide additional metadata that <code>drf-spectacular</code> cannot infer automatically. This includes:</p> <ul> <li>Responses: Defining expected success and error responses, often referencing the centralized schema definitions.</li> <li>Request Bodies: Specifying the structure of request payloads.</li> <li>Parameters: Documenting query parameters, path parameters, and headers.</li> <li>Description: Adding human-readable descriptions for endpoints.</li> </ul> <p>Example (from <code>apps/users/views.py</code> for LoginView):</p> <pre><code>from drf_spectacular.utils import extend_schema\n# ... other imports\n\n@extend_schema(responses=LOGIN_RESPONSE_SCHEMA)\nclass LoginView(KnoxLoginView):\n    # ... view implementation\n</code></pre> <p>Here, <code>LOGIN_RESPONSE_SCHEMA</code> is imported from <code>apps/users/schema.py</code>, ensuring consistency and reusability.</p>"},{"location":"auto_documentation/#3-spectacular_settings-in-confsettingspy","title":"3. <code>SPECTACULAR_SETTINGS</code> in <code>conf/settings.py</code>","text":"<p>Global settings for <code>drf-spectacular</code> are configured in <code>conf/settings.py</code> under the <code>SPECTACULAR_SETTINGS</code> dictionary. This includes basic API metadata like title, description, and version.</p> <pre><code># Example from conf/settings.py\nSPECTACULAR_SETTINGS = {\n    \"TITLE\": \"Django Starter Template\",\n    \"DESCRIPTION\": \"A comprehensive starting point for your new API with Django and DRF\",\n    \"VERSION\": \"0.1.0\",\n    \"SERVE_INCLUDE_SCHEMA\": False,\n}\n</code></pre>"},{"location":"auto_documentation/#4-interactive-swagger-ui","title":"4. Interactive Swagger UI","text":"<p>The generated OpenAPI schema is served via Swagger UI, providing an interactive and user-friendly interface to explore and test the API. You can access it at:</p> <p><code>/api/schema/swagger-ui/</code></p> <p>This endpoint is configured in <code>conf/urls.py</code>:</p> <pre><code># Example from conf/urls.py\nfrom drf_spectacular.views import SpectacularAPIView, SpectacularSwaggerView\n\nurlpatterns = [\n    # ... other urls\n]\n\nif settings.DEBUG:\n    urlpatterns += [\n        path(\"api/schema/\", SpectacularAPIView.as_view(), name=\"schema\"),\n        path(\n            \"api/schema/swagger-ui/\",\n            SpectacularSwaggerView.as_view(url_name=\"schema\"),\n            name=\"swagger-ui\",\n        ),\n    ]\n</code></pre> <p>By following these practices, the project ensures that its API documentation is robust, maintainable, and automatically generated, reflecting the true state of the API.</p>"},{"location":"core_endpoints/","title":"Core Application","text":""},{"location":"core_endpoints/#overview","title":"Overview","text":"<p>This section provides an overview of the Core application (<code>apps/core/</code>), which serves as a foundational component within the Django Starter Template. It encapsulates common utilities, middleware, base tasks, and essential API endpoints.</p>"},{"location":"core_endpoints/#key-functionalities","title":"Key Functionalities","text":"<p>The <code>apps/core/</code> directory includes the following key functionalities:</p> <ul> <li>Middleware: Contains custom middleware, such as <code>RequestIDMiddleware</code>, which enriches logs and responses with request-specific details like <code>request_id</code>, client IP, and response time.</li> <li>Tasks: Provides base Celery task classes, including <code>BaseTaskWithRetry</code>, which offers common functionalities like automatic retries for background tasks, enhancing task reliability.</li> <li>Schema: Defines common OpenAPI schema components and examples, promoting reusability and consistency across API documentation.</li> <li>Management Commands: Includes custom Django management commands, such as the <code>seed</code> command, designed for populating the database with sample data for development and testing purposes.</li> </ul>"},{"location":"core_endpoints/#api-endpoints","title":"API Endpoints","text":"<p>The Core application exposes the following API endpoints, all prefixed with <code>/core/</code>:</p>"},{"location":"core_endpoints/#ping","title":"Ping","text":"<p>This is a simple endpoint designed to verify that the server is operational and responsive.</p> <p>Request:</p> <ul> <li>Method: <code>GET</code></li> <li>URL: <code>/core/ping/</code></li> </ul> <p>Responses:</p> <ul> <li>Success (200 OK): <pre><code>{\n    \"ping\": \"pong\"\n}\n</code></pre><ul> <li>Returns a JSON object with a <code>ping</code> key and <code>pong</code> value, indicating a successful response.</li> </ul> </li> </ul>"},{"location":"core_endpoints/#fire-task","title":"Fire Task","text":"<p>This endpoint triggers a sample Celery task in the background. It's useful for testing the Celery setup and task execution.</p> <p>Request:</p> <ul> <li>Method: <code>GET</code></li> <li>URL: <code>/core/fire-task/</code></li> </ul> <p>Responses:</p> <ul> <li>Success (200 OK): <pre><code>{\n    \"task\": \"Task fired\"\n}\n</code></pre><ul> <li>Returns a confirmation that the task has been successfully initiated.</li> </ul> </li> </ul>"},{"location":"database_seeding/","title":"Database Seeding","text":"<p>Database seeding is the process of populating a database with initial data. This is particularly useful during development and testing phases to ensure your application has realistic data to work with, without having to manually create it.</p>"},{"location":"database_seeding/#why-use-database-seeding","title":"Why Use Database Seeding?","text":"<ul> <li>Development: Provides a quick way to set up a development environment with sample data, allowing developers to immediately start working on features without worrying about data entry.</li> <li>Testing: Ensures that your tests run against a consistent and representative dataset, making your tests more reliable and reproducible.</li> <li>Demonstrations: Useful for populating a database for demonstrations or presentations of your application.</li> </ul>"},{"location":"database_seeding/#the-seed-management-command","title":"The <code>seed</code> Management Command","text":"<p>This project includes a powerful custom Django management command, <code>seed</code>, located at <code>apps/core/management/commands/seed.py</code>. This command allows you to easily populate your database with sample user data.</p>"},{"location":"database_seeding/#usage","title":"Usage","text":"<p>To use the <code>seed</code> command with Docker Compose:</p> <pre><code>docker compose exec backend python manage.py seed [options]\n</code></pre> <p>Or if running locally:</p> <pre><code>python manage.py seed [options]\n</code></pre>"},{"location":"database_seeding/#available-options","title":"Available Options","text":"<p>The <code>seed</code> command supports the following arguments:</p> <ul> <li> <p><code>--users &lt;count&gt;</code>: Specifies the number of fake users to create. If not provided, it defaults to 10 users.</p> <ul> <li>Example: <code>docker compose exec backend python manage.py seed --users 50</code> (Creates 50 fake users)</li> </ul> </li> <li> <p><code>--superuser</code>: A flag that, when present, creates a superuser with predefined credentials (<code>admin@admin.com</code> / <code>admin</code>).</p> <ul> <li>Example: <code>python manage.py seed --superuser</code> (Creates an admin user)</li> </ul> </li> <li> <p><code>--clean</code>: A flag that, when present, deletes all existing non-superuser user data from the database before seeding. This is useful for starting with a fresh dataset.</p> <ul> <li>Example: <code>python manage.py seed --clean</code> (Deletes existing data before seeding)</li> </ul> </li> </ul>"},{"location":"database_seeding/#combined-examples","title":"Combined Examples","text":"<p>You can combine these options to achieve specific seeding scenarios:</p> <ul> <li> <p>Basic seeding with default options (creates 10 users):</p> <pre><code>python manage.py seed\n</code></pre> </li> <li> <p>Create specific number of users and a superuser:</p> <pre><code>python manage.py seed --users 20 --superuser\n</code></pre> </li> <li> <p>Clean existing data, create 50 users, and a superuser:</p> <pre><code>python manage.py seed --users 50 --superuser --clean\n</code></pre> </li> </ul>"},{"location":"database_seeding/#implementation-details","title":"Implementation Details","text":"<p>The <code>seed</code> command uses the <code>Faker</code> library to generate realistic-looking fake data for user profiles. It also utilizes Django's <code>transaction.atomic</code> decorator to ensure that the seeding process is atomic; if any part of the seeding fails, the entire operation is rolled back, preventing partial data corruption.</p>"},{"location":"dependencies/","title":"Project Dependencies","text":""},{"location":"dependencies/#overview","title":"Overview","text":"<p>This project utilizes uv as its dependency management tool. uv is an extremely fast Python package installer and resolver written in Rust by Astral (creators of Ruff). It ensures consistent project environments by managing dependencies, virtual environments, and packaging with 10-100x faster performance than traditional tools. All project dependencies are defined in the <code>pyproject.toml</code> file, categorized into main dependencies and development-specific dependencies.</p>"},{"location":"dependencies/#main-dependencies","title":"Main Dependencies","text":"<p>The following are the primary dependencies required for the application to run in production:</p> <ul> <li><code>python</code>: Specifies the compatible Python version. Version: <code>^3.13</code></li> <li><code>django</code>: The web framework for perfectionists with deadlines. Version: <code>^5.1.2</code></li> <li><code>django-environ</code>: Manages environment variables for Django settings. Version: <code>^0.12.0</code></li> <li><code>django-cors-headers</code>: Handles Cross-Origin Resource Sharing (CORS) headers. Version: <code>^4.5.0</code></li> <li><code>djangorestframework</code>: A powerful and flexible toolkit for building Web APIs. Version: <code>^3.15.2</code></li> <li><code>psycopg2</code>: PostgreSQL adapter for Python. Version: <code>^2.9.10</code></li> <li><code>whitenoise</code>: Serves static files efficiently in production. Version: <code>^6.7.0</code></li> <li><code>gunicorn</code>: A Python WSGI HTTP Server for UNIX. Version: <code>^23.0.0</code></li> <li><code>django-rest-knox</code>: Token-based authentication for Django REST Framework. Version: <code>^5.0.2</code></li> <li><code>redis</code>: Python client for Redis. Version: <code>^6.0.0</code></li> <li><code>celery</code>: Distributed task queue. Version: <code>^5.4.0</code></li> <li><code>django-celery-beat</code>: A periodic task scheduler for Celery. Version: <code>^2.7.0</code></li> <li><code>django-celery-results</code>: Stores Celery task results in Django models. Version: <code>^2.5.1</code></li> <li><code>sentry-sdk</code>: Official Sentry SDK for Python, with Django integration. Version: <code>^2.17.0</code></li> <li><code>django-redis</code>: Full-featured Redis cache backend for Django. Version: <code>^6.0.0</code></li> <li><code>drf-spectacular</code>: OpenAPI 3 schema generation for Django REST Framework. Version: <code>^0.28.0</code></li> <li><code>faker</code>: Generates fake data for testing and development. Version: <code>^37.1.0</code></li> <li><code>django-seed</code>: Populates Django database with random data. Version: <code>^0.3.1</code></li> <li><code>django-extensions</code>: A collection of custom extensions for Django. Version: <code>^4.1</code></li> <li><code>django-filter</code>: Reusable Django application for filtering querysets. Version: <code>^25.1</code></li> <li><code>python-json-logger</code>: A JSON formatter for Python logging. Version: <code>^3.3.0</code></li> </ul>"},{"location":"dependencies/#development-dependencies","title":"Development Dependencies","text":"<ul> <li>django-debug-toolbar: ^5.0.0</li> <li>pytest: ^8.3.3</li> <li>pytest-django: ^4.9.0</li> <li>ipykernel: ^6.29.5</li> <li>pytest-mock: ^3.14.0</li> <li>pytest-cov: ^6.0.0</li> <li>mkdocs: ^1.6.0</li> <li>mkdocs-material: ^9.5.26</li> </ul>"},{"location":"dependencies/#managing-dependencies","title":"Managing Dependencies","text":"<p>You can manage dependencies using the provided <code>make</code> shortcuts or directly with <code>uv</code>.</p>"},{"location":"dependencies/#adding-a-dependency","title":"Adding a Dependency","text":"<p>To add a new package to the project:</p> <p>Using Make: <pre><code>make add-dep pkg=package_name\n</code></pre></p> <p>Using uv: <pre><code>uv add package_name\n</code></pre></p> <p>Both methods will: 1. Add the package to <code>pyproject.toml</code> 2. Update <code>uv.lock</code></p>"},{"location":"dependencies/#removing-a-dependency","title":"Removing a Dependency","text":"<p>To remove a package from the project:</p> <p>Using Make: <pre><code>make remove-dep pkg=package_name\n</code></pre></p> <p>Using uv: <pre><code>uv remove package_name\n</code></pre></p> <p>Both methods will: 1. Remove the package from <code>pyproject.toml</code> 2. Update <code>uv.lock</code></p>"},{"location":"dependencies/#updating-dependencies","title":"Updating Dependencies","text":"<p>To update all dependencies to their latest allowed versions (respecting constraints in <code>pyproject.toml</code>):</p> <p>Using Make: <pre><code>make update-deps\n</code></pre></p> <p>Using uv: <pre><code>uv lock --upgrade\n</code></pre></p> <p>Both methods will update <code>uv.lock</code> with the latest versions.</p>"},{"location":"dependencies/#applying-changes","title":"Applying Changes","text":"<p>After any dependency change, you must rebuild the Docker container to install the new packages:</p> <pre><code>make rebuild\n</code></pre>"},{"location":"development/","title":"Development Workflow","text":""},{"location":"development/#overview","title":"Overview","text":"<p>This guide outlines the essential commands and best practices for developing your application within the Django Starter Template using Docker Compose.</p>"},{"location":"development/#development-setup","title":"Development Setup","text":""},{"location":"development/#docker-compose","title":"Docker Compose","text":"<p>This approach runs all services (PostgreSQL, Redis, Django, Celery) in Docker containers while you work on your local machine with full IDE support.</p> <p>1. (Optional) Create <code>.env</code> file:</p> <p>Docker Compose already defines environment variables, but if you need a local <code>.env</code> file:</p> <pre><code>cp .env.example .env\n</code></pre> <p>2. Start services: <pre><code>docker compose up\n# Or using make:\nmake up\n</code></pre></p> <p>This starts: - <code>db</code> - PostgreSQL database on port 5432 - <code>redis</code> - Redis cache on port 6379 - <code>backend</code> - Django development server on port 8000 - <code>worker</code> - Celery worker for background tasks - <code>beat</code> - Celery beat scheduler</p> <p>3. Enable IDE support (IntelliSense, autocomplete):</p> <p>For your IDE to recognize dependencies, install them locally:</p> <pre><code>uv sync --all-extras\n</code></pre> <p>This creates a local virtual environment that your IDE uses for: - Code completion and IntelliSense - Import resolution - Type checking - Linting and formatting</p> <p>Note: Your code still runs in Docker containers, but your IDE uses the local environment for editor features.</p> <p>4. Common tasks:</p> <p>The project includes a <code>Makefile</code> with shortcuts for common operations. Run <code>make help</code> to see all available commands.</p> <pre><code># Service Management\nmake up              # Start all services\nmake down            # Stop all services\nmake build           # Build Docker image\nmake rebuild         # Rebuild and restart\nmake ps              # Show running containers\n\n# Django Commands\nmake shell           # Open Django shell\nmake migrate         # Run migrations\nmake makemigrations  # Create migrations\nmake superuser       # Create superuser\nmake seed            # Seed database with test data\n\n# Testing &amp; Debugging\nmake test            # Run all tests\nmake test-cov        # Run tests with coverage\nmake logs            # View backend logs\nmake logs-worker     # View Celery worker logs\nmake logs-beat       # View Celery beat logs\n\n# Dependency Management\nmake update-deps     # Update all dependencies\nmake add-dep         # Add a new dependency (pkg=name)\nmake remove-dep      # Remove a dependency (pkg=name)\n\n# Maintenance\nmake clean           # Stop services and remove volumes\nmake prune           # Remove unused Docker resources\n</code></pre> <p>Traditional docker compose commands still work:</p> <pre><code># Run migrations\ndocker compose exec backend python manage.py migrate\n\n# Create migrations\ndocker compose exec backend python manage.py makemigrations\n\n# Create superuser\ndocker compose exec backend python manage.py createsuperuser\n\n# Run Django shell\ndocker compose exec backend python manage.py shell\n\n# View logs\ndocker compose logs -f backend\n\n# Rebuild containers after dependency changes\ndocker compose up --build\n\n# Stop all services\ndocker compose down\n</code></pre> <p>Important: If your <code>.env</code> file contains special characters like <code>$</code> in values (e.g., in <code>DJANGO_SECRET_KEY</code>), escape them with <code>$$</code> to prevent Docker Compose from treating them as variables:</p> <pre><code># Bad - Docker Compose interprets $d as a variable\nDJANGO_SECRET_KEY=secret-key-with-$d-in-it\n\n# Good - Escaped with $$\nDJANGO_SECRET_KEY=secret-key-with-$$d-in-it\n</code></pre>"},{"location":"development/#core-development-commands","title":"Core Development Commands","text":""},{"location":"development/#using-make-recommended","title":"Using Make (Recommended)","text":"<p>For faster development, use the provided <code>Makefile</code> shortcuts:</p> Make Command Description <code>make help</code> Show all available commands <code>make up</code> Start all services <code>make down</code> Stop all services <code>make migrate</code> Apply database migrations <code>make makemigrations</code> Create new migrations <code>make shell</code> Open Django shell <code>make test</code> Run test suite <code>make test-cov</code> Run tests with coverage <code>make logs</code> View backend logs <code>make seed</code> Seed database with test data"},{"location":"development/#using-docker-compose-directly","title":"Using Docker Compose Directly","text":"<p>You can also use docker compose commands directly:</p> Command Description <code>docker compose exec backend python manage.py runserver</code> Starts the Django development server (usually auto-started). <code>docker compose exec backend python manage.py makemigrations</code> Creates new database migrations based on model changes. <code>docker compose exec backend python manage.py migrate</code> Applies pending database migrations. <code>docker compose exec backend pytest</code> Runs the test suite using <code>pytest</code>. <code>docker compose exec backend pytest --cov</code> Runs the test suite and generates a coverage report."},{"location":"development/#testing","title":"Testing","text":"<p>The project utilizes <code>pytest</code> for its test suite. Below are common commands for running tests and generating coverage reports:</p> <ul> <li> <p>Run all tests (using make): <pre><code>make test\n</code></pre>     Executes the entire test suite.</p> </li> <li> <p>Run tests with coverage (using make): <pre><code>make test-cov\n</code></pre>     Runs all tests and collects code coverage information.</p> </li> <li> <p>Generate an HTML coverage report (using make): <pre><code>make test-html\n</code></pre>     Generates a detailed HTML report of code coverage in the <code>htmlcov/</code> directory.</p> </li> <li> <p>Using docker compose directly: <pre><code># Run all tests\ndocker compose exec backend pytest\n\n# Run tests with coverage\ndocker compose exec backend pytest --cov\n\n# Generate HTML coverage report\ndocker compose exec backend pytest --cov --cov-report=html\n</code></pre></p> </li> </ul>"},{"location":"development/#database-seeding","title":"Database Seeding","text":"<p>The template includes a powerful management command to populate your database with sample data, which is invaluable for development and testing. This command is part of the <code>apps/core/management/commands/seed.py</code> module.</p> <p>Usage with make (recommended):</p> <pre><code># Seed with 20 users + superuser, cleaning existing data\nmake seed\n</code></pre> <p>Usage with docker compose:</p> <pre><code># Basic seeding with default options (creates 10 users)\ndocker compose exec backend python manage.py seed\n\n# Create a specific number of users\ndocker compose exec backend python manage.py seed --users 20\n\n# Create a superuser (admin@admin.com:admin)\ndocker compose exec backend python manage.py seed --superuser\n\n# Clean existing data before seeding\ndocker compose exec backend python manage.py seed --clean\n\n# Combine options\ndocker compose exec backend python manage.py seed --users 50 --superuser --clean\n</code></pre> <p>Options:</p> <ul> <li><code>--users &lt;number&gt;</code>: Specifies the number of regular users to create. Default is 10.</li> <li><code>--superuser</code>: Creates a default superuser (<code>admin@admin.com</code> with password <code>admin</code>).</li> <li><code>--clean</code>: Cleans (deletes) existing seeded data before generating new data. Use with caution as this will remove all existing users and related data.</li> </ul>"},{"location":"development/#asynchronous-tasks-celery","title":"Asynchronous Tasks (Celery)","text":"<p>For handling background tasks and asynchronous operations, the project integrates Celery.</p> <p>With Docker Compose: Celery worker and beat are automatically started as separate services. Check their logs: <pre><code># Using make (recommended)\nmake logs-worker\nmake logs-beat\n\n# Using docker compose\ndocker compose logs -f worker\ndocker compose logs -f beat\n</code></pre></p> <p>Locally (if not using Docker Compose):</p> <ul> <li> <p>Start the Celery worker: <pre><code>celery -A conf worker -l info\n</code></pre>     This command starts a Celery worker process that executes tasks from the message queue.</p> </li> <li> <p>Start the Celery beat scheduler: <pre><code>celery -A conf beat -l info\n</code></pre>     This command starts the Celery beat scheduler, which is responsible for periodically executing scheduled tasks.</p> </li> </ul>"},{"location":"development/#environment-variables","title":"Environment Variables","text":"<p>Environment variables are managed using a <code>.env</code> file, which is crucial for configuring application settings without hardcoding sensitive information. The project uses <code>django-environ</code> to load these variables.</p> <ul> <li>Development <code>.env</code> file: Copy <code>.env.example</code> to <code>.env</code> and adjust values as needed for local development.</li> <li>Production <code>.env</code> file: For production deployments, refer to the <code>.env.example</code> file at the project root for a comprehensive list of all required environment variables and their descriptions. This file serves as a template for setting up your production environment.</li> </ul>"},{"location":"environment_setup/","title":"Environment Setup","text":"<p>This section explains how environment variables are used in the Django Starter Template and how to configure your project for both development and production environments.</p>"},{"location":"environment_setup/#environment-variables","title":"Environment Variables","text":"<p>Environment variables are a crucial part of modern application development, allowing you to configure your application's behavior without modifying the codebase. This is especially important for sensitive information (like API keys, database credentials) and for settings that vary between development, testing, and production environments.</p> <p>This project uses the <code>django-environ</code> library to manage environment variables. It reads variables from a <code>.env</code> file located in the project's root directory.</p>"},{"location":"environment_setup/#envexample","title":"<code>.env.example</code>","text":"<p>The <code>.env.example</code> file serves as a template for your <code>.env</code> file. It lists all the environment variables that your project expects, along with example values and comments explaining their purpose. Never commit your actual <code>.env</code> file to version control.</p> <pre><code># --------------------------------------------------------------------------------\n# \u26a1 Basic Config: for development and testing.\n# --------------------------------------------------------------------------------\nDEBUG=True\nDATABASE_URL=postgres://postgres:postgres@localhost:5432/postgres\nDJANGO_SECRET_KEY=django-insecure-wlgjuo53y49%-4y5(!%ksylle_ud%b=7%__@9hh+@$d%_^y3s!\n\n\n# --------------------------------------------------------------------------------\n# \ud83d\udce7 Email Config: optional and can be copied if needed.\n# --------------------------------------------------------------------------------\nEMAIL_HOST=smtp.gmail.com\nEMAIL_USE_TLS=True\nEMAIL_PORT=587\nEMAIL_HOST_USER=user@user.com\nEMAIL_HOST_PASSWORD=myverystrongpassword\n\n\n# --------------------------------------------------------------------------------\n# \ud83d\udd10 Security Config: for production or testing the production settings locally.\n# --------------------------------------------------------------------------------\nALLOWED_HOSTS=mysite.com,mysite2.com\nCORS_ALLOWED_ORIGINS=mysite.com,mysite2.com\nSENTRY_DSN=https://examplePublicKey@o0.ingest.sentry.io/0\n</code></pre> <p>To set up your environment, copy <code>.env.example</code> to <code>.env</code> and fill in the appropriate values:</p> <pre><code>cp .env.example .env\n</code></pre> <p>Important: If your environment variable values contain special characters like <code>$</code>, you must escape them with <code>$$</code> in the <code>.env</code> file when using Docker Compose. For example:</p> <pre><code># Incorrect - Docker Compose treats $d as a variable\nDJANGO_SECRET_KEY=django-insecure-abc@$d123\n\n# Correct - Escape $ with $$\nDJANGO_SECRET_KEY=django-insecure-abc@$$d123\n</code></pre> <p>This prevents Docker Compose from interpreting parts of your values as variable references.</p>"},{"location":"environment_setup/#development-environment","title":"Development Environment","text":"<p>For local development:</p>"},{"location":"environment_setup/#docker-compose","title":"Docker Compose","text":"<p>When using Docker Compose for development:</p> <ul> <li><code>DEBUG=True</code>: Enables Django's debug mode</li> <li><code>DATABASE_URL=postgres://postgres:postgres@db:5432/postgres</code>: Uses the containerized PostgreSQL service</li> <li><code>REDIS_URL=redis://redis:6379/0</code>: Uses the containerized Redis service</li> <li><code>CELERY_BROKER_URL=redis://redis:6379/0</code>: Celery connects to containerized Redis</li> <li><code>DJANGO_SECRET_KEY</code>: Use the development key from <code>.env.example</code></li> </ul> <p>The <code>.env</code> file is automatically loaded by Docker Compose. For IDE support (IntelliSense, code completion), also run:</p> <pre><code>uv sync\n</code></pre> <p>This installs dependencies locally so your IDE can provide autocomplete while your application runs in Docker containers.</p>"},{"location":"environment_setup/#production-environment","title":"Production Environment","text":"<p>For production deployments, it is critical to configure your environment variables securely and appropriately:</p> <ul> <li><code>DEBUG=False</code>: Always set to <code>False</code> in production. This disables debug mode, preventing sensitive information from being exposed in error pages.</li> <li><code>DJANGO_SECRET_KEY</code>: Generate a strong, unique secret key and store it securely. Never use the development secret key in production.</li> <li><code>ALLOWED_HOSTS</code>: A comma-separated list of domain names that your Django application will serve. Do not use <code>*</code> in production.</li> <li><code>DATABASE_URL</code>: The connection string for your production database.</li> <li><code>CORS_ALLOWED_ORIGINS</code>: A comma-separated list of origins that are allowed to make cross-origin requests to your API. Do not use <code>CORS_ALLOW_ALL_ORIGINS=True</code> in production.</li> <li><code>SENTRY_DSN</code>: Your Sentry Data Source Name (DSN) for error tracking and performance monitoring.</li> <li><code>EMAIL_HOST</code>, <code>EMAIL_USE_TLS</code>, <code>EMAIL_PORT</code>, <code>EMAIL_HOST_USER</code>, <code>EMAIL_HOST_PASSWORD</code>: Configure these for sending emails from your production environment.</li> </ul>"},{"location":"environment_setup/#example-production-env-conceptual","title":"Example Production <code>.env</code> (Conceptual)","text":"<pre><code>DEBUG=False\nDJANGO_SECRET_KEY=your_very_long_and_secure_production_secret_key\nALLOWED_HOSTS=api.yourdomain.com,www.yourdomain.com\nDATABASE_URL=postgres://user:password@db.yourdomain.com:5432/prod_db\nCORS_ALLOWED_ORIGINS=https://www.yourdomain.com,https://app.yourdomain.com\nSENTRY_DSN=https://your_sentry_public_key@o0.ingest.sentry.io/0\nEMAIL_HOST=smtp.sendgrid.net\nEMAIL_USE_TLS=True\nEMAIL_PORT=587\nEMAIL_HOST_USER=apikey\nEMAIL_HOST_PASSWORD=your_sendgrid_api_key\n</code></pre>"},{"location":"environment_setup/#managing-environment-variables","title":"Managing Environment Variables","text":"<p>It is recommended to use a tool or service provided by your deployment platform (e.g., Docker Compose, Kubernetes, Heroku, AWS Elastic Beanstalk) to manage and inject environment variables into your production environment. This ensures that sensitive information is not hardcoded or exposed in your codebase.</p>"},{"location":"logging/","title":"Logging System","text":"<p>This section details the logging system implemented in the Django Starter Template, which is designed for high-performance production environments using 12-Factor App methodology.</p>"},{"location":"logging/#overview","title":"Overview","text":"<p>The logging system is configured in <code>conf/settings.py</code> to stream all events to <code>stdout</code> (Console) in structured JSON format. This eliminates the need for managing local log files and integrating easily with modern container logging drivers (Docker, Kubernetes) and aggregators (Datadog, Splunk, CloudWatch).</p>"},{"location":"logging/#key-features","title":"Key Features","text":"<ul> <li>JSON Format: All logs are formatted as JSON, enabling machine readability and easier parsing.</li> <li>Console Only: Adheres to \"logs as event streams\" philosophy. No files are written to disk.</li> <li>Unified Logger: Centralized logger strategy simplifies configuration and prevents \"lost\" logs.</li> <li>Request Tracing: A modern, async-safe <code>RequestIDMiddleware</code> assigns a unique <code>request_id</code> to each request. This is stored in <code>ContextVars</code> (immune to thread-bleeding issues) and injected into every log line.</li> <li>Automatic Context: Every log entry automatically includes:<ul> <li><code>request_id</code></li> <li><code>client_ip</code></li> <li><code>user_id</code> (if authenticated)</li> <li><code>path</code></li> <li><code>response_time</code> (for completed requests)</li> </ul> </li> </ul>"},{"location":"logging/#log-levels-categories","title":"Log Levels &amp; Categories","text":"<p>The system uses three primary logger categories:</p> <ol> <li>Root (<code>\"\"</code>): format catching all third-party libraries.</li> <li>Framework (<code>\"django\"</code>): Captures internal framework events (DB queries, generic errors).</li> <li>Application (<code>\"apps\"</code>): Captures your business logic logs.</li> </ol>"},{"location":"logging/#how-to-log-in-your-code","title":"How to Log in Your Code","text":"<p>Do not use <code>print()</code>. Use the standard Python logging module with the <code>__name__</code> convention:</p> <pre><code>import logging\nlogger = logging.getLogger(__name__)\n\ndef my_view(request):\n    logger.info(\"Processing order %s\", order_id)\n    try:\n        ...\n    except ValueError as e:\n        logger.warning(\"Invalid input received: %s\", e)\n</code></pre> <p>Note: Always use lazy interpolation (e.g., <code>logger.info(\"Msg %s\", var)</code>), NOT f-strings, to improve performance.</p>"},{"location":"logging/#example-log-entry","title":"Example Log Entry","text":"<pre><code>{\n    \"asctime\": \"2026-01-23 20:29:08,372\",\n    \"levelname\": \"INFO\", \n    \"module\": \"apps.users.views\", \n    \"message\": \"User admin@admin.com logged in.\", \n    \"request_id\": \"2cecc66f-6cf1-4417-bbc8-af862bba999e\", \n    \"user_id\": \"anonymous\", \n    \"client\": \"192.168.97.1\",\n    \"path\": \"/auth/login/\"\n}\n</code></pre>"},{"location":"project_structure/","title":"Project Structure","text":""},{"location":"project_structure/#overview","title":"Overview","text":"<p>Understanding the project's directory structure is fundamental for navigating, developing, and maintaining the Django Starter Template. This document provides a detailed overview of the main directories and files, explaining their purpose and contents to help you quickly grasp the project's organization.</p> <pre><code>\u251c\u2500\u2500 .coveragerc                 # Coverage.py configuration\n\u251c\u2500\u2500 .env.example                # Example environment variables file\n\u251c\u2500\u2500 .flake8                     # Flake8 linter configuration\n\u251c\u2500\u2500 .github/                    # GitHub CI/CD workflows and issue templates\n\u251c\u2500\u2500 .gitignore                  # Git ignore file\n\u251c\u2500\u2500 .venv/                      # Virtual environment\n\u251c\u2500\u2500 .vscode/                    # IDE settings (VS Code configuration)\n\u251c\u2500\u2500 apps/                       # Django applications (core logic)\n\u2502   \u251c\u2500\u2500 core/                   # Core functionalities and shared components\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py         # Initializes the core app\n\u2502   \u2502   \u251c\u2500\u2500 admin.py            # Django admin configuration for core app\n\u2502   \u2502   \u251c\u2500\u2500 apps.py             # App configuration for core app\n\u2502   \u2502   \u251c\u2500\u2500 management/         # Custom Django management commands\n\u2502   \u2502   \u251c\u2500\u2500 middleware.py       # Custom middleware for core app\n\u2502   \u2502   \u251c\u2500\u2500 migrations/         # Database migrations for core app\n\u2502   \u2502   \u251c\u2500\u2500 schema.py           # OpenAPI schema definitions for core app\n\u2502   \u2502   \u251c\u2500\u2500 tasks.py            # Celery task definitions for core app\n\u2502   \u2502   \u251c\u2500\u2500 tests/              # Unit and integration tests for core app\n\u2502   \u2502   \u2514\u2500\u2500 urls.py             # URL routing for core app\n\u2502   \u2514\u2500\u2500 users/                  # User management and authentication app\n\u2502       \u251c\u2500\u2500 __init__.py         # Initializes the users app\n\u2502       \u251c\u2500\u2500 admin.py            # Django admin configuration for users app\n\u2502       \u251c\u2500\u2500 apps.py             # App configuration for users app\n\u2502       \u251c\u2500\u2500 forms.py            # Custom forms for users app\n\u2502       \u251c\u2500\u2500 managers.py         # Custom managers for user models\n\u2502       \u251c\u2500\u2500 migrations/         # Database migrations for users app\n\u2502       \u251c\u2500\u2500 models.py           # User model definition\n\u2502       \u251c\u2500\u2500 schema.py           # OpenAPI schema definitions for users app\n\u2502       \u251c\u2500\u2500 serializers.py      # Serializers for users app\n\u2502       \u251c\u2500\u2500 tests/              # Unit and integration tests for users app\n\u2502       \u251c\u2500\u2500 throttles.py        # Rate limiting configurations for user-related views\n\u2502       \u251c\u2500\u2500 urls.py             # URL routing for users app\n\u2502       \u251c\u2500\u2500 utils.py            # Utility functions for users app\n\u2502       \u2514\u2500\u2500 views.py            # API views for user authentication and profile management\n\u251c\u2500\u2500 conf/                       # Project-wide configuration\n\u2502   \u251c\u2500\u2500 __init__.py             # Initializes the conf module\n\u2502   \u251c\u2500\u2500 asgi.py                 # ASGI application entry point\n\u2502   \u251c\u2500\u2500 celery.py               # Celery application configuration\n\u2502   \u251c\u2500\u2500 settings.py             # Main Django settings file\n\u2502   \u251c\u2500\u2500 test_settings.py        # Settings specifically for running tests\n\u2502   \u251c\u2500\u2500 test_utils.py           # Test utilities\n\u2502   \u251c\u2500\u2500 urls.py                 # Main URL routing for the project\n\u2502   \u2514\u2500\u2500 wsgi.py                 # WSGI application entry point\n\u251c\u2500\u2500 docker-compose.yml          # Docker services configuration\n\u251c\u2500\u2500 Dockerfile                  # Docker build instructions\n\u251c\u2500\u2500 docs/                       # Documentation files\n\u251c\u2500\u2500 manage.py                   # Django's command-line utility\n\u251c\u2500\u2500 mkdocs.yml                  # MkDocs configuration\n\u251c\u2500\u2500 notebook.ipynb              # Jupyter Notebook for interactive development\n\u251c\u2500\u2500 uv.lock                     # uv lock file\n\u251c\u2500\u2500 pyproject.toml              # Project dependencies and metadata (uv)\n\u251c\u2500\u2500 pytest.ini                  # Pytest configuration\n\u251c\u2500\u2500 README.md                   # Project README file\n\u251c\u2500\u2500 renovate.json               # Renovate Bot configuration for dependency updates\n\u251c\u2500\u2500 scripts/                    # Utility scripts for various development tasks\n\u251c\u2500\u2500 static/                     # Static files (CSS, JavaScript, images)\n\u2514\u2500\u2500 templates/                  # Project-wide HTML templates\n</code></pre>"},{"location":"project_structure/#key-directories","title":"Key Directories","text":"<p>This section describes the primary directories within the project and their respective purposes:</p> <ul> <li> <p><code>.github/</code>: Stores GitHub-specific files, including GitHub Actions workflows for Continuous Integration (CI) and Continuous Deployment (CD), issue templates, and other repository settings. This directory automates various development processes.</p> </li> <li> <p><code>.vscode/</code>: Contains IDE configuration files for Visual Studio Code (optional). These settings can enhance the development experience by providing consistent formatting, linting, and debugging configurations for those using VS Code.</p> </li> <li> <p><code>apps/</code>: This is the core of your Django project, where individual Django applications (modules) reside. Each app is designed to be a self-contained unit responsible for a specific feature or set of features, promoting modularity and reusability.</p> <ul> <li><code>core/</code>: Houses fundamental functionalities and shared components that are used across different parts of the application. This includes custom management commands, base Celery tasks, and common API schema definitions, serving as a foundational app.</li> <li><code>users/</code>: Manages all aspects of user authentication and authorization. This includes user models, serializers, views, and related utilities for user registration, login, and profile management.</li> </ul> </li> <li> <p><code>conf/</code>: Contains project-wide configuration files that apply to the entire Django project, rather than being specific to a single app. This includes the main <code>settings.py</code>, URL routing (<code>urls.py</code>), ASGI/WSGI configurations, and Celery setup.</p> </li> <li> <p><code>scripts/</code>: A collection of utility scripts that automate various development and maintenance tasks. These scripts can include commands for running the server, managing migrations, or executing custom project-specific operations.</p> </li> <li> <p><code>static/</code>: Stores static assets such as CSS stylesheets, JavaScript files, and images. These files are typically served directly by the web server and are essential for the frontend of the application.</p> </li> <li> <p><code>templates/</code>: Contains project-wide HTML templates that are not specific to any single Django application. These templates can be used for common pages like error pages or base layouts.</p> </li> </ul>"},{"location":"project_structure/#key-files","title":"Key Files","text":"<p>This section outlines the most important files at the project root and their functions:</p> <ul> <li> <p><code>.env.example</code>: A template file that outlines all the environment variables required by the project. Developers should copy this to a <code>.env</code> file and fill in their specific values for local development, ensuring sensitive information is not hardcoded.</p> </li> <li> <p><code>manage.py</code>: Django's command-line utility for administrative tasks. This script is used for running the development server, performing database migrations, creating superusers, and executing custom management commands.</p> </li> <li> <p><code>pyproject.toml</code>: Used by uv (the dependency management tool) to define project metadata, dependencies, and build configurations. It serves as the central point for managing the project's Python environment.</p> </li> <li> <p><code>pytest.ini</code>: The configuration file for <code>pytest</code>, the testing framework used in this project. It specifies how tests should be discovered and run, including settings for code coverage analysis.</p> </li> <li> <p><code>README.md</code>: The main project documentation file, providing a high-level overview, quick start instructions, key features, and links to more detailed documentation. It's the first file new contributors typically read.</p> </li> </ul> <p>By adhering to this structured layout, the project promotes modularity, maintainability, and scalability, making it easier for developers to understand and contribute to the codebase.</p>"},{"location":"rate_limiting/","title":"Rate Limiting","text":"<p>Rate limiting is a crucial security and performance feature that controls the number of requests a user or IP address can make to your API within a given timeframe. It helps prevent abuse, brute-force attacks, and ensures fair usage of your API resources.</p>"},{"location":"rate_limiting/#why-use-rate-limiting","title":"Why Use Rate Limiting?","text":"<ul> <li>Security: Protects against brute-force attacks on login endpoints, denial-of-service (DoS) attacks, and excessive data scraping.</li> <li>Performance: Prevents a single user or malicious actor from overwhelming your server with too many requests, ensuring the API remains responsive for all legitimate users.</li> <li>Fair Usage: Ensures that API resources are distributed fairly among all users, preventing any single user from monopolizing resources.</li> </ul>"},{"location":"rate_limiting/#how-its-implemented","title":"How it's Implemented","text":"<p>This project uses Django REST Framework's built-in throttling mechanisms, along with a custom throttle class, to implement rate limiting.</p>"},{"location":"rate_limiting/#1-default-throttle-rates","title":"1. Default Throttle Rates","text":"<p>Global throttle rates are defined in <code>conf/settings.py</code> under the <code>REST_FRAMEWORK</code> dictionary. These rates are applied based on different scopes:</p> <pre><code># Example from conf/settings.py\nREST_FRAMEWORK = {\n    # ... other settings\n    \"DEFAULT_THROTTLE_RATES\": {\n        \"user\": \"1000/day\",\n        \"anon\": \"100/day\",\n        \"user_login\": \"5/minute\",\n    },\n}\n</code></pre> <ul> <li><code>user</code>: Applies to authenticated users. Default: <code>1000 requests per day</code>.</li> <li><code>anon</code>: Applies to unauthenticated (anonymous) users. Default: <code>100 requests per day</code>.</li> <li><code>user_login</code>: A custom scope specifically for login attempts. Default: <code>5 requests per minute</code>.</li> </ul>"},{"location":"rate_limiting/#2-custom-throttle-class","title":"2. Custom Throttle Class","text":"<p>For specific scenarios, like limiting login attempts, a custom throttle class (<code>apps/users/throttles.py</code>) is used. This allows for more granular control over how requests are identified and limited.</p> <pre><code># Example from apps/users/throttles.py\nfrom rest_framework.throttling import SimpleRateThrottle\n\nclass UserLoginRateThrottle(SimpleRateThrottle):\n    scope = \"user_login\"\n\n    def get_cache_key(self, request, view):\n        if not request.user.is_authenticated:\n            ident = self.get_ident(request) # Uses IP for anonymous users\n        else:\n            ident = request.user.pk # Uses user ID for authenticated users\n\n        return self.cache_format % {\"scope\": self.scope, \"ident\": ident}\n</code></pre> <p>This custom throttle ensures that:</p> <ul> <li>For anonymous users, rate limiting is based on their IP address.</li> <li>For authenticated users, rate limiting is based on their user ID.</li> </ul>"},{"location":"rate_limiting/#3-applying-throttles-to-views","title":"3. Applying Throttles to Views","text":"<p>Throttles are applied to DRF views using the <code>throttle_classes</code> attribute. This tells DRF which throttle policies to enforce for that specific view.</p> <p>Example (from <code>apps/users/views.py</code> for <code>LoginView</code> and <code>UserProfileView</code>):</p> <pre><code># For LoginView\nfrom rest_framework.throttling import AnonRateThrottle # Or other built-in throttles\nfrom .throttles import UserLoginRateThrottle\n\nclass LoginView(KnoxLoginView):\n    # ...\n    throttle_classes = [UserLoginRateThrottle]\n\n# For UserProfileView and CreateUserView\nfrom rest_framework import throttling\n\nclass UserProfileView(generics.RetrieveUpdateAPIView):\n    # ...\n    throttle_classes = [throttling.UserRateThrottle]\n\nclass CreateUserView(generics.CreateAPIView):\n    # ...\n    throttle_classes = [throttling.UserRateThrottle]\n</code></pre> <ul> <li><code>UserLoginRateThrottle</code>: Applied to the <code>LoginView</code> to limit login attempts.</li> <li><code>throttling.UserRateThrottle</code>: A built-in DRF throttle that applies the <code>user</code> scope rate (from <code>DEFAULT_THROTTLE_RATES</code>) to authenticated users. This is used for <code>UserProfileView</code> and <code>CreateUserView</code>.</li> </ul>"},{"location":"rate_limiting/#how-to-configure","title":"How to Configure","text":"<p>To adjust the rate limits for your API, modify the <code>DEFAULT_THROTTLE_RATES</code> dictionary in <code>conf/settings.py</code>.</p> <p>For example, to change the anonymous user rate limit to 50 requests per hour:</p> <pre><code># In conf/settings.py\nREST_FRAMEWORK = {\n    # ...\n    \"DEFAULT_THROTTLE_RATES\": {\n        \"user\": \"1000/day\",\n        \"anon\": \"50/hour\", # Changed from 100/day\n        \"user_login\": \"5/minute\",\n    },\n}\n</code></pre> <p>You can also create new custom throttle classes in <code>apps/users/throttles.py</code> (or a similar location) and apply them to specific views as needed.</p>"},{"location":"settings/","title":"Project Settings","text":""},{"location":"settings/#overview","title":"Overview","text":"<p>This document provides a comprehensive guide to the <code>conf/settings.py</code> file, which centralizes the configuration for the Django Starter Template. Understanding these settings is crucial for customizing and deploying your application effectively. The settings are organized into logical sections to facilitate navigation and comprehension.</p>"},{"location":"settings/#environment-variables","title":"Environment Variables","text":"<p>The project leverages <code>django-environ</code> to manage environment variables, ensuring that sensitive information and deployment-specific configurations are kept out of version control. Variables are loaded from a <code>.env</code> file located in the project root.</p> <p>Configuration Snippet:</p> <pre><code>import environ\n\nenv = environ.Env()\nroot_path = environ.Path(__file__) - 2\nenv.read_env(str(root_path.path(\".env\")))\n</code></pre> <p>Explanation:</p> <ul> <li><code>env = environ.Env()</code>: Initializes the environment reader, which provides methods to access environment variables with type casting.</li> <li><code>root_path</code>: Defines the base directory for resolving relative paths within the project. It's calculated as two levels up from the <code>settings.py</code> file's location.</li> <li><code>env.read_env()</code>: Reads variables from the <code>.env</code> file. When called without arguments, it automatically searches for a <code>.env</code> file in the current working directory or its parent directories.</li> </ul>"},{"location":"settings/#basic-configuration","title":"Basic Configuration","text":"<p>These are fundamental Django settings that define the core behavior of the application:</p> <ul> <li><code>ROOT_URLCONF</code>: Specifies the root URL configuration module for the project. Default: <code>conf.urls</code>. This tells Django where to find the main URL patterns that route incoming requests.</li> <li><code>WSGI_APPLICATION</code>: The full Python path to the WSGI application object. Default: <code>conf.wsgi.application</code>. This is the entry point for WSGI-compatible web servers (e.g., Gunicorn) to serve the Django application.</li> <li><code>DEBUG</code>: A boolean that controls Django's debug mode. Default: <code>False</code> (loaded from <code>env.bool(\"DEBUG\", default=False)</code>). When <code>True</code>, Django provides detailed error pages, automatically reloads code on changes, and enables other development-specific features. It is critical to set this to <code>False</code> in production environments for security and performance reasons.</li> </ul>"},{"location":"settings/#time-language","title":"Time &amp; Language","text":"<p>These settings control the localization and time zone behavior of the Django application:</p> <ul> <li><code>LANGUAGE_CODE</code>: The language code for this Django installation. Default: <code>en-us</code>. This setting influences the default language for Django's built-in messages, forms, and templates.</li> <li><code>TIME_ZONE</code>: The time zone for this installation. Default: <code>UTC</code>. Django uses this time zone for all datetime objects unless a specific timezone is explicitly activated (e.g., for a user's local time).</li> <li><code>USE_I18N</code>: A boolean that determines whether Django's internationalization system should be enabled. Default: <code>True</code>. When <code>True</code>, Django will look for translation files to provide localized content.</li> <li><code>USE_TZ</code>: A boolean that specifies whether Django's timezone support should be enabled. Default: <code>True</code>. When <code>True</code>, Django stores datetimes in UTC in the database and converts them to the appropriate local time zone for display, based on <code>TIME_ZONE</code> or user-specific settings.</li> </ul>"},{"location":"settings/#security-and-users","title":"Security and Users","text":"<p>This section covers critical security configurations and user model settings, essential for protecting your application and managing user accounts:</p> <ul> <li> <p><code>SECRET_KEY</code>: A unique secret key used for cryptographic signing in Django. Default: Loaded from the <code>DJANGO_SECRET_KEY</code> environment variable. This key must be kept absolutely secret and never hardcoded in version control.</p> <pre><code>SECRET_KEY = env(\"DJANGO_SECRET_KEY\")\n</code></pre> </li> <li> <p><code>ALLOWED_HOSTS</code>: A list of strings representing the host/domain names that this Django site can serve. Default: <code>[\"*\"]</code> (loaded from <code>env.list(\"ALLOWED_HOSTS\", default=[\"*\"])</code>). This is a crucial security measure to prevent HTTP Host header attacks. In production, always specify your exact domain names (e.g., <code>[\"api.example.com\"]</code>) and never use <code>\"*\"</code> for security reasons.</p> <pre><code>ALLOWED_HOSTS = env.list(\"ALLOWED_HOSTS\", default=[\"*\"])\n</code></pre> </li> <li> <p><code>AUTH_USER_MODEL</code>: Specifies the custom user model to be used by Django's authentication system. Default: <code>users.CustomUser</code>. This allows for extending Django's default user model with custom fields and behaviors tailored to your application's needs.</p> </li> <li><code>MIN_PASSWORD_LENGTH</code>: Defines the minimum length required for user passwords. Default: <code>8</code> (loaded from <code>env.int(\"MIN_PASSWORD_LENGTH\", default=8)</code>). This setting is integrated with Django's password validation system to enforce stronger password policies.</li> <li><code>PASSWORD_HASHERS</code>: A list of password hashing algorithms used for storing user passwords. Django attempts to use them in the order specified. Default: Includes <code>ScryptPasswordHasher</code>, <code>PBKDF2PasswordHasher</code>, <code>PBKDF2SHA1PasswordHasher</code>, <code>Argon2PasswordHasher</code>, and <code>BCryptSHA256PasswordHasher</code>. This provides robust password security by using modern, secure hashing algorithms.</li> <li><code>AUTH_PASSWORD_VALIDATORS</code>: Configures the rules for password validation. Default: Includes validators for user attribute similarity, minimum length, common passwords, and numeric passwords. These can be customized to enforce more stringent password policies.</li> </ul>"},{"location":"settings/#security-headers","title":"Security Headers","text":"<p>These settings configure various HTTP security headers to protect against common web vulnerabilities:</p> <ul> <li><code>SECURE_BROWSER_XSS_FILTER</code>: Enables the <code>X-XSS-Protection</code> header. Default: <code>True</code>. This helps protect against Cross-Site Scripting (XSS) attacks by enabling the browser's built-in XSS filter.</li> <li><code>SECURE_CONTENT_TYPE_NOSNIFF</code>: Enables the <code>X-Content-Type-Options</code> header. Default: <code>True</code>. This prevents browsers from MIME-sniffing a response away from the declared <code>Content-Type</code>, mitigating certain types of attacks.</li> <li><code>X_FRAME_OPTIONS</code>: Controls the <code>X-Frame-Options</code> header to prevent clickjacking attacks. Default: <code>DENY</code>. This means the page cannot be displayed in a frame, iframe, or object tag.</li> <li><code>CSRF_COOKIE_SECURE</code>: A boolean that determines whether the CSRF cookie should only be sent over HTTPS. Default: <code>True</code> if <code>DEBUG</code> is <code>False</code>, <code>False</code> otherwise. This should always be <code>True</code> in production environments to prevent cookie interception.</li> <li><code>SESSION_COOKIE_SECURE</code>: A boolean that determines whether the session cookie should only be sent over HTTPS. Default: <code>True</code> if <code>DEBUG</code> is <code>False</code>, <code>False</code> otherwise. Similar to <code>CSRF_COOKIE_SECURE</code>, this must be <code>True</code> in production for secure session management.</li> </ul>"},{"location":"settings/#databases","title":"Databases","text":"<p>Database connection settings are managed through the <code>DATABASE_URL</code> environment variable, which <code>django-environ</code> parses to configure the database connection.</p> <p>Configuration Snippet:</p> <pre><code>DJANGO_DATABASE_URL = env.db(\"DATABASE_URL\")\nDATABASES = {\"default\": DJANGO_DATABASE_URL}\n</code></pre> <p>Explanation:</p> <ul> <li><code>DJANGO_DATABASE_URL</code>: This variable holds the database connection string, which is parsed by <code>django-environ</code> to extract database credentials and settings. Default: Loaded from the <code>DATABASE_URL</code> environment variable.</li> <li><code>DATABASES</code>: A dictionary that contains all database configurations for the project. The <code>default</code> key specifies the primary database connection used by the application.</li> <li><code>DEFAULT_AUTO_FIELD</code>: Defines the type of primary key to use for models that do not explicitly specify one. Default: <code>django.db.models.BigAutoField</code>. This uses a 64-bit integer, which is generally preferred over the default <code>AutoField</code> (32-bit) to prevent potential integer overflow issues in large-scale applications.</li> </ul>"},{"location":"settings/#applications-configuration","title":"Applications Configuration","text":"<p>This section details the configuration of installed Django applications and middleware, which are crucial for defining the project's functionalities and request-response processing flow:</p> <ul> <li> <p><code>INSTALLED_APPS</code>: A list of strings specifying all Django applications enabled in this project. Default: This includes Django's built-in applications (e.g., <code>django.contrib.admin</code>, <code>django.contrib.auth</code>), essential third-party libraries (e.g., <code>whitenoise</code>, <code>rest_framework</code>, <code>knox</code>, <code>drf_spectacular</code>), and the project's local applications (<code>apps.users</code>, <code>apps.core</code>). This setting informs Django which application modules are active and should be loaded.</p> </li> <li> <p><code>MIDDLEWARE</code>: A list of middleware classes that process requests and responses globally across your Django application. Default: This typically includes security middleware, static files handling, session management, CORS headers, common utilities, CSRF protection, authentication, and custom middleware like <code>RequestIDMiddleware</code>. The order of middleware is critically important, as they are executed sequentially for incoming requests and in reverse order for outgoing responses.</p> </li> </ul>"},{"location":"settings/#templates","title":"Templates","text":"<p>These settings configure Django's template engine, which is responsible for rendering HTML and other content:</p> <ul> <li><code>BACKEND</code>: Specifies the template engine to be used. Default: <code>django.template.backends.django.DjangoTemplates</code>.</li> <li><code>DIRS</code>: A list of absolute paths to directories where Django should search for template files. Default: <code>[root_path(\"templates\")]</code>. This allows for project-wide templates to be organized outside of individual application directories.</li> <li><code>APP_DIRS</code>: A boolean that instructs Django to look for templates within the <code>templates</code> subdirectory of installed applications. Default: <code>True</code>. This is a convenient way to organize app-specific templates alongside their respective applications.</li> <li><code>OPTIONS</code>: A dictionary of additional options for the template engine. Default: Includes <code>context_processors</code> (functions that add variables to the template context, such as <code>debug</code>, <code>request</code>, <code>auth</code>, <code>messages</code>) and <code>builtins</code> (which register built-in template tags and filters for use in templates).</li> </ul>"},{"location":"settings/#rest-framework","title":"REST Framework","text":"<p>This section details the settings for Django REST Framework (DRF) and related tools for API development, authentication, and schema generation.</p>"},{"location":"settings/#token-based-authentication","title":"Token-Based Authentication","text":"<p>Configuration for <code>django-rest-knox</code>, the token-based authentication system used for secure API access:</p> <ul> <li><code>SECURE_HASH_ALGORITHM</code>: The hashing algorithm employed for generating and verifying authentication tokens. Default: <code>hashlib.sha512</code>.</li> <li><code>AUTH_TOKEN_CHARACTER_LENGTH</code>: Defines the length of the generated authentication tokens. Default: <code>64</code>.</li> <li><code>TOKEN_TTL</code>: Sets the time-to-live (TTL) for authentication tokens, determining how long a token remains valid after issuance. Default: <code>timedelta(hours=10)</code>.</li> <li><code>USER_SERIALIZER</code>: Specifies the serializer class used for user profiles when returning user-related data with tokens. Default: <code>apps.users.serializers.UserProfileSerializer</code>.</li> <li><code>TOKEN_LIMIT_PER_USER</code>: Allows limiting the number of active tokens a single user can possess simultaneously. Default: <code>None</code> (no limit).</li> <li><code>AUTO_REFRESH</code>: A boolean indicating whether tokens should be automatically refreshed upon use, extending their validity. Default: <code>False</code>.</li> <li><code>AUTO_REFRESH_MAX_TTL</code>: The maximum time-to-live for tokens that are automatically refreshed. Default: <code>None</code>.</li> <li><code>MIN_REFRESH_INTERVAL</code>: The minimum time interval (in seconds) that must pass between token refreshes. Default: <code>60</code> seconds.</li> <li><code>AUTH_HEADER_PREFIX</code>: The prefix expected in the <code>Authorization</code> HTTP header for token authentication (e.g., <code>Bearer &lt;token&gt;</code>). Default: <code>Bearer</code>.</li> <li><code>TOKEN_MODEL</code>: Refers to the Django model used by <code>django-rest-knox</code> to store authentication tokens. Default: <code>knox.AuthToken</code>.</li> </ul>"},{"location":"settings/#general-drf-settings","title":"General DRF Settings","text":"<p>Core settings for Django REST Framework, influencing how APIs behave, including authentication, filtering, and rendering:</p> <ul> <li><code>DEFAULT_AUTHENTICATION_CLASSES</code>: Defines the authentication methods available for API endpoints. Default: <code>knox.auth.TokenAuthentication</code>. In <code>DEBUG</code> mode, <code>SessionAuthentication</code> and <code>BasicAuthentication</code> are also included for development convenience.</li> <li><code>DEFAULT_FILTER_BACKENDS</code>: Specifies the default filter backends used for enabling filtering, searching, and ordering capabilities on API list views. Default: <code>django_filters.rest_framework.DjangoFilterBackend</code>, <code>rest_framework.filters.SearchFilter</code>, <code>rest_framework.filters.OrderingFilter</code>.</li> <li><code>DEFAULT_RENDERER_CLASSES</code>: Determines how API responses are rendered. Default: <code>rest_framework.renderers.JSONRenderer</code>. In <code>DEBUG</code> mode, <code>BrowsableAPIRenderer</code> is also added, providing a user-friendly HTML interface for API interaction.</li> <li><code>DEFAULT_SCHEMA_CLASS</code>: Integrates <code>drf-spectacular</code> for automatic OpenAPI schema generation. Default: <code>drf_spectacular.openapi.AutoSchema</code>.</li> <li><code>DEFAULT_THROTTLE_RATES</code>: Configures rate limiting for different types of users or requests, helping to prevent API abuse. Default: <code>user: \"1000/day\"</code> (authenticated users), <code>anon: \"100/day\"</code> (unauthenticated users), <code>user_login: \"5/minute\"</code> (specific throttle for login attempts).</li> </ul>"},{"location":"settings/#openapi-schema-generation","title":"OpenAPI Schema Generation","text":"<p>Settings for <code>drf-spectacular</code>, which generates OpenAPI 3 documentation for your API:</p> <ul> <li><code>TITLE</code>: The title displayed in your API documentation. Default: <code>Django Starter Template</code>.</li> <li><code>DESCRIPTION</code>: A brief description of your API, providing context for users of the documentation. Default: <code>A comprehensive starting point for your new API with Django and DRF</code>.</li> <li><code>VERSION</code>: The version number of your API. Default: <code>0.1.0</code>.</li> <li><code>SERVE_INCLUDE_SCHEMA</code>: A boolean indicating whether the raw OpenAPI schema endpoint should be included in the generated documentation. Default: <code>False</code>. Set to <code>True</code> if you want the raw schema to be directly accessible.</li> </ul>"},{"location":"settings/#cors-headers","title":"CORS Headers","text":"<p>Settings related to Cross-Origin Resource Sharing (CORS), managed by <code>django-cors-headers</code>:</p> <ul> <li><code>CORS_ALLOW_ALL_ORIGINS</code>: A boolean that, when <code>True</code>, allows requests from all origins. Default: <code>True</code> if <code>DEBUG</code> is <code>True</code>, <code>False</code> otherwise. For production environments, this should always be <code>False</code> for security reasons.</li> <li><code>CORS_ALLOWED_ORIGINS</code>: A list of allowed origins for CORS requests. This setting is active when <code>CORS_ALLOW_ALL_ORIGINS</code> is <code>False</code>. Default: Loaded from the <code>CORS_ALLOWED_ORIGINS</code> environment variable, allowing you to specify trusted domains.</li> </ul>"},{"location":"settings/#cache","title":"Cache","text":"<p>These settings configure the caching mechanism, primarily utilizing Redis for efficient data storage and retrieval:</p> <ul> <li><code>CACHES</code>: A dictionary defining the cache backends available to the project. Default: Includes a <code>default</code> cache configured to use <code>django_redis.cache.RedisCache</code>.</li> <li><code>LOCATION</code>: The connection URL for the Redis server. Default: <code>redis://redis:6379</code> (loaded from <code>env(\"REDIS_URL\", default=\"redis://redis:6379\")</code>). This specifies the address and port of your Redis instance.</li> <li><code>OPTIONS</code>: Additional options passed to the Redis client. Default: <code>{\"CLIENT_CLASS\": \"django_redis.client.DefaultClient\"}</code>. This can be used to customize the Redis client's behavior.</li> <li><code>USER_AGENTS_CACHE</code>: The cache alias to be used for caching user agent information. Default: <code>default</code>. This allows for efficient storage and retrieval of user agent strings.</li> </ul>"},{"location":"settings/#celery","title":"Celery","text":"<p>These settings configure Celery, the distributed task queue used for handling asynchronous tasks and periodic jobs:</p> <ul> <li><code>CELERY_BROKER_URL</code>: The URL for the Celery message broker, which facilitates communication between the application and Celery workers. Default: <code>redis://redis:6379</code> (loaded from <code>env(\"CELERY_BROKER_URL\", default=\"redis://redis:6379\")</code>).</li> <li><code>CELERY_RESULT_BACKEND</code>: Specifies where Celery task results are stored after a task completes. Default: <code>django-db</code> (loaded from <code>env(\"CELERY_RESULT_BACKEND\", default=\"django-db\")</code>). This means results are stored in the Django database.</li> <li><code>CELERY_BEAT_SCHEDULER</code>: Defines the scheduler for periodic tasks. Default: <code>django_celery_beat.schedulers.DatabaseScheduler</code>. This allows you to manage and schedule recurring tasks directly from the Django admin interface.</li> <li><code>CELERY_ACCEPT_CONTENT</code>: A list of accepted content types for tasks, ensuring secure deserialization. Default: <code>[\"application/json\"]</code>.</li> <li><code>CELERY_TASK_SERIALIZER</code>: The default serialization method used for tasks when they are sent to the broker. Default: <code>json</code>.</li> <li><code>CELERY_RESULT_SERIALIZER</code>: The default serialization method for task results when they are stored. Default: <code>json</code>.</li> <li><code>CELERY_TIMEZONE</code>: The timezone used by Celery for scheduling and executing tasks. Default: <code>America/Santiago</code>.</li> <li><code>CELERY_RESULT_EXTENDED</code>: A boolean that, when <code>True</code>, stores extended result information for tasks, providing more details about their execution. Default: <code>True</code>.</li> </ul>"},{"location":"settings/#email","title":"Email","text":"<p>These settings configure the email backend, enabling the application to send emails for various purposes (e.g., user registration, password resets):</p> <ul> <li><code>EMAIL_HOST</code>: The hostname or IP address of the SMTP server used for sending emails. Default: <code>smtp.gmail.com</code> (loaded from <code>env(\"EMAIL_HOST\", default=\"smtp.gmail.com\")</code>).</li> <li><code>EMAIL_USE_TLS</code>: A boolean that determines whether to use TLS (Transport Layer Security) for a secure connection to the SMTP server. Default: <code>True</code> (loaded from <code>env.bool(\"EMAIL_USE_TLS\", default=True)</code>). It is highly recommended to keep this <code>True</code> for production.</li> <li><code>EMAIL_PORT</code>: The port number for the SMTP server. Default: <code>587</code> (loaded from <code>env.int(\"EMAIL_PORT\", default=587)</code>). Common ports are 587 (for TLS) or 465 (for SSL).</li> <li><code>EMAIL_HOST_USER</code>: The username for authenticating with the SMTP server. Default: <code>\"\"</code> (loaded from <code>env(\"EMAIL_HOST_USER\", default=\"\")</code>). This should be set to your email account username.</li> <li><code>EMAIL_HOST_PASSWORD</code>: The password for authenticating with the SMTP server. Default: <code>\"\"</code> (loaded from <code>env(\"EMAIL_HOST_PASSWORD\", default=\"\")</code>). This should be set to your email account password or an application-specific password.</li> </ul>"},{"location":"settings/#sentry-and-logging","title":"Sentry and Logging","text":"<p>While the logging system has its own dedicated documentation page (Logging System), this section briefly covers settings related to error tracking with Sentry and general logging configurations:</p> <ul> <li><code>IGNORABLE_404_URLS</code>: A list of regular expressions for URLs that should not trigger 404 errors in logging or error reporting systems (like Sentry). Default: Includes patterns for common favicon and Apple touch icon requests, reducing noise in logs.</li> <li><code>LOGGING</code>: This dictionary contains the detailed configuration for the project's logging system. For a comprehensive understanding of how logging is set up and used, refer to the Logging System documentation.</li> <li><code>sentry_sdk.init()</code>: This function initializes the Sentry SDK for error tracking and performance monitoring. Default: It is conditionally initialized in production environments (when <code>DEBUG</code> is <code>False</code>) with parameters such as <code>dsn</code> (your Sentry project DSN), <code>traces_sample_rate=1.0</code> (for performance monitoring), and <code>profiles_sample_rate=1.0</code> (for profiling).</li> </ul>"},{"location":"settings/#static-media-files","title":"Static &amp; Media Files","text":"<p>These settings govern how static files (CSS, JavaScript, images) and user-uploaded media files are handled and served by the Django application:</p> <ul> <li><code>STORAGES</code>: Defines the storage backends for different types of files. Default: Uses <code>FileSystemStorage</code> for default file storage and <code>whitenoise.storage.CompressedManifestStaticFilesStorage</code> for static files, which handles compression and caching for production.</li> <li><code>STATIC_URL</code>: The URL prefix to use when referring to static files. Default: <code>/static/</code>. For example, if you have a static file <code>my_app/static/css/style.css</code>, it would be accessible at <code>/static/css/style.css</code>.</li> <li><code>STATICFILES_DIRS</code>: A list of directories where Django will search for additional static files, beyond those found within individual app's <code>static/</code> directories. Default: <code>[root_path(\"static\")]</code>.</li> <li><code>STATIC_ROOT</code>: The absolute path to the directory where Django's <code>collectstatic</code> command will gather all static files for deployment. Default: A temporary directory if <code>DEBUG</code> is <code>True</code>, otherwise a <code>static_root</code> directory within the project root. This directory should be served directly by your web server in production.</li> <li><code>MEDIA_URL</code>: The URL prefix that handles media files served from <code>MEDIA_ROOT</code>. Default: <code>/media/</code>. This is used for user-uploaded content.</li> <li><code>MEDIA_ROOT</code>: The absolute path to the directory where user-uploaded media files are stored. Default: A <code>media_root</code> directory within the project root. This directory should be configured for serving by your web server.</li> <li><code>ADMIN_MEDIA_PREFIX</code>: The URL prefix for Django admin's static media files. Default: <code>/static/admin/</code>.</li> </ul>"},{"location":"settings/#django-debug-toolbar-and-django-extensions","title":"Django Debug Toolbar and Django Extensions","text":"<p>These development-centric tools are conditionally enabled only when Django's <code>DEBUG</code> mode is active, providing valuable insights and utilities during development:</p> <ul> <li><code>debug_toolbar</code>: Integrates the Django Debug Toolbar, which provides a customizable debug panel for inspecting various aspects of your Django application (e.g., SQL queries, request/response headers, templates). Default: Automatically added to <code>INSTALLED_APPS</code> and <code>MIDDLEWARE</code> if <code>DEBUG</code> is <code>True</code>.</li> <li><code>INTERNAL_IPS</code>: A list of IP addresses that are considered \"internal\" for the Django Debug Toolbar. Requests originating from these IP addresses will display the debug toolbar. Default: <code>[\"127.0.0.1\"]</code>.</li> <li><code>django_extensions</code>: Provides a collection of custom extensions for Django, including a variety of useful management commands (e.g., <code>runserver_plus</code>, <code>shell_plus</code>). Default: Automatically added to <code>INSTALLED_APPS</code> if <code>DEBUG</code> is <code>True</code>.</li> </ul> <p>These settings are dynamically included in <code>INSTALLED_APPS</code> and <code>MIDDLEWARE</code> when <code>DEBUG</code> is <code>True</code>, ensuring they are only active in development environments.</p>"},{"location":"tasks/","title":"Celery Tasks","text":"<p>This section provides a comprehensive guide to working with Celery tasks in the Django Starter Template, including how to create, configure, and manage them, with a focus on retry mechanisms and periodic tasks.</p>"},{"location":"tasks/#overview","title":"Overview","text":"<p>Celery is an asynchronous task queue/job queue based on distributed message passing. It's used in this project to offload long-running operations from the main request-response cycle, improving application responsiveness and scalability.</p>"},{"location":"tasks/#configuration","title":"Configuration","text":"<p>Celery is configured in <code>conf/celery.py</code>. It integrates with Django's settings, allowing you to manage Celery-related configurations within your Django project.</p> <p>Key settings are typically found in <code>conf/settings.py</code>:</p> <ul> <li><code>CELERY_BROKER_URL</code>: The URL for the message broker (e.g., Redis).</li> <li><code>CELERY_RESULT_BACKEND</code>: Where task results are stored (e.g., Django database).</li> <li><code>CELERY_BEAT_SCHEDULER</code>: Specifies the scheduler for periodic tasks.</li> </ul>"},{"location":"tasks/#creating-new-tasks","title":"Creating New Tasks","text":"<p>To create a new Celery task, use the <code>@shared_task</code> decorator from <code>celery</code>.</p> <pre><code>from celery import shared_task\n\n@shared_task\ndef my_new_task(arg1, arg2):\n    # Your task logic here\n    print(f\"Executing my_new_task with {arg1} and {arg2}\")\n</code></pre> <p>Place your task definitions in <code>tasks.py</code> files within your Django apps (e.g., <code>apps/core/tasks.py</code>). Celery is configured to automatically discover tasks in installed apps.</p>"},{"location":"tasks/#task-retries","title":"Task Retries","text":"<p>The template provides a custom base task class, <code>BaseTaskWithRetry</code>, located in <code>apps/core/tasks.py</code>, which simplifies implementing retry logic for your tasks.</p>"},{"location":"tasks/#basetaskwithretry-attributes","title":"<code>BaseTaskWithRetry</code> Attributes","text":"<ul> <li><code>autoretry_for</code>: A tuple of exception types that should trigger a retry. If any of these exceptions occur during task execution, Celery will automatically retry the task.</li> <li><code>retry_kwargs</code>: A dictionary of keyword arguments passed to the <code>retry()</code> method. The most common is <code>max_retries</code>, which defines the maximum number of times the task will be retried.</li> <li><code>retry_backoff</code>: The initial delay in seconds before the first retry attempt. Subsequent retries will have an exponentially increasing delay.</li> <li><code>retry_jitter</code>: A boolean that, when <code>True</code>, adds a random component to the retry delay. This helps prevent all failed tasks from retrying simultaneously, which can lead to a \"thundering herd\" problem.</li> </ul>"},{"location":"tasks/#example-usage","title":"Example Usage","text":"<p>To use <code>BaseTaskWithRetry</code> for your task, simply set its <code>base</code> argument in the <code>@shared_task</code> decorator:</p> <pre><code>from celery import shared_task\nfrom apps.core.tasks import BaseTaskWithRetry\n\n@shared_task(bind=True, base=BaseTaskWithRetry)\ndef my_retriable_task(self):\n    try:\n        # Your task logic that might fail\n        result = 1 / 0 # Example of an error\n        return result\n    except Exception as e:\n        # Log the error or perform any necessary cleanup before retrying\n        print(f\"Task failed: {e}. Retrying...\")\n        raise self.retry(exc=e)\n</code></pre>"},{"location":"tasks/#calling-tasks","title":"Calling Tasks","text":"<p>Tasks can be called in a few ways:</p> <ul> <li> <p>Asynchronously (recommended for most cases):</p> <pre><code>my_new_task.delay(arg1_value, arg2_value)\n</code></pre> </li> <li> <p>With more control (e.g., setting a countdown or ETA):</p> <pre><code>from datetime import datetime, timedelta\n\n# Execute in 10 seconds\nmy_new_task.apply_async((arg1_value, arg2_value), countdown=10)\n\n# Execute at a specific time\neta_time = datetime.now() + timedelta(minutes=5)\nmy_new_task.apply_async((arg1_value, arg2_value), eta=eta_time)\n</code></pre> </li> </ul>"},{"location":"tasks/#periodic-tasks","title":"Periodic Tasks","text":"<p>Celery Beat is a scheduler that kicks off tasks periodically. In this project, periodic tasks are managed through the Django Admin interface.</p>"},{"location":"tasks/#steps-to-configure-a-periodic-task","title":"Steps to Configure a Periodic Task","text":"<ol> <li> <p>Start Celery Worker: Ensure your Celery worker is running (automatic with Docker Compose):</p> <pre><code>docker compose logs -f worker\n</code></pre> </li> <li> <p>Start Celery Beat: Ensure the Celery Beat scheduler is running (automatic with Docker Compose):</p> <pre><code>docker compose logs -f beat\n</code></pre> </li> <li> <p>Configure in Django Admin: Navigate to the Django Admin interface (<code>/admin-panel/</code>). Under the <code>DJANGO CELERY BEAT</code> section, you can add and manage <code>Periodic tasks</code>. You'll need to specify:</p> <ul> <li>The task name (e.g., <code>apps.core.tasks.my_periodic_task</code>).</li> <li>The schedule (e.g., every 5 minutes, daily, etc.).</li> <li>Any arguments or keyword arguments for the task.</li> </ul> </li> </ol>"},{"location":"tasks/#example-periodic-task","title":"Example Periodic Task","text":"<pre><code>from celery import shared_task\n\n@shared_task\ndef my_periodic_task():\n    print(\"This task runs periodically!\")\n</code></pre>"},{"location":"testing/","title":"Testing","text":"<p>This project uses <code>pytest</code> as its primary testing framework, integrated with <code>pytest-django</code> for seamless Django testing and <code>pytest-cov</code> for code coverage analysis. This setup ensures a robust and efficient testing environment.</p>"},{"location":"testing/#testing-setup","title":"Testing Setup","text":""},{"location":"testing/#pytestini-configuration","title":"<code>pytest.ini</code> Configuration","text":"<p>The <code>pytest.ini</code> file in the project root configures <code>pytest</code> behavior:</p> <pre><code>[pytest]\nDJANGO_SETTINGS_MODULE = conf.test_settings\npython_files = tests.py test_*.py *_tests.py\n\naddopts = --reuse-db --nomigrations --cov=. --cov-report=html --cov-report=term-missing --no-cov-on-fail\n</code></pre> <ul> <li><code>DJANGO_SETTINGS_MODULE = conf.test_settings</code>: Specifies that <code>conf.test_settings.py</code> should be used for running tests. This file typically contains settings optimized for testing (e.g., using an in-memory database).</li> <li><code>python_files = tests.py test_*.py *_tests.py</code>: Defines the naming conventions for test files that <code>pytest</code> should discover.</li> <li><code>addopts</code>: Additional command-line options that are always passed to <code>pytest</code>:<ul> <li><code>--reuse-db</code>: Reuses the test database between test runs, significantly speeding up subsequent test executions.</li> <li><code>--nomigrations</code>: Prevents Django from running migrations during tests, assuming your test database schema is up-to-date.</li> <li><code>--cov=.</code>: Enables code coverage analysis for the entire project.</li> <li><code>--cov-report=html</code>: Generates an HTML report for code coverage, providing a visual breakdown of covered and uncovered lines.</li> <li><code>--cov-report=term-missing</code>: Displays missing coverage information directly in the terminal.</li> <li><code>--no-cov-on-fail</code>: Prevents coverage reporting if tests fail.</li> </ul> </li> </ul>"},{"location":"testing/#test-file-organization","title":"Test File Organization","text":"<p>Tests are organized by application within <code>tests/</code> directories. For example, tests for the <code>users</code> app are located in <code>apps/users/tests/</code>.</p> <ul> <li><code>apps/core/tests/</code>: Contains tests for core functionalities.</li> <li><code>apps/users/tests/</code>: Contains tests for user management and authentication.</li> </ul> <p>This structure keeps tests co-located with the code they test, making it easier to find and maintain them.</p>"},{"location":"testing/#running-tests","title":"Running Tests","text":"<p>To run tests with Docker Compose, use <code>docker compose exec backend pytest</code>. The <code>pytest.ini</code> configuration will automatically apply the necessary options.</p>"},{"location":"testing/#basic-test-run","title":"Basic Test Run","text":"<p>To run all tests:</p> <pre><code>docker compose exec backend pytest\n</code></pre>"},{"location":"testing/#running-tests-with-coverage","title":"Running Tests with Coverage","text":"<p>To run tests and generate a code coverage report:</p> <pre><code>docker compose exec backend pytest --cov\n</code></pre> <p>This will output a summary of code coverage in the terminal. To generate a detailed HTML report (which you can open in your browser for a visual representation of coverage):</p> <pre><code>docker compose exec backend pytest --cov --cov-report=html\n</code></pre> <p>The HTML report will be generated in the <code>htmlcov/</code> directory in your project root.</p>"},{"location":"testing/#running-specific-tests","title":"Running Specific Tests","text":"<p>You can run specific test files or even individual test functions:</p> <ul> <li> <p>Run tests in a specific file:</p> <pre><code>docker compose exec backend pytest apps/users/tests/test_user_model.py\n</code></pre> </li> <li> <p>Run a specific test function:</p> <pre><code>docker compose exec backend pytest apps/users/tests/test_user_model.py::test_create_user\n</code></pre> </li> </ul>"},{"location":"testing/#best-practices","title":"Best Practices","text":"<ul> <li>Test Coverage: Aim for high test coverage, especially for critical business logic and API endpoints. The <code>--cov</code> option helps you track this.</li> <li>Fixtures: Utilize <code>pytest</code> fixtures to set up common test data and environments, promoting reusability and reducing boilerplate code.</li> <li>Clear Naming: Name your test files and functions clearly (e.g., <code>test_feature_name.py</code>, <code>test_function_behavior</code>) to make it easy to understand what each test covers.</li> <li>Isolation: Ensure your tests are isolated and do not depend on the state of previous tests. Use <code>pytest-django</code>'s transactional test cases or database cleanup mechanisms.</li> </ul>"},{"location":"ai_tools/","title":"AI Tools and CLI Agents","text":"<p>This section provides documentation on the various AI tools and CLI agents used in this project to enhance development, code quality, and automation.</p> <ul> <li>GitHub Copilot</li> </ul>"},{"location":"ai_tools/copilot/","title":"GitHub Copilot","text":"<p>This page provides detailed information and guidelines for using GitHub Copilot within this project.</p>"},{"location":"ai_tools/copilot/#technical-requirements-and-communication-standards","title":"Technical Requirements and Communication Standards","text":"<p>This project adheres to specific technical requirements and communication standards for Django backend development when using GitHub Copilot:</p> <p>Framework &amp; Core Dependencies: - Django 5.2+ with Django REST Framework - PostgreSQL database - Redis for caching - Authentication via django-rest-knox - API documentation using drf-spectacular - Testing framework: Pytest or Django/DRF TestCase</p> <p>Project Structure: - Test files must be placed in each app's <code>tests</code> directory - Follow Django's recommended project layout - Implement RESTful API patterns</p> <p>Development Guidelines: 1. All implementations must follow Django's best practices and security standards 2. Use Django REST Framework viewsets and serializers when building APIs 3. Implement proper authentication and permission checks using knox 4. Cache expensive operations using Redis 5. Document all APIs using OpenAPI/Swagger via drf-spectacular</p> <p>Testing Requirements: 1. Write comprehensive unit tests for all features 2. Follow Pytest conventions and patterns 3. Achieve minimum test coverage as per project standards 4. Include both positive and negative test scenarios</p> <p>Documentation: 1. Reference official Django and DRF documentation 2. Include docstrings for all classes and methods that have an important role 3. Document API endpoints using drf-spectacular decorators</p> <p>Response Format: 1. Provide direct, implementation-focused answers 2. Highlight any missing information needed for implementation 3. Include code examples only when explicitly requested 4. Format code according to PEP 8 standards</p> <ul> <li>Utilize context7 MCP for current documentation when applicable</li> </ul> <p>All responses must focus on technical implementation within these specifications and avoid theoretical discussions or alternative technology suggestions.</p>"},{"location":"ai_tools/copilot/#feature-prompt-featurepromptmd","title":"Feature Prompt (<code>feature.prompt.md</code>)","text":"<p>Purpose: Use this prompt when you need to plan and implement a new feature. It guides Copilot to think about the feature's overview, impact, implementation plan, code, and integration strategy.</p> <pre><code>As a professional developer, analyze and implement a new feature in the codebase following these guidelines:\n\n1. Feature Overview\n   - Describe the feature's core functionality and purpose\n   - List specific requirements and acceptance criteria\n   - Define expected inputs and outputs\n   - Specify performance targets and constraints\n\n2. Impact Analysis\n   - Identify affected components and dependencies\n   - Evaluate performance implications\n   - Assess security considerations\n   - Document potential risks and mitigations\n\n3. Implementation Plan\n   - Break down the feature into atomic tasks\n   - Specify interfaces and data structures\n   - Define error handling and edge cases\n   - List required test scenarios\n\n4. Code Implementation\n   - Provide code examples for each component\n   - Include inline documentation\n   - Follow project coding standards\n   - Implement necessary unit tests\n\n5. Integration Strategy\n   - Outline deployment steps\n   - Specify configuration changes\n   - Document API modifications\n   - Define rollback procedures\n\nInclude benchmark results, security review findings, and maintainability metrics for each implemented component. Prioritize clean architecture and SOLID principles.\n</code></pre>"},{"location":"ai_tools/copilot/#refactor-prompt-refactorpromptmd","title":"Refactor Prompt (<code>refactor.prompt.md</code>)","text":"<p>Purpose: Use this prompt when you want to refactor existing code. It directs Copilot to focus on performance, security, maintainability, and readability, providing a structured approach to code improvement.</p> <pre><code>As a senior software engineer, analyze the provided code and suggest specific refactoring improvements focusing on these key aspects:\n\n1. Performance:\n- Identify algorithmic inefficiencies\n- Optimize resource usage and memory management\n- Suggest caching strategies where applicable\n- Highlight potential bottlenecks\n\n2. Security:\n- Review for common vulnerabilities (OWASP Top 10)\n- Ensure proper input validation\n- Verify authentication and authorization\n- Check for secure data handling\n\n3. Maintainability:\n- Apply SOLID principles\n- Improve code organization and structure\n- Reduce technical debt\n- Enhance modularity and reusability\n\n4. Readability:\n- Follow language-specific style guides\n- Apply consistent naming conventions\n- Add meaningful comments and documentation\n- Break down complex logic into smaller functions\n\nFor each suggested improvement:\n- Explain the rationale\n- Provide a code example\n- Highlight potential trade-offs\n- Consider the impact on existing functionality\n\nPlease provide the code you want to refactor, and specify any constraints or requirements specific to your project's context.\n</code></pre>"},{"location":"ai_tools/copilot/#security-prompt-securitypromptmd","title":"Security Prompt (<code>security.prompt.md</code>)","text":"<p>Purpose: Use this prompt to conduct a security review of your API implementation. It guides Copilot to check for authentication, authorization, input validation, rate limiting, and security monitoring.</p> <pre><code>Conduct a comprehensive security review of the REST API implementation according to industry best practices. Review and implement the following security controls:\n\nAuthentication &amp; Authorization:\n- Verify JWT/OAuth2 authentication is properly implemented for all endpoints\n- Confirm role-based access control (RBAC) is enforced\n- Check token validation, expiration, and refresh mechanisms\n- Ensure sensitive endpoints require appropriate scopes/permissions\n\nInput Validation &amp; Sanitization:\n- Validate request parameters, headers, and body content\n- Implement strong input validation using a schema validator (e.g. JSON Schema)\n- Apply appropriate encoding for special characters\n- Prevent SQL injection, XSS, and CSRF attacks\n\nRate Limiting &amp; DDoS Protection:\n- Set appropriate rate limits per endpoint/user\n- Implement exponential backoff for failed attempts\n- Configure API gateway throttling rules\n- Document rate limit headers and responses\n\nSecurity Monitoring:\n- Enable detailed logging for authentication attempts\n- Track and alert on suspicious activity patterns\n- Log all administrative actions and data modifications\n- Implement audit trails for sensitive operations\n- Set up automated security scanning and penetration testing\n\nFollow OWASP API Security Top 10 guidelines and document any findings in a security assessment report.\n\nReferences:\n- OWASP API Security Top 10: https://owasp.org/www-project-api-security/\n- NIST Security Guidelines for Web Services\n</code></pre>"},{"location":"ai_tools/copilot/#test-model-prompt-test-modelpromptmd","title":"Test Model Prompt (<code>test-model.prompt.md</code>)","text":"<p>Purpose: Use this prompt when writing tests for Django models. It ensures comprehensive test coverage for field validation, relationships, data operations, edge cases, and performance.</p> <pre><code>Write comprehensive model tests for Django applications adhering to the following specifications:\n\n## Test Structure\n- Organize tests in `tests/test_&lt;model_name&gt;.py` within each Django app\n- Implement tests using pytest or Django TestCase\n- Follow PEP 8 and Django coding standards\n\n## Required Test Coverage\n\n### 1. Field Validation\n- Test all model field constraints:\n  - Required fields (null/blank)\n  - Field type validations\n  - Length/range restrictions\n  - Custom validators\n  - Unique constraints\n  - Index effectiveness\n\n### 2. Relationships\n- Validate ForeignKey constraints\n- Test ManyToMany relationship behaviors\n- Verify cascading operations\n- Check related field access patterns\n\n### 3. Data Operations\n- Test CRUD operations\n- Verify bulk operations performance\n- Validate custom manager methods\n- Test model-specific business logic\n- Check complex queries and filters\n\n### 4. Edge Cases\n- Test boundary conditions\n- Include negative test scenarios\n- Validate error handling\n- Check race conditions\n\n### 5. Performance\n- Benchmark query execution times\n- Test with representative data volumes\n- Verify index usage\n- Monitor memory consumption\n\n## Documentation\n- Add descriptive docstrings\n- Document test fixtures\n- Explain complex test scenarios\n- Reference expected behaviors\n\n## References\n- Django Testing Documentation: https://docs.djangoproject.com/en/stable/topics/testing/\n- pytest-django: https://pytest-django.readthedocs.io/\n\nUse appropriate fixtures and mocking strategies to ensure tests are isolated and repeatable.\n</code></pre>"},{"location":"ai_tools/copilot/#test-view-prompt-test-viewpromptmd","title":"Test View Prompt (<code>test-view.prompt.md</code>)","text":"<p>Purpose: Use this prompt when writing tests for Django REST framework API views. It ensures comprehensive test coverage for authentication, security, HTTP methods, response validation, and edge cases.</p> <pre><code>Generate comprehensive test suite for Django REST framework API views following these requirements:\n\n1. Test Location and Framework:\n   - Place tests in the `tests` directory within each Django app\n   - Use Pytest or Django/DRF TestCase as the testing framework\n   - Follow the `test_&lt;view_name&gt;.py` naming convention\n\n2. Authentication &amp; Security Tests:\n   - Verify authentication requirements for each endpoint\n   - Test authorization rules and permissions\n   - Validate rate limiting functionality\n   - Test request throttling behavior\n\n3. HTTP Method Coverage:\n   - Test all CRUD operations: GET, POST, PUT, PATCH, DELETE\n   - Verify correct HTTP status codes (200, 201, 204, 400, 401, 403, 404, etc.)\n   - Include both successful and error scenarios\n   - Test request payload validation\n\n4. Response Validation:\n   - Verify response structure and data types\n   - Check serializer field validation\n   - Test pagination if implemented\n   - Validate filtering and sorting functionality\n\n5. Documentation Requirements:\n   - Include docstrings describing test purpose\n   - Document test data and fixtures\n   - Add comments for complex test scenarios\n\n6. Edge Cases:\n   - Test boundary conditions\n   - Include negative testing scenarios\n   - Verify error message formats\n\nReference Django REST framework testing documentation for best practices:\nhttps://www.django-rest-framework.org/api-guide/testing/\n</code></pre>"},{"location":"ai_tools/copilot/#reusable-prompts","title":"Reusable Prompts","text":"<p>Specific reusable prompts for various tasks are located in the <code>.github/prompts/</code> directory of the repository: *   <code>feature.prompt.md</code> - For planning and implementing new features *   <code>refactor.prompt.md</code> - For code refactoring improvements *   <code>security.prompt.md</code> - For security analysis and hardening *   <code>test-model.prompt.md</code> - For model testing *   <code>test-view.prompt.md</code> - For view testing</p>"}]}